[
    {
        "data": {
            "function_name": "exractAndLoad",
            "function_code": "private boolean exractAndLoad(ArrayList<String> errors, String version, String customPath, String resourcePath) {\n        URL resource = classLoader.getResource(resourcePath);\n        if( resource !=null ) {\n            \n            String libName = name + \"-\" + getBitModel();\n            if( version !=null) {\n                libName += \"-\" + version;\n            }\n            \n            if( customPath!=null ) {\n                // Try to extract it to the custom path...\n                File target = file(customPath, map(libName));\n                if( extract(errors, resource, target) ) {\n                    if( load(errors, target) ) {\n                        return true;\n                    }\n                }\n            }\n            \n            // Fall back to extracting to the tmp dir\n            customPath = System.getProperty(\"java.io.tmpdir\");\n            File target = file(customPath, map(libName));\n            if( extract(errors, resource, target) ) {\n                if( load(errors, target) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
            "commit_message": "Simplify shared lib extraction."
        },
        "CWE": "CWE-94",
        "CVE": "CVE-2013-2035"
    },
    {
        "data": {
            "function_name": "run",
            "function_code": "protected int run() throws Exception {\n        Jenkins h = Jenkins.getInstance();\n        h.checkPermission(Item.CREATE);\n\n        if (h.getItemByFullName(name)!=null) {\n            stderr.println(\"Job '\"+name+\"' already exists\");\n            return -1;\n        }\n\n        ModifiableTopLevelItemGroup ig = h;\n        int i = name.lastIndexOf('/');\n        if (i > 0) {\n            String group = name.substring(0, i);\n            Item item = h.getItemByFullName(group);\n            if (item == null) {\n                throw new IllegalArgumentException(\"Unknown ItemGroup \" + group);\n            }\n\n            if (item instanceof ModifiableTopLevelItemGroup) {\n                ig = (ModifiableTopLevelItemGroup) item;\n            } else {\n                throw new IllegalArgumentException(\"Can't create job from CLI in \" + group);\n            }\n            name = name.substring(i + 1);\n        }\n\n        ig.createProjectFromXML(name, stdin);\n        return 0;\n    }",
            "commit_message": "[FIXED SECURITY-108] Check job name created via CLI"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2014-2059"
    },
    {
        "data": {
            "function_name": "getShortDescription",
            "function_code": "@Exported(visibility=3)\n    public abstract String getShortDescription();",
            "commit_message": "[FIXED SECURITY-74] Apply markup formatter to remote cause note."
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2014-2067"
    },
    {
        "data": {
            "function_name": "init",
            "function_code": "public void init(FilterConfig filterConfig) throws ServletException {\n        servletContext = filterConfig.getServletContext();\n        servletMajorVersion = servletContext.getMajorVersion();\n    }",
            "commit_message": "RF-13250: applying patch"
        },
        "CWE": "CWE-20",
        "CVE": "CVE-2014-0086"
    },
    {
        "data": {
            "function_name": "resolveAction",
            "function_code": "protected String resolveAction() throws JspException {\n\t\tString action = getAction();\n\t\tString servletRelativeAction = getServletRelativeAction();\n\t\tif (StringUtils.hasText(action)) {\n\t\t\taction = getDisplayString(evaluate(ACTION_ATTRIBUTE, action));\n\t\t\treturn processAction(action);\n\t\t}\n\t\telse if (StringUtils.hasText(servletRelativeAction)) {\n\t\t\tString pathToServlet = getRequestContext().getPathToServlet();\n\t\t\tif (servletRelativeAction.startsWith(\"/\") && !servletRelativeAction.startsWith(getRequestContext().getContextPath())) {\n\t\t\t\tservletRelativeAction = pathToServlet + servletRelativeAction;\n\t\t\t}\n\t\t\tservletRelativeAction = getDisplayString(evaluate(ACTION_ATTRIBUTE, servletRelativeAction));\n\t\t\treturn processAction(servletRelativeAction);\n\t\t}\n\t\telse {\n\t\t\tString requestUri = getRequestContext().getRequestUri();\n\t\t\tServletResponse response = this.pageContext.getResponse();\n\t\t\tif (response instanceof HttpServletResponse) {\n\t\t\t\trequestUri = ((HttpServletResponse) response).encodeURL(requestUri);\n\t\t\t\tString queryString = getRequestContext().getQueryString();\n\t\t\t\tif (StringUtils.hasText(queryString)) {\n\t\t\t\t\trequestUri += \"?\" + HtmlUtils.htmlEscape(queryString);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (StringUtils.hasText(requestUri)) {\n\t\t\t\treturn processAction(requestUri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Attribute 'action' is required. \" +\n\t\t\t\t\t\t\"Attempted to resolve against current request URI but request URI was null.\");\n\t\t\t}\n\t\t}\n\t}",
            "commit_message": "Add encoding for the default action in FormTag\n\nIssue: SPR-11426"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2014-1904"
    },
    {
        "data": {
            "function_name": "resolveAction",
            "function_code": "protected String resolveAction() throws JspException {\n\t\tString action = getAction();\n\t\tString servletRelativeAction = getServletRelativeAction();\n\t\tif (StringUtils.hasText(action)) {\n\t\t\taction = getDisplayString(evaluate(ACTION_ATTRIBUTE, action));\n\t\t\treturn processAction(action);\n\t\t}\n\t\telse if (StringUtils.hasText(servletRelativeAction)) {\n\t\t\tString pathToServlet = getRequestContext().getPathToServlet();\n\t\t\tif (servletRelativeAction.startsWith(\"/\") && !servletRelativeAction.startsWith(getRequestContext().getContextPath())) {\n\t\t\t\tservletRelativeAction = pathToServlet + servletRelativeAction;\n\t\t\t}\n\t\t\tservletRelativeAction = getDisplayString(evaluate(ACTION_ATTRIBUTE, servletRelativeAction));\n\t\t\treturn processAction(servletRelativeAction);\n\t\t}\n\t\telse {\n\t\t\tString requestUri = getRequestContext().getRequestUri();\n\t\t\tServletResponse response = this.pageContext.getResponse();\n\t\t\tif (response instanceof HttpServletResponse) {\n\t\t\t\trequestUri = ((HttpServletResponse) response).encodeURL(requestUri);\n\t\t\t\tString queryString = getRequestContext().getQueryString();\n\t\t\t\tif (StringUtils.hasText(queryString)) {\n\t\t\t\t\trequestUri += \"?\" + HtmlUtils.htmlEscape(queryString);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (StringUtils.hasText(requestUri)) {\n\t\t\t\treturn processAction(requestUri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Attribute 'action' is required. \" +\n\t\t\t\t\t\t\"Attempted to resolve against current request URI but request URI was null.\");\n\t\t\t}\n\t\t}\n\t}",
            "commit_message": "Add encoding for the default action in FormTag\n\nIssue: SPR-11426"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2014-1904"
    },
    {
        "data": {
            "function_name": "unwrapNonAppData",
            "function_code": "private void unwrapNonAppData(ChannelHandlerContext ctx, Channel channel) throws SSLException {\n        unwrap(ctx, channel, ChannelBuffers.EMPTY_BUFFER, EMPTY_BUFFER, -1);\n    }",
            "commit_message": "Fix a bug where SslHandler does not handle SSLv2Hello correctly\n\nMotivation:\n\nWhen a SSLv2Hello message is received, SSLEngine expects the application buffer size to be more than 30KB which is larger than what SslBufferPool can provide.  SSLEngine will always return with BUFFER_OVERFLOW status, blocking the SSL session from continuing the handshake.\n\nModifications:\n\nWhen SSLEngine.getSession().getApplicationBufferSize() returns a value larger than what SslBufferPool provides, allocate a temporary heap buffer.\n\nResult:\n\nSSLv2Hello is handled correctly."
        },
        "CWE": "CWE-119",
        "CVE": "CVE-2014-3488"
    },
    {
        "data": {
            "function_name": "doHeapDump",
            "function_code": "@WebMethod(name=\"heapdump.hprof\")\n        public void doHeapDump(StaplerRequest req, StaplerResponse rsp) throws IOException, InterruptedException {\n            owner.checkPermission(Jenkins.ADMINISTER);\n            rsp.setContentType(\"application/octet-stream\");\n\n            FilePath dump = obtain();\n            try {\n                dump.copyTo(rsp.getCompressedOutputStream(req));\n            } finally {\n                dump.delete();\n            }\n        }",
            "commit_message": "[FIXED SECURITY-73] Require RUN_SCRIPTS for /heapDump."
        },
        "CWE": "CWE-264",
        "CVE": "CVE-2014-2068"
    },
    {
        "data": {
            "function_name": "authenticate",
            "function_code": "@Override\n    protected Details authenticate(String username, String password) throws AuthenticationException {\n        Details u = loadUserByUsername(username);\n        if (!u.isPasswordCorrect(password))\n            throw new BadCredentialsException(\"Failed to login as \"+username);\n        return u;\n    }",
            "commit_message": "[FIXED SECURITY-79] Prevent (private security realm) usernames from being guessed."
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2014-2064"
    },
    {
        "data": {
            "function_name": "onSuccessfulAuthentication",
            "function_code": "@Override\n    protected void onSuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, Authentication authResult) throws IOException {\n        super.onSuccessfulAuthentication(request,response,authResult);\n        // make sure we have a session to store this successful authentication, given that we no longer\n        // let HttpSessionContextIntegrationFilter2 to create sessions.\n        // HttpSessionContextIntegrationFilter stores the updated SecurityContext object into this session later\n        // (either when a redirect is issued, via its HttpResponseWrapper, or when the execution returns to its\n        // doFilter method.\n        request.getSession();\n    }",
            "commit_message": "[FIXED SECURITY-75] Invalidate session after login to avoid session fixation"
        },
        "CWE": "CWE-287",
        "CVE": "CVE-2014-2066"
    },
    {
        "data": {
            "function_name": "submit",
            "function_code": "@Override\n    protected void submit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {\n        super.submit(req,rsp);\n        JSONObject json = req.getSubmittedForm();\n\n        makeDisabled(req.getParameter(\"disable\")!=null);\n\n        jdk = req.getParameter(\"jdk\");\n        if(req.getParameter(\"hasCustomQuietPeriod\")!=null) {\n            quietPeriod = Integer.parseInt(req.getParameter(\"quiet_period\"));\n        } else {\n            quietPeriod = null;\n        }\n        if(req.getParameter(\"hasCustomScmCheckoutRetryCount\")!=null) {\n            scmCheckoutRetryCount = Integer.parseInt(req.getParameter(\"scmCheckoutRetryCount\"));\n        } else {\n            scmCheckoutRetryCount = null;\n        }\n        blockBuildWhenDownstreamBuilding = req.getParameter(\"blockBuildWhenDownstreamBuilding\")!=null;\n        blockBuildWhenUpstreamBuilding = req.getParameter(\"blockBuildWhenUpstreamBuilding\")!=null;\n\n        if(req.hasParameter(\"customWorkspace\")) {\n            customWorkspace = Util.fixEmptyAndTrim(req.getParameter(\"customWorkspace.directory\"));\n        } else {\n            customWorkspace = null;\n        }\n\n        if (json.has(\"scmCheckoutStrategy\"))\n            scmCheckoutStrategy = req.bindJSON(SCMCheckoutStrategy.class,\n                json.getJSONObject(\"scmCheckoutStrategy\"));\n        else\n            scmCheckoutStrategy = null;\n\n        \n        if(req.getParameter(\"hasSlaveAffinity\")!=null) {\n            assignedNode = Util.fixEmptyAndTrim(req.getParameter(\"_.assignedLabelString\"));\n        } else {\n            assignedNode = null;\n        }\n        canRoam = assignedNode==null;\n\n        concurrentBuild = req.getSubmittedForm().has(\"concurrentBuild\");\n\n        authToken = BuildAuthorizationToken.create(req);\n\n        setScm(SCMS.parseSCM(req,this));\n\n        for (Trigger t : triggers())\n            t.stop();\n        triggers = buildDescribable(req, Trigger.for_(this));\n        for (Trigger t : triggers)\n            t.start(this,true);\n\n        for (Publisher _t : Descriptor.newInstancesFromHeteroList(req, json, \"publisher\", Jenkins.getInstance().getExtensionList(BuildTrigger.DescriptorImpl.class))) {\n            BuildTrigger t = (BuildTrigger) _t;\n            for (AbstractProject downstream : t.getChildProjects(this)) {\n                downstream.checkPermission(BUILD);\n            }\n        }\n    }",
            "commit_message": "[FIXED SECURITY-109] SECURITY-55 fix to BuildTrigger configuration failed if downstream project was not visible."
        },
        "CWE": "CWE-264",
        "CVE": "CVE-2014-2058"
    },
    {
        "data": {
            "function_name": "doFilter",
            "function_code": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse rsp = (HttpServletResponse) response;\n        String authorization = req.getHeader(\"Authorization\");\n\n        if (authorization!=null) {\n            // authenticate the user\n            String uidpassword = Scrambler.descramble(authorization.substring(6));\n            int idx = uidpassword.indexOf(':');\n            if (idx >= 0) {\n                String username = uidpassword.substring(0, idx);\n                String password = uidpassword.substring(idx+1);\n\n                // attempt to authenticate as API token\n                User u = User.get(username);\n                ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n                if (t!=null && t.matchesPassword(password)) {\n                    // even if we fail to match the password, we aren't rejecting it.\n                    // as the user might be passing in a real password.\n                    SecurityContext oldContext = ACL.impersonate(u.impersonate());\n                    try {\n                        request.setAttribute(ApiTokenProperty.class.getName(), u);\n                        chain.doFilter(request,response);\n                        return;\n                    } finally {\n                        SecurityContextHolder.setContext(oldContext);\n                    }\n                }\n            }\n        }\n\n        chain.doFilter(request,response);\n    }",
            "commit_message": "[FIXED SECURITY-89] When checking an API token, verify that the user actually exists."
        },
        "CWE": "CWE-287",
        "CVE": "CVE-2014-2062"
    },
    {
        "data": {
            "function_name": "processControlCommand",
            "function_code": "@Override\n    public Response processControlCommand(ControlCommand command) throws Exception {\n        String control = command.getCommand();\n        if (control != null && control.equals(\"shutdown\")) {\n            System.exit(0);\n        }\n        return null;\n    }",
            "commit_message": "Remove unused ConnectionControl handling."
        },
        "CWE": "CWE-264",
        "CVE": "CVE-2014-3576"
    },
    {
        "data": {
            "function_name": "getInstance",
            "function_code": "public static OHttpSessionManager getInstance() {\n     return instance;\n   }",
            "commit_message": "Adopted SecureRandom to avoid predicable random numbers in session"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2015-2913"
    },
    {
        "data": {
            "function_name": "toString",
            "function_code": "public String toString() {\n\t\treturn \"'this' reference (XThis) to Bsh object: \" + namespace;\n\t}",
            "commit_message": "Avoid (de)serialization of XThis.Handler"
        },
        "CWE": "CWE-19",
        "CVE": "CVE-2016-2510"
    },
    {
        "data": {
            "function_name": "getStringParameterSQL",
            "function_code": "@Override\n    public String getStringParameterSQL(String param) {\n        return \"'\" + param + \"'\";\n    }",
            "commit_message": "DASHBUILDE-113: SQL Injection on data set lookup filters"
        },
        "CWE": "CWE-89",
        "CVE": "CVE-2016-4999"
    },
    {
        "data": {
            "function_name": "processPacket",
            "function_code": "@Override\n\t\t\tpublic void processPacket(Packet packet) {\n\t\t\t\tif (packet == null) return;\n\n\t\t\t\tif (packet instanceof IQ && packet.getFrom() != null) {\n\t\t\t\t\tIQ ping = (IQ)packet;\n\t\t\t\t\tString from_bare = getBareJID(ping.getFrom());\n\t\t\t\t\t// check for ping error or RESULT\n\t\t\t\t\tif (ping.getType() == Type.RESULT && mucJIDs.contains(from_bare)) {\n\t\t\t\t\t\tLog.d(TAG, \"Ping: got response from MUC \" + from_bare);\n\t\t\t\t\t\tmucLastPong.put(from_bare, System.currentTimeMillis());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mPingID != null && mPingID.equals(packet.getPacketID()))\n\t\t\t\t\tgotServerPong(packet.getPacketID());\n\n\t\t\t}",
            "commit_message": "Smackable: improved carbon checks"
        },
        "CWE": "CWE-20",
        "CVE": "CVE-2017-5589"
    },
    {
        "data": {
            "function_name": "onTaskSelectionEvent",
            "function_code": "public void onTaskSelectionEvent(@Observes TaskSelectionEvent event){\n        selectedTaskId = event.getTaskId();\n        selectedTaskName = event.getTaskName();\n        \n        view.getTaskIdAndName().setText(String.valueOf(selectedTaskId) + \" - \"+selectedTaskName);\n        \n        view.getContent().clear();\n        \n        String placeToGo;\n        if(event.getPlace() != null && !event.getPlace().equals(\"\")){\n            placeToGo = event.getPlace();\n        }else{\n            placeToGo = \"Task Details\";\n        }\n        \n        \n\n        DefaultPlaceRequest defaultPlaceRequest = new DefaultPlaceRequest(placeToGo);\n        //Set Parameters here: \n        defaultPlaceRequest.addParameter(\"taskId\", String.valueOf(selectedTaskId));\n        defaultPlaceRequest.addParameter(\"taskName\", selectedTaskName);\n\n        Set<Activity> activities = activityManager.getActivities(defaultPlaceRequest);\n        AbstractWorkbenchScreenActivity activity = ((AbstractWorkbenchScreenActivity) activities.iterator().next());\n        \n        activitiesMap.put(placeToGo, activity);\n        \n        IsWidget widget = activity.getWidget();\n        activity.launch(place, null);\n        activity.onStartup(defaultPlaceRequest);\n        view.getContent().add(widget);\n        activity.onOpen();\n    }",
            "commit_message": "BZ-1049109: escaping task name html inputs"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2013-6465"
    },
    {
        "data": {
            "function_name": "doesNotContainFileColon",
            "function_code": "private static boolean doesNotContainFileColon(String path) {\n        return !path.contains(\"file:\");\n    }",
            "commit_message": "Fix for #981, patch 2 (#988)"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2018-9159"
    },
    {
        "data": {
            "function_name": "all",
            "function_code": "protected Collection<TopLevelItem> all() { return getAllItems(TopLevelItem.class); }",
            "commit_message": "Merge pull request #96 from jenkinsci-cert/SECURITY-385\n\n[SECURITY-385] Only suggest visible views in search"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2017-2609"
    },
    {
        "data": {
            "function_name": "getUser",
            "function_code": "public User getUser() {\n            return user;\n        }",
            "commit_message": "Merge pull request #80 from jenkinsci-cert/SECURITY-362\n\n[SECURITY-362] Do not persist User in OfflineCause.UserCause"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2017-2603"
    },
    {
        "data": {
            "function_name": "getSearchUrl",
            "function_code": "public String getSearchUrl() {\n        return getUrl();\n    }",
            "commit_message": "Merge pull request #82 from jenkinsci-cert/security-343\n\n[SECURITY-343] Restrict API access to NodeMonitor data"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2017-2600"
    },
    {
        "data": {
            "function_name": "getItems",
            "function_code": "@Exported(name=\"jobs\")\n    public List<TopLevelItem> getItems() {\n        if (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||\n            authorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {\n            return new ArrayList(items.values());\n        }\n\n        List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n        for (TopLevelItem item : items.values()) {\n            if (item.hasPermission(Item.READ))\n                viewableItems.add(item);\n        }\n\n        return viewableItems;\n    }",
            "commit_message": "Merge pull request #86 from jenkinsci-cert/SECURITY-380\n\n[FIX SECURITY-380] Don't optimize permission check in getItems()"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2017-2606"
    },
    {
        "data": {
            "function_name": "getItems",
            "function_code": "@Exported(name=\"jobs\")\n    public List<TopLevelItem> getItems() {\n        if (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||\n            authorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {\n            return new ArrayList(items.values());\n        }\n\n        List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n        for (TopLevelItem item : items.values()) {\n            if (item.hasPermission(Item.READ))\n                viewableItems.add(item);\n        }\n\n        return viewableItems;\n    }",
            "commit_message": "Merge pull request #86 from jenkinsci-cert/SECURITY-380\n\n[FIX SECURITY-380] Don't optimize permission check in getItems()"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2017-2606"
    },
    {
        "data": {
            "function_name": "doWorkspaceCleanup",
            "function_code": "@RequirePOST\n    public void doWorkspaceCleanup(StaplerResponse rsp) throws IOException {\n        WorkspaceCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }",
            "commit_message": "Merge pull request #99 from jenkinsci-cert/SECURITY-389\n\n[SECURITY-389] Check ADMINISTER on /fingerprintCleanup and /workspaceCleanup"
        },
        "CWE": "CWE-275",
        "CVE": "CVE-2017-2611"
    },
    {
        "data": {
            "function_name": "parseSoapMethodName",
            "function_code": "private static String parseSoapMethodName(InputStream stream, String charEncoding) {\n\t\ttry {\n\t\t\t// newInstance() et pas newFactory() pour java 1.5 (issue 367)\n\t\t\tfinal XMLInputFactory factory = XMLInputFactory.newInstance();\n\t\t\tfinal XMLStreamReader xmlReader;\n\t\t\tif (charEncoding != null) {\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream, charEncoding);\n\t\t\t} else {\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream);\n\t\t\t}\n\n\t\t\t//best-effort parsing\n\n\t\t\t//start document, go to first tag\n\t\t\txmlReader.nextTag();\n\n\t\t\t//expect first tag to be \"Envelope\"\n\t\t\tif (!\"Envelope\".equals(xmlReader.getLocalName())) {\n\t\t\t\tLOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName()\n\t\t\t\t\t\t+ \"' (expected 'Envelope')\");\n\t\t\t\treturn null; //failed\n\t\t\t}\n\n\t\t\t//scan for body tag\n\t\t\tif (!scanForChildTag(xmlReader, \"Body\")) {\n\t\t\t\tLOG.debug(\"Unable to find SOAP 'Body' tag\");\n\t\t\t\treturn null; //failed\n\t\t\t}\n\n\t\t\txmlReader.nextTag();\n\n\t\t\t//tag is method name\n\t\t\treturn \".\" + xmlReader.getLocalName();\n\t\t} catch (final XMLStreamException e) {\n\t\t\tLOG.debug(\"Unable to parse SOAP request\", e);\n\t\t\t//failed\n\t\t\treturn null;\n\t\t}\n\t}",
            "commit_message": "fix for security"
        },
        "CWE": "CWE-611",
        "CVE": "CVE-2018-15531"
    },
    {
        "data": {
            "function_name": "download",
            "function_code": "@GetMapping(\"/download/{key:.+}\")\n    public ResponseEntity<Resource> download(@PathVariable String key) {\n        LitemallStorage litemallStorage = litemallStorageService.findByKey(key);\n        if (key == null) {\n            ResponseEntity.notFound();\n        }\n        String type = litemallStorage.getType();\n        MediaType mediaType = MediaType.parseMediaType(type);\n\n        Resource file = storageService.loadAsResource(key);\n        if (file == null) {\n            ResponseEntity.notFound();\n        }\n        return ResponseEntity.ok().contentType(mediaType).header(HttpHeaders.CONTENT_DISPOSITION,\n                \"attachment; filename=\\\"\" + file.getFilename() + \"\\\"\").body(file);\n    }",
            "commit_message": "fix[litemall-wx-api]: \u4fee\u590d\u6587\u4ef6\u8def\u5f84\u4e2d\u5305\u542b\"../\"\u5e26\u6765\u7684\u5b89\u5168\u95ee\u9898"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2018-18434"
    },
    {
        "data": {
            "function_name": "addPathParam",
            "function_code": "void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      // The relative URL is cleared when the first query parameter is set.\n      throw new AssertionError();\n    }\n    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\n  }",
            "commit_message": "Forbid path traversal ('.' and '..') as @Path parameters.\n\nThey're likely to have the unintended effect. For example, passing \"..\"\nto @DELETE /account/book/{isbn}/ yields @DELETE /account/."
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2018-1000850"
    },
    {
        "data": {
            "function_name": "addPathParam",
            "function_code": "void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      // The relative URL is cleared when the first query parameter is set.\n      throw new AssertionError();\n    }\n    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\n  }",
            "commit_message": "Forbid path traversal ('.' and '..') as @Path parameters.\n\nThey're likely to have the unintended effect. For example, passing \"..\"\nto @DELETE /account/book/{isbn}/ yields @DELETE /account/."
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2018-1000850"
    },
    {
        "data": {
            "function_name": "recover",
            "function_code": "@RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})\n    public ModelAndView recover(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        String usernameOrEmail = StringUtils.trimToNull(request.getParameter(\"usernameOrEmail\"));\n\n        if (usernameOrEmail != null) {\n\n            map.put(\"usernameOrEmail\", usernameOrEmail);\n            User user = getUserByUsernameOrEmail(usernameOrEmail);\n\n            boolean captchaOk;\n            if (settingsService.isCaptchaEnabled()) {\n                String recaptchaResponse = request.getParameter(\"g-recaptcha-response\");\n                ReCaptcha captcha = new ReCaptcha(settingsService.getRecaptchaSecretKey());\n                captchaOk = recaptchaResponse != null && captcha.isValid(recaptchaResponse);\n            } else {\n                captchaOk = true;\n            }\n            \n            if (!captchaOk) {\n                map.put(\"error\", \"recover.error.invalidcaptcha\");\n            } else if (user == null) {\n                map.put(\"error\", \"recover.error.usernotfound\");\n            } else if (user.getEmail() == null) {\n                map.put(\"error\", \"recover.error.noemail\");\n            } else {\n                String password = RandomStringUtils.randomAlphanumeric(8);\n                if (emailPassword(password, user.getUsername(), user.getEmail())) {\n                    map.put(\"sentTo\", user.getEmail());\n                    user.setLdapAuthenticated(false);\n                    user.setPassword(password);\n                    securityService.updateUser(user);\n                } else {\n                    map.put(\"error\", \"recover.error.sendfailed\");\n                }\n            }\n        }\n\n        if (settingsService.isCaptchaEnabled()) {\n            map.put(\"recaptchaSiteKey\", settingsService.getRecaptchaSiteKey());\n        }\n\n        return new ModelAndView(\"recover\", \"model\", map);\n    }",
            "commit_message": "Generate new passwords in a secure way\n\nPreviously, lost passwords were generated via\norg.apache.commons.lang.RandomStringUtils,\nwhich is using java.util.Random internally.\n\nThis PRNG is has a 48-bit seed, that can easily be bruteforced\nif an attacker is able to get the PRNG's output, for example\nbut resetting their own account multiple times,\nleading to trivial privileges escalation attacks.\n\nThis commit makes use of java.security.SecureRandom\ninstead."
        },
        "CWE": "CWE-310",
        "CVE": "CVE-2019-10908"
    },
    {
        "data": {
            "function_name": "configure",
            "function_code": "@Override\n        protected void configure(HttpSecurity http) throws Exception {\n\n            http = http.addFilter(new WebAsyncManagerIntegrationFilter());\n            http = http.addFilterBefore(jwtAuthFilter(), UsernamePasswordAuthenticationFilter.class);\n\n            http\n                    .antMatcher(\"/ext/**\")\n                    .csrf().requireCsrfProtectionMatcher(csrfSecurityRequestMatcher).and()\n                    .headers().frameOptions().sameOrigin().and()\n                    .authorizeRequests()\n                    .antMatchers(\"/ext/stream/**\", \"/ext/coverArt*\", \"/ext/share/**\", \"/ext/hls/**\")\n                    .hasAnyRole(\"TEMP\", \"USER\").and()\n                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n                    .exceptionHandling().and()\n                    .securityContext().and()\n                    .requestCache().and()\n                    .anonymous().and()\n                    .servletApi();\n        }",
            "commit_message": "Use a random key to \"encrypt\" the remember-me cookie's value\n\nSince Spring's default remember-me technique is\nterrible security-wise (`user:timstamp:md5(use:timestamp:password:key)`),\nwe should at least use a random key, instead of a fixed one,\notherwise, and attacker able to capture the cookies\nmight be able to trivially bruteforce offline\nthe password of the associated user."
        },
        "CWE": "CWE-326",
        "CVE": "CVE-2019-10907"
    },
    {
        "data": {
            "function_name": "getTableValue",
            "function_code": "public static <T> Set<T> getTableValue(final Table table) {\n        @SuppressWarnings(\"unchecked\")\n        Set<T> values = (Set<T>) table.getValue();\n        if (values == null) {\n            values = Collections.emptySet();\n        }\n        return values.stream().filter(Objects::nonNull).collect(Collectors.toSet());\n    }",
            "commit_message": "Fix cast exception in UI (#816)\n\n* check type before cast\r\n\r\nSigned-off-by: Stefan Klotz <stefan.klotz@bosch-si.com>\r\n\r\n* use collection instead of set\r\n\r\nSigned-off-by: Stefan Klotz <stefan.klotz@bosch-si.com>"
        },
        "CWE": "CWE-310",
        "CVE": "CVE-2019-10240"
    },
    {
        "data": {
            "function_name": "handle",
            "function_code": "@Override\n    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String path = baseRequest.getPathInfo();\n        int soff = 0, eoff;\n        // We're handling this request\n        baseRequest.setHandled(true);\n\n        if (path.charAt(0) == '/') soff = 1;\n        eoff = path.indexOf('/', soff);\n        if (soff < 0) {\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        String world = path.substring(soff, eoff);\n        String uri = path.substring(eoff+1);\n        // If faces directory, handle faces\n        if (world.equals(\"faces\")) {\n            handleFace(response, uri);\n            return;\n        }\n        // If markers directory, handle markers\n        if (world.equals(\"_markers_\")) {\n            handleMarkers(response, uri);\n            return;\n        }\n\n        DynmapWorld w = null;\n        if (core.mapManager != null) {\n            w = core.mapManager.getWorld(world);\n        }\n        // If world not found quit\n        if (w == null) {\n            response.setContentType(\"image/png\");\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        MapStorage store = w.getMapStorage();    // Get storage handler\n        // Get tile reference, based on URI and world\n        MapStorageTile tile = store.getTile(w, uri);\n        if (tile == null) {\n            response.setContentType(\"image/png\");\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        // Read tile\n        TileRead tr = null;\n        if (tile.getReadLock(5000)) {\n            tr = tile.read();\n            tile.releaseReadLock();\n        }\n        response.setHeader(\"Cache-Control\", \"max-age=0,must-revalidate\");\n        String etag;\n        if (tr == null) {\n        \tetag = \"\\\"\" + blankpnghash + \"\\\"\";\n        }\n        else {\n        \tetag = \"\\\"\" + tr.hashCode + \"\\\"\";\n        }\n        response.setHeader(\"ETag\", etag);\n        String ifnullmatch = request.getHeader(\"If-None-Match\");\n        if ((ifnullmatch != null) && ifnullmatch.equals(etag)) {\n            response.sendError(HttpStatus.NOT_MODIFIED_304);\n        \treturn;\n        }\n        if (tr == null) {\n            response.setContentType(\"image/png\");\n            response.setIntHeader(\"Content-Length\", blankpng.length);\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        // Got tile, package up for response\n        response.setDateHeader(\"Last-Modified\", tr.lastModified);\n        response.setIntHeader(\"Content-Length\", tr.image.length());\n        if (tr.format == ImageEncoding.PNG) {\n            response.setContentType(\"image/png\");\n        }\n        else {\n            response.setContentType(\"image/jpeg\");\n        }\n        ServletOutputStream out = response.getOutputStream();\n        out.write(tr.image.buffer(), 0, tr.image.length());\n        out.flush();\n\n    }",
            "commit_message": "Merge pull request #2475 from Ry0taK/v3.0\n\nFix required login bypass vulnerability"
        },
        "CWE": "CWE-287",
        "CVE": "CVE-2019-12395"
    },
    {
        "data": {
            "function_name": "newRequest",
            "function_code": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n    if (!nettyRequest.decoderResult().isSuccess()) {\n      LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n      sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n      return;\n    }\n\n    Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n\n    //Find the content length we will use this as an indicator of a body\n    Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n    String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n\n    //If there is a content length or transfer encoding that indicates there is a body\n    boolean hasBody = (contentLength > 0) || (transferEncoding != null);\n\n    RequestBody requestBody = hasBody ? new RequestBody(contentLength, nettyRequest, ctx) : null;\n\n    Channel channel = ctx.channel();\n\n    if (requestBody != null) {\n      channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n    }\n    InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n    InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n\n    ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n\n    DefaultRequest request = new DefaultRequest(\n      clock.instant(),\n      requestHeaders,\n      nettyRequest.method(),\n      nettyRequest.protocolVersion(),\n      nettyRequest.uri(),\n      remoteAddress,\n      socketAddress,\n      serverRegistry.get(ServerConfig.class),\n      requestBody,\n      connectionIdleTimeout,\n      channel.attr(CLIENT_CERT_KEY).get()\n    );\n\n    HttpHeaders nettyHeaders = new DefaultHttpHeaders(false);\n    MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);\n    AtomicBoolean transmitted = new AtomicBoolean(false);\n\n    DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);\n\n    ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);\n\n    Action<Action<Object>> subscribeHandler = thing -> {\n      transmitted.set(true);\n      ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);\n    };\n\n    DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(\n      applicationConstants,\n      request,\n      channel,\n      responseTransmitter,\n      subscribeHandler\n    );\n\n    Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter);\n    requestConstants.response = response;\n\n    DefaultContext.start(channel.eventLoop(), requestConstants, serverRegistry, handlers, execution -> {\n      if (!transmitted.get()) {\n        Handler lastHandler = requestConstants.handler;\n        StringBuilder description = new StringBuilder();\n        description\n          .append(\"No response sent for \")\n          .append(request.getMethod().getName())\n          .append(\" request to \")\n          .append(request.getUri());\n\n        if (lastHandler != null) {\n          description.append(\" (last handler: \");\n\n          if (lastHandler instanceof DescribingHandler) {\n            ((DescribingHandler) lastHandler).describeTo(description);\n          } else {\n            DescribingHandlers.describeTo(lastHandler, description);\n          }\n          description.append(\")\");\n        }\n\n        String message = description.toString();\n        LOGGER.warn(message);\n\n        response.getHeaders().clear();\n\n        ByteBuf body;\n        if (development) {\n          CharBuffer charBuffer = CharBuffer.wrap(message);\n          body = ByteBufUtil.encodeString(ctx.alloc(), charBuffer, CharsetUtil.UTF_8);\n          response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);\n        } else {\n          body = Unpooled.EMPTY_BUFFER;\n        }\n\n        response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, body.readableBytes());\n        responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);\n      }\n    });\n  }",
            "commit_message": "Enable HTTP header validation"
        },
        "CWE": "CWE-74",
        "CVE": "CVE-2019-17513"
    },
    {
        "data": {
            "function_name": "renderState",
            "function_code": "private void renderState(FacesContext context) throws IOException {\n        // Get the view state and write it to the response..\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        String viewStateId = Util.getViewStateId(context);\n\n        writer.startUpdate(viewStateId);\n        String state = context.getApplication().getStateManager().getViewState(context);\n        writer.write(state);\n        writer.endUpdate();\n\n        ClientWindow window = context.getExternalContext().getClientWindow();\n        if (null != window) {\n            String clientWindowId = Util.getClientWindowId(context);\n            writer.startUpdate(clientWindowId);\n            writer.write(window.getId());\n            writer.endUpdate();\n        }\n    }",
            "commit_message": "Fixes #4556 : HIGH-LEVEL VULNERABILITY WITHIN MOJARRA JSF V2.2"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2019-17091"
    },
    {
        "data": {
            "function_name": "getFragmentAsDocument",
            "function_code": "private Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tIterator<Element> nodes = fragment.children().iterator();\n\t\twhile ( nodes.hasNext() ) {\n\t\t\tdocument.body().appendChild( nodes.next() );\n\t\t}\n\n\t\treturn document;\n\t}",
            "commit_message": "HV-1739 Fix CVE-2019-10219 Security issue with @SafeHtml"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2019-10219"
    },
    {
        "data": {
            "function_name": "enableServiceAccount",
            "function_code": "public void enableServiceAccount(ClientModel client) {\n        client.setServiceAccountsEnabled(true);\n\n        // Add dedicated user for this service account\n        if (realmManager.getSession().users().getServiceAccount(client) == null) {\n            String username = ServiceAccountConstants.SERVICE_ACCOUNT_USER_PREFIX + client.getClientId();\n            logger.debugf(\"Creating service account user '%s'\", username);\n\n            // Don't use federation for service account user\n            UserModel user = realmManager.getSession().userLocalStorage().addUser(client.getRealm(), username);\n            user.setEnabled(true);\n            user.setEmail(username + \"@placeholder.org\");\n            user.setServiceAccountClientLink(client.getId());\n        }\n\n        // Add protocol mappers to retrieve clientId in access token\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_ID,\n                    ServiceAccountConstants.CLIENT_ID, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n\n        // Add protocol mappers to retrieve hostname and IP address of client in access token\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_HOST,\n                    ServiceAccountConstants.CLIENT_HOST, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_ADDRESS,\n                    ServiceAccountConstants.CLIENT_ADDRESS, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n    }",
            "commit_message": "KEYCLOAK-10780 Stop creating placeholder e-mails for service accounts (#228)"
        },
        "CWE": "CWE-798",
        "CVE": "CVE-2019-14837"
    },
    {
        "data": {
            "function_name": "enableServiceAccount",
            "function_code": "public void enableServiceAccount(ClientModel client) {\n        client.setServiceAccountsEnabled(true);\n\n        // Add dedicated user for this service account\n        if (realmManager.getSession().users().getServiceAccount(client) == null) {\n            String username = ServiceAccountConstants.SERVICE_ACCOUNT_USER_PREFIX + client.getClientId();\n            logger.debugf(\"Creating service account user '%s'\", username);\n\n            // Don't use federation for service account user\n            UserModel user = realmManager.getSession().userLocalStorage().addUser(client.getRealm(), username);\n            user.setEnabled(true);\n            user.setEmail(username + \"@placeholder.org\");\n            user.setServiceAccountClientLink(client.getId());\n        }\n\n        // Add protocol mappers to retrieve clientId in access token\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_ID,\n                    ServiceAccountConstants.CLIENT_ID, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n\n        // Add protocol mappers to retrieve hostname and IP address of client in access token\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_HOST,\n                    ServiceAccountConstants.CLIENT_HOST, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_ADDRESS,\n                    ServiceAccountConstants.CLIENT_ADDRESS, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n    }",
            "commit_message": "KEYCLOAK-10780 Stop creating placeholder e-mails for service accounts (#228)"
        },
        "CWE": "CWE-798",
        "CVE": "CVE-2019-14837"
    },
    {
        "data": {
            "function_name": "addViolation",
            "function_code": "public void addViolation(String msg) {\n        violationOccurred = true;\n        context.buildConstraintViolationWithTemplate(msg)\n            .addConstraintViolation();\n    }",
            "commit_message": "Escape EL expressions in ViolationCollector (#3157)\n\nFixes #3153"
        },
        "CWE": "CWE-74",
        "CVE": "CVE-2020-5245"
    },
    {
        "data": {
            "function_name": "getUser",
            "function_code": "@Override\n  public User getUser() throws IllegalStateException {\n    Organization org = getOrganization();\n    if (org == null)\n      throw new IllegalStateException(\"No organization is set in security context\");\n\n    User delegatedUser = delegatedUserHolder.get();\n\n    if (delegatedUser != null) {\n      return delegatedUser;\n    }\n\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(org);\n    if (auth != null) {\n      Object principal = auth.getPrincipal();\n      if ((principal != null) && (principal instanceof UserDetails)) {\n        UserDetails userDetails = (UserDetails) principal;\n\n        User user = null;\n\n        // If user exists, fetch it from the userDirectory\n        if (userDirectory != null) {\n          user = userDirectory.loadUser(userDetails.getUsername());\n          if (user == null) {\n            logger.debug(\n                    \"Authenticated user '{}' could not be found in any of the current UserProviders. Continuing anyway...\",\n                    userDetails.getUsername());\n          }\n        } else {\n          logger.debug(\"No UserDirectory was found when trying to search for user '{}'\", userDetails.getUsername());\n        }\n\n        // Add the roles (authorities) in the security context\n        Set<JaxbRole> roles = new HashSet<JaxbRole>();\n        Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();\n        if (authorities != null) {\n          for (GrantedAuthority ga : authorities) {\n            roles.add(new JaxbRole(ga.getAuthority(), jaxbOrganization));\n          }\n        }\n\n        if (user == null) {\n          // No user was found. Create one to hold the auth information from the security context\n          user = new JaxbUser(userDetails.getUsername(), null, jaxbOrganization, roles);\n        } else {\n          // Combine the existing user with the roles in the security context\n          user = JaxbUser.fromUser(user, roles);\n        }\n\n        // Save the user to retrieve it quicker the next time(s) this method is called (by this thread)\n        delegatedUserHolder.set(user);\n\n        return user;\n      }\n    }\n\n    // Return the anonymous user by default\n    return SecurityUtil.createAnonymousUser(jaxbOrganization);\n  }",
            "commit_message": "Authentication Bypass For Endpoints With Anonymous Access\n\nUsing a remember-me cookie with an arbitrary username can cause Opencast\nto assume proper authentication for that user even if the remember-me\ncookie was incorrect given that the attacked endpoint also allows\nanonymous access.\n\nThis way, an attacker can, for example, fake a remember-me token, assume\nthe identity of the global system administrator and request non-public\ncontent from the search service without ever providing any proper\nauthentication.\n\nThe reason for this problem is that using a remember-me cookie will\nalways cause the user in the request context to be populated, even if\nthe cookie is invalid by now. This is usually no problem, except in\ncombination with anonymous access where anonymous authentication is\ngranted and the request may continue.\n\nIn such a case, Opencast's security service would just check that a user\nexisted in the request context and assume proper authentication of this\nuser, never checking if it's actually anonymous authentication.\n\nThis patch adds this additional check, falling back to the anonymous\nuser in case of anonymous authentication."
        },
        "CWE": "CWE-287",
        "CVE": "CVE-2020-5206"
    },
    {
        "data": {
            "function_name": "handle",
            "function_code": "@Override\n    public Element handle(Element request, Map<String, Object> context) throws ServiceException {\n        ZimbraSoapContext zsc = getZimbraSoapContext(context);\n        Account account = getRequestedAccount(getZimbraSoapContext(context));\n\n        if (!canAccessAccount(zsc, account))\n            throw ServiceException.PERM_DENIED(\"can not access account\");\n        \n        String name = request.getAttribute(AccountConstants.E_NAME);\n        String typeStr = request.getAttribute(AccountConstants.A_TYPE, \"account\");\n        GalSearchType type = GalSearchType.fromString(typeStr);\n\n        boolean needCanExpand = request.getAttributeBool(AccountConstants.A_NEED_EXP, false);\n\n        String galAcctId = request.getAttribute(AccountConstants.A_GAL_ACCOUNT_ID, null);\n        \n        GalSearchParams params = new GalSearchParams(account, zsc);\n        params.setType(type);\n        params.setRequest(request);\n        params.setQuery(name);\n        params.setLimit(account.getContactAutoCompleteMaxResults());\n        params.setNeedCanExpand(needCanExpand);\n        params.setResponseName(AccountConstants.AUTO_COMPLETE_GAL_RESPONSE);\n        if (galAcctId != null)\n            params.setGalSyncAccount(Provisioning.getInstance().getAccountById(galAcctId));\n        GalSearchControl gal = new GalSearchControl(params);\n        gal.autocomplete();\n        return params.getResultCallback().getResponse();\n    }",
            "commit_message": "ZBUG-1094:Broken GAL search filtering"
        },
        "CWE": "CWE-863",
        "CVE": "CVE-2020-10194"
    },
    {
        "data": {
            "function_name": "deleteShoppingCart",
            "function_code": "public void deleteShoppingCart(final Long id, final MerchantStore store) throws Exception {\n    \tShoppingCart cart = shoppingCartService.getById(id, store);\n    \tif(cart!=null) {\n    \t\tshoppingCartService.deleteCart(cart);\n    \t}\n    }",
            "commit_message": "Merge pull request from GHSA-w8rc-pgxq-x2cj\n\nFixing negative charge vulnerability"
        },
        "CWE": "CWE-20",
        "CVE": "CVE-2020-11007"
    },
    {
        "data": {
            "function_name": "deleteShoppingCart",
            "function_code": "public void deleteShoppingCart(final Long id, final MerchantStore store) throws Exception {\n    \tShoppingCart cart = shoppingCartService.getById(id, store);\n    \tif(cart!=null) {\n    \t\tshoppingCartService.deleteCart(cart);\n    \t}\n    }",
            "commit_message": "Merge pull request from GHSA-w8rc-pgxq-x2cj\n\nFixing negative charge vulnerability"
        },
        "CWE": "CWE-20",
        "CVE": "CVE-2020-11007"
    },
    {
        "data": {
            "function_name": "handleAtRule",
            "function_code": "public void handleAtRule(ApplContext ac, String ident, String string) {\n        style.getWarnings().addWarning(new Warning(cssFouffa.getSourceFile(),\n                cssFouffa.getLine(),\n                \"at-rule\",\n                2,\n                new String[]{ident, string},\n                ac));\n        //stylesheet.addAtRule(atRule);\n    }",
            "commit_message": "escape also the throwable message, see #278"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2020-4070"
    },
    {
        "data": {
            "function_name": "stop",
            "function_code": "public void stop() {\n    try {\n      officeManager.stop();\n    } catch (OfficeException e) {\n      log.error(\"Could not stop Office Manager\", e);\n    }\n\n  }",
            "commit_message": "Merge pull request #10619 from bigbluebutton/bbb-soffice-disable-update\n\nDisable libreoffice document update ( speed up the conversion )"
        },
        "CWE": "CWE-918",
        "CVE": "CVE-2020-25820"
    },
    {
        "data": {
            "function_name": "createTemporaryFolderIn",
            "function_code": "private File createTemporaryFolderIn(File parentFolder) throws IOException {\n        File createdFolder = null;\n        for (int i = 0; i < TEMP_DIR_ATTEMPTS; ++i) {\n            // Use createTempFile to get a suitable folder name.\n            String suffix = \".tmp\";\n            File tmpFile = File.createTempFile(TMP_PREFIX, suffix, parentFolder);\n            String tmpName = tmpFile.toString();\n            // Discard .tmp suffix of tmpName.\n            String folderName = tmpName.substring(0, tmpName.length() - suffix.length());\n            createdFolder = new File(folderName);\n            if (createdFolder.mkdir()) {\n                tmpFile.delete();\n                return createdFolder;\n            }\n            tmpFile.delete();\n        }\n        throw new IOException(\"Unable to create temporary directory in: \"\n            + parentFolder.toString() + \". Tried \" + TEMP_DIR_ATTEMPTS + \" times. \"\n            + \"Last attempted to create: \" + createdFolder.toString());\n    }",
            "commit_message": "Merge pull request from GHSA-269g-pwp5-87pp\n\nWhen running on Java 7 or later, temporary directories are now created\nUsing Java\u2019s NIO API which restricts permissions to owner-only by\ndefault."
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2020-15250"
    },
    {
        "data": {
            "function_name": "verify",
            "function_code": "public void verify(String host, SSLSocket ssl) throws IOException {\n        logger.trace(\"Skipping SSL host name check on {}\", host);\n      }",
            "commit_message": "Re-Enable Hostname Verification\n\nThis patch is a minimal change to re-enable HTTPS hostname verification\nof Opencast's HTTP client used for a large portion its HTTP requests.\n\nHostname verification is an important part when using HTTPS to ensure\nthat the presented certificate is valid for the host. Disabling it can\nallow for man-in-the-middle attacks."
        },
        "CWE": "CWE-346",
        "CVE": "CVE-2020-26234"
    },
    {
        "data": {
            "function_name": "getJobExecutionIdsByTaskExecutionId",
            "function_code": "@Override\n\tpublic Set<Long> getJobExecutionIdsByTaskExecutionId(long taskExecutionId) {\n\t\tfinal MapSqlParameterSource queryParameters = new MapSqlParameterSource()\n\t\t\t\t.addValue(\"taskExecutionId\", taskExecutionId, Types.BIGINT);\n\n\t\ttry {\n\t\t\treturn this.jdbcTemplate.query(\n\t\t\t\t\tgetQuery(FIND_JOB_EXECUTION_BY_TASK_EXECUTION_ID), queryParameters,\n\t\t\t\t\tnew ResultSetExtractor<Set<Long>>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Set<Long> extractData(ResultSet resultSet)\n\t\t\t\t\t\t\t\tthrows SQLException, DataAccessException {\n\t\t\t\t\t\t\tSet<Long> jobExecutionIds = new TreeSet<>();\n\n\t\t\t\t\t\t\twhile (resultSet.next()) {\n\t\t\t\t\t\t\t\tjobExecutionIds\n\t\t\t\t\t\t\t\t\t\t.add(resultSet.getLong(\"JOB_EXECUTION_ID\"));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn jobExecutionIds;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t\tcatch (DataAccessException e) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t}",
            "commit_message": "Added sort validation\n\nThis commit now validates that the value passed via a PageRequest to\nsort the results by is a valid value.\n\nResolves #739\n\nFixed to allow for all letter cases\n\nPolish"
        },
        "CWE": "CWE-89",
        "CVE": "CVE-2020-5428"
    },
    {
        "data": {
            "function_name": "migrate",
            "function_code": "public static String migrate(String xml) {\n\t\tDocument xmlDoc;\n\t\ttry {\n\t\t\txmlDoc = new SAXReader().read(new StringReader(xml));\n\t\t} catch (DocumentException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t\tList<NodeTuple> tuples = new ArrayList<>();\n\t\tNode keyNode = new ScalarNode(Tag.STR, \"version\");\n\t\tNode valueNode = new ScalarNode(Tag.INT, \"0\");\n\t\ttuples.add(new NodeTuple(keyNode, valueNode));\n\t\t\n\t\tList<Node> jobNodes = new ArrayList<>();\n\t\tfor (Element jobElement: xmlDoc.getRootElement().element(\"jobs\").elements()) \n\t\t\tjobNodes.add(migrateJob(jobElement));\n\t\t\n\t\tif (!jobNodes.isEmpty()) {\n\t\t\tkeyNode = new ScalarNode(Tag.STR, \"jobs\");\n\t\t\ttuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, jobNodes, FlowStyle.BLOCK)));\n\t\t}\n\t\t\n\t\tList<Node> propertyNodes = new ArrayList<>();\n\t\tElement propertiesElement = xmlDoc.getRootElement().element(\"properties\");\n\t\tif (propertiesElement != null) {\n\t\t\tfor (Element propertyElement: propertiesElement.elements()) {\n\t\t\t\tNode nameNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"name\").trim());\n\t\t\t\tvalueNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"value\").trim());\n\t\t\t\tList<NodeTuple> propertyTuples = Lists.newArrayList(\n\t\t\t\t\t\tnew NodeTuple(new ScalarNode(Tag.STR, \"name\"), nameNode), \n\t\t\t\t\t\tnew NodeTuple(new ScalarNode(Tag.STR, \"value\"), valueNode));\n\t\t\t\tpropertyNodes.add(new MappingNode(Tag.MAP, propertyTuples, FlowStyle.BLOCK));\n\t\t\t}\n\t\t}\n\t\tif(!propertyNodes.isEmpty()) {\n\t\t\tkeyNode = new ScalarNode(Tag.STR, \"properties\");\n\t\t\ttuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, propertyNodes, FlowStyle.BLOCK)));\n\t\t}\n\t\t\n\t\tMappingNode rootNode = new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);\n\t\tStringWriter writer = new StringWriter();\n\t\tDumperOptions dumperOptions = new DumperOptions();\n\t\tSerializer serializer = new Serializer(new Emitter(writer, dumperOptions), \n\t\t\t\tnew Resolver(), dumperOptions, Tag.MAP);\n\t\ttry {\n\t\t\tserializer.open();\n\t\t\tserializer.serialize(rootNode);\n\t\t\tserializer.close();\n\t\t\treturn writer.toString();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t}",
            "commit_message": "Fix XXE injection attack by disabling XML DTD handling"
        },
        "CWE": "CWE-538",
        "CVE": "CVE-2021-21250"
    },
    {
        "data": {
            "function_name": "toBean",
            "function_code": "@SuppressWarnings(\"unchecked\")\n\tpublic <T> T toBean(Class<T> beanClass) {\n        setTag(new Tag(beanClass));\n        \n\t\tif (getVersion() != null) {\n\t\t\ttry {\n\t\t\t\tMigrationHelper.migrate(getVersion(), beanClass.newInstance(), this);\n\t\t\t\tremoveVersion();\n\t\t\t} catch (InstantiationException | IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\t\n        return (T) new OneYaml().construct(this);\n\t}",
            "commit_message": "Fix security vulnerability issue caused by SnakeYaml deserialization"
        },
        "CWE": "CWE-502",
        "CVE": "CVE-2021-21249"
    },
    {
        "data": {
            "function_name": "get",
            "function_code": "@Override\n\t\t\tpublic ValidatorFactory get() {\n\t\t\t\tConfiguration<?> configuration = Validation.byDefaultProvider().configure();\n\t\t\t\treturn configuration.buildValidatorFactory();\n\t\t\t}",
            "commit_message": "fix issue #88: Users able to edit build spec can execute arbitrary java\ncode"
        },
        "CWE": "CWE-94",
        "CVE": "CVE-2021-21244"
    },
    {
        "data": {
            "function_name": "onCreate",
            "function_code": "protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.grant_credentials_permission);\n        setTitle(R.string.grant_permissions_header_text);\n\n        mInflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\n        final Bundle extras = getIntent().getExtras();\n        if (extras == null) {\n            // we were somehow started with bad parameters. abort the activity.\n            setResult(Activity.RESULT_CANCELED);\n            finish();\n            return;\n        }\n\n        // Grant 'account'/'type' to mUID\n        mAccount = extras.getParcelable(EXTRAS_ACCOUNT);\n        mAuthTokenType = extras.getString(EXTRAS_AUTH_TOKEN_TYPE);\n        mUid = extras.getInt(EXTRAS_REQUESTING_UID);\n        final PackageManager pm = getPackageManager();\n        final String[] packages = pm.getPackagesForUid(mUid);\n\n        if (mAccount == null || mAuthTokenType == null || packages == null) {\n            // we were somehow started with bad parameters. abort the activity.\n            setResult(Activity.RESULT_CANCELED);\n            finish();\n            return;\n        }\n\n        String accountTypeLabel;\n        try {\n            accountTypeLabel = getAccountLabel(mAccount);\n        } catch (IllegalArgumentException e) {\n            // label or resource was missing. abort the activity.\n            setResult(Activity.RESULT_CANCELED);\n            finish();\n            return;\n        }\n\n        final TextView authTokenTypeView = findViewById(R.id.authtoken_type);\n        authTokenTypeView.setVisibility(View.GONE);\n\n        final AccountManagerCallback<String> callback = new AccountManagerCallback<String>() {\n            public void run(AccountManagerFuture<String> future) {\n                try {\n                    final String authTokenLabel = future.getResult();\n                    if (!TextUtils.isEmpty(authTokenLabel)) {\n                        runOnUiThread(new Runnable() {\n                            public void run() {\n                                if (!isFinishing()) {\n                                    authTokenTypeView.setText(authTokenLabel);\n                                    authTokenTypeView.setVisibility(View.VISIBLE);\n                                }\n                            }\n                        });\n                    }\n                } catch (OperationCanceledException e) {\n                } catch (IOException e) {\n                } catch (AuthenticatorException e) {\n                }\n            }\n        };\n\n        if (!AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE.equals(mAuthTokenType)) {\n            AccountManager.get(this).getAuthTokenLabel(mAccount.type,\n                    mAuthTokenType, callback, null);\n        }\n\n        findViewById(R.id.allow_button).setOnClickListener(this);\n        findViewById(R.id.deny_button).setOnClickListener(this);\n\n        LinearLayout packagesListView = findViewById(R.id.packages_list);\n\n        for (String pkg : packages) {\n            String packageLabel;\n            try {\n                packageLabel = pm.getApplicationLabel(pm.getApplicationInfo(pkg, 0)).toString();\n            } catch (PackageManager.NameNotFoundException e) {\n                packageLabel = pkg;\n            }\n            packagesListView.addView(newPackageView(packageLabel));\n        }\n\n        ((TextView) findViewById(R.id.account_name)).setText(mAccount.name);\n        ((TextView) findViewById(R.id.account_type)).setText(accountTypeLabel);\n    }",
            "commit_message": "Protect GrantCredentialsPermissionActivity against overlay.\n\nBug: 169763814\nTest: manual\nChange-Id: I15dd22791fcc61ef02b06ad51d9e4409d11c0181\n(cherry picked from commit f45dcfe1f5ed74dcec15799f2abd9e5ecbbed4b7)"
        },
        "CWE": "CWE-1021",
        "CVE": "CVE-2021-0315"
    },
    {
        "data": {
            "function_name": "checkCallerIsSystemOr",
            "function_code": "private void checkCallerIsSystemOr(String pkg) throws RemoteException {\n            checkCallerIsSystemOr(pkg, getCallingUserId());\n        }",
            "commit_message": "RESTRICT AUTOMERGE\nFix CDM package check\n\nCDM was using a pckage check that returns a value intead of throwing,\nresulting in failing to throw on querying other package's associations\n\nTest: ensure attached bug no longer reproduces\nBug: 167244818\nChange-Id: I21319b6f5495dcae681541c76b847aad0c00b8ab\n(cherry picked from commit 30b022a8d207573aeaf735a33439884afe60c684)"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2021-0321"
    },
    {
        "data": {
            "function_name": "checkCallerIsSystemOr",
            "function_code": "private void checkCallerIsSystemOr(String pkg) throws RemoteException {\n            checkCallerIsSystemOr(pkg, getCallingUserId());\n        }",
            "commit_message": "RESTRICT AUTOMERGE\nFix CDM package check\n\nCDM was using a pckage check that returns a value intead of throwing,\nresulting in failing to throw on querying other package's associations\n\nTest: ensure attached bug no longer reproduces\nBug: 167244818\nChange-Id: I21319b6f5495dcae681541c76b847aad0c00b8ab\n(cherry picked from commit 30b022a8d207573aeaf735a33439884afe60c684)"
        },
        "CWE": "CWE-863",
        "CVE": "CVE-2021-0319"
    },
    {
        "data": {
            "function_name": "checkCallerIsSystemOr",
            "function_code": "private void checkCallerIsSystemOr(String pkg) throws RemoteException {\n            checkCallerIsSystemOr(pkg, getCallingUserId());\n        }",
            "commit_message": "RESTRICT AUTOMERGE\nFix CDM package check\n\nCDM was using a pckage check that returns a value intead of throwing,\nresulting in failing to throw on querying other package's associations\n\nTest: ensure attached bug no longer reproduces\nBug: 167244818\nChange-Id: I21319b6f5495dcae681541c76b847aad0c00b8ab\n(cherry picked from commit 30b022a8d207573aeaf735a33439884afe60c684)"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2021-0321"
    },
    {
        "data": {
            "function_name": "checkCallerIsSystemOr",
            "function_code": "private void checkCallerIsSystemOr(String pkg) throws RemoteException {\n            checkCallerIsSystemOr(pkg, getCallingUserId());\n        }",
            "commit_message": "RESTRICT AUTOMERGE\nFix CDM package check\n\nCDM was using a pckage check that returns a value intead of throwing,\nresulting in failing to throw on querying other package's associations\n\nTest: ensure attached bug no longer reproduces\nBug: 167244818\nChange-Id: I21319b6f5495dcae681541c76b847aad0c00b8ab\n(cherry picked from commit 30b022a8d207573aeaf735a33439884afe60c684)"
        },
        "CWE": "CWE-863",
        "CVE": "CVE-2021-0319"
    },
    {
        "data": {
            "function_name": "updateDynamicPermission",
            "function_code": "public void updateDynamicPermission(Collection<BasePermission> permissionTrees) {\n        if (PackageManagerService.DEBUG_SETTINGS) Log.v(TAG, \"Dynamic permission: name=\"\n                + getName() + \" pkg=\" + getSourcePackageName()\n                + \" info=\" + pendingPermissionInfo);\n        if (pendingPermissionInfo != null) {\n            final BasePermission tree = findPermissionTree(permissionTrees, name);\n            if (tree != null && tree.perm != null) {\n                perm = new ParsedPermission(tree.perm, pendingPermissionInfo,\n                        tree.perm.getPackageName(), name);\n                uid = tree.uid;\n            }\n        }\n    }",
            "commit_message": "Revoke permission on non-runtime -> runtime upgrade\n\nNot only on normal -> runtime.\n\nTest: atest PermissionEscalationTest\nBug: 154505240, 168319670\nChange-Id: If3b420067b4d7111dcf67ae6f98e42176158b679\nMerged-In: If3b420067b4d7111dcf67ae6f98e42176158b679\n(cherry picked from commit 33e24c883c5797fe7ba05468bde967fb0e46e66d)"
        },
        "CWE": "CWE-269",
        "CVE": "CVE-2021-0317"
    },
    {
        "data": {
            "function_name": "updateDynamicPermission",
            "function_code": "public void updateDynamicPermission(Collection<BasePermission> permissionTrees) {\n        if (PackageManagerService.DEBUG_SETTINGS) Log.v(TAG, \"Dynamic permission: name=\"\n                + getName() + \" pkg=\" + getSourcePackageName()\n                + \" info=\" + pendingPermissionInfo);\n        if (pendingPermissionInfo != null) {\n            final BasePermission tree = findPermissionTree(permissionTrees, name);\n            if (tree != null && tree.perm != null) {\n                perm = new ParsedPermission(tree.perm, pendingPermissionInfo,\n                        tree.perm.getPackageName(), name);\n                uid = tree.uid;\n            }\n        }\n    }",
            "commit_message": "Revoke permission on non-runtime -> runtime upgrade\n\nNot only on normal -> runtime.\n\nTest: atest PermissionEscalationTest\nBug: 154505240, 168319670\nChange-Id: If3b420067b4d7111dcf67ae6f98e42176158b679\nMerged-In: If3b420067b4d7111dcf67ae6f98e42176158b679\n(cherry picked from commit 33e24c883c5797fe7ba05468bde967fb0e46e66d)"
        },
        "CWE": "CWE-269",
        "CVE": "CVE-2021-0317"
    },
    {
        "data": {
            "function_name": "updateDynamicPermission",
            "function_code": "public void updateDynamicPermission(Collection<BasePermission> permissionTrees) {\n        if (PackageManagerService.DEBUG_SETTINGS) Log.v(TAG, \"Dynamic permission: name=\"\n                + getName() + \" pkg=\" + getSourcePackageName()\n                + \" info=\" + pendingPermissionInfo);\n        if (pendingPermissionInfo != null) {\n            final BasePermission tree = findPermissionTree(permissionTrees, name);\n            if (tree != null && tree.perm != null) {\n                perm = new ParsedPermission(tree.perm, pendingPermissionInfo,\n                        tree.perm.getPackageName(), name);\n                uid = tree.uid;\n            }\n        }\n    }",
            "commit_message": "Revoke permission on non-runtime -> runtime upgrade\n\nNot only on normal -> runtime.\n\nTest: atest PermissionEscalationTest\nBug: 154505240, 168319670\nChange-Id: If3b420067b4d7111dcf67ae6f98e42176158b679\nMerged-In: If3b420067b4d7111dcf67ae6f98e42176158b679\n(cherry picked from commit 33e24c883c5797fe7ba05468bde967fb0e46e66d)"
        },
        "CWE": "CWE-269",
        "CVE": "CVE-2021-0317"
    },
    {
        "data": {
            "function_name": "verifyContentLength",
            "function_code": "private void verifyContentLength(Http2Stream stream, int data, boolean isEnd) throws Http2Exception {\n        if (!VALIDATE_CONTENT_LENGTH) {\n            return;\n        }\n        ContentLength contentLength = stream.getProperty(contentLengthKey);\n        if (contentLength != null) {\n            try {\n                contentLength.increaseReceivedBytes(connection.isServer(), stream.id(), data, isEnd);\n            } finally {\n                if (isEnd) {\n                    stream.removeProperty(contentLengthKey);\n                }\n            }\n        }\n    }",
            "commit_message": "Merge pull request from GHSA-f256-j965-7f32\n\nMotivation:\n\nWe also need to ensure that all the header validation is done when a single header with the endStream flag is received\n\nModifications:\n\n- Adjust code to always enforce the validation\n- Add more unit tests\n\nResult:\n\nAlways correctly validate"
        },
        "CWE": "CWE-444",
        "CVE": "CVE-2021-21409"
    },
    {
        "data": {
            "function_name": "getTmpFolder",
            "function_code": "protected static File getTmpFolder() {\n        try {\n            File outputFolder = File.createTempFile(\"codegen-\", \"-tmp\");\n            outputFolder.delete();\n            outputFolder.mkdir();\n            outputFolder.deleteOnExit();\n            return outputFolder;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }",
            "commit_message": "Merge pull request from GHSA-pc22-3g76-gm6j\n\n security: use java.nio.files in Generator."
        },
        "CWE": "CWE-378",
        "CVE": "CVE-2021-21363"
    },
    {
        "data": {
            "function_name": "requestForbidden",
            "function_code": "private boolean requestForbidden(HttpServletRequest request) {\n        if (!xsrfProtectionEnabled) {\n            return false;\n        }\n\n        HttpSession session = request.getSession(false);\n        if (session == null) {\n            return false;\n        }\n\n        String csrfTokenInSession = (String) session\n                .getAttribute(VaadinService.getCsrfTokenAttributeName());\n        if (csrfTokenInSession == null) {\n            if (getLogger().isInfoEnabled()) {\n                getLogger().info(\n                        \"Unable to verify CSRF token for endpoint request, got null token in session\");\n            }\n\n            return true;\n        }\n\n        if (!csrfTokenInSession.equals(request.getHeader(\"X-CSRF-Token\"))) {\n            if (getLogger().isInfoEnabled()) {\n                getLogger().info(\"Invalid CSRF token in endpoint request\");\n            }\n\n            return true;\n        }\n\n        return false;\n    }",
            "commit_message": "Use time-constant comparison for CSRF tokens in endpoint (#10157)\n\nThis hardens the framework against a theoretical timing attack based on\r\ncomparing how quickly a request with an invalid CSRF token is rejected.\r\n\r\nNo tests since this functionality is equivalent to the previous implementation aside from timing differences that would be very fragile to verify in an automated test.\r\n\r\nRelated to https://github.com/vaadin/flow/pull/9875"
        },
        "CWE": "CWE-203",
        "CVE": "CVE-2021-31406"
    },
    {
        "data": {
            "function_name": "isStaticResourceRequest",
            "function_code": "@Override\n    public boolean isStaticResourceRequest(HttpServletRequest request) {\n        URL resource;\n\n        String requestFilename = getRequestFilename(request);\n        if (requestFilename.endsWith(\"/\")) {\n            // Directories are not static resources although\n            // servletContext.getResource will return a URL for them, at\n            // least with Jetty\n            return false;\n        }\n\n        if (requestFilename.startsWith(\"/\" + VAADIN_STATIC_FILES_PATH)\n                || requestFilename.startsWith(\"/\" + VAADIN_BUILD_FILES_PATH)) {\n            // The path is reserved for internal resources only\n            // We rather serve 404 than let it fall through\n            return true;\n        }\n        resource = servletService.getStaticResource(requestFilename);\n\n        if (resource == null && shouldFixIncorrectWebjarPaths()\n                && isIncorrectWebjarPath(requestFilename)) {\n            // Flow issue #4601\n            return true;\n        }\n\n        return resource != null;\n    }",
            "commit_message": "fix: avoid exposing ServletContext resources via StaticFileServer (#10269)\n\nfix: avoid exposing ServletContext resources via StaticFileServer in OSGi\r\n\r\nfixes #10260"
        },
        "CWE": "CWE-668",
        "CVE": "CVE-2021-31407"
    },
    {
        "data": {
            "function_name": "isStaticResourceRequest",
            "function_code": "@Override\n    public boolean isStaticResourceRequest(HttpServletRequest request) {\n        URL resource;\n\n        String requestFilename = getRequestFilename(request);\n        if (requestFilename.endsWith(\"/\")) {\n            // Directories are not static resources although\n            // servletContext.getResource will return a URL for them, at\n            // least with Jetty\n            return false;\n        }\n\n        if (requestFilename.startsWith(\"/\" + VAADIN_STATIC_FILES_PATH)\n                || requestFilename.startsWith(\"/\" + VAADIN_BUILD_FILES_PATH)) {\n            // The path is reserved for internal resources only\n            // We rather serve 404 than let it fall through\n            return true;\n        }\n        resource = servletService.getStaticResource(requestFilename);\n\n        if (resource == null && shouldFixIncorrectWebjarPaths()\n                && isIncorrectWebjarPath(requestFilename)) {\n            // Flow issue #4601\n            return true;\n        }\n\n        return resource != null;\n    }",
            "commit_message": "fix: avoid exposing ServletContext resources via StaticFileServer (#10269)\n\nfix: avoid exposing ServletContext resources via StaticFileServer in OSGi\r\n\r\nfixes #10260"
        },
        "CWE": "CWE-668",
        "CVE": "CVE-2021-31407"
    },
    {
        "data": {
            "function_name": "isCsrfTokenValid",
            "function_code": "public static boolean isCsrfTokenValid(UI ui, String requestToken) {\n\n        if (ui.getSession().getService().getDeploymentConfiguration()\n                .isXsrfProtectionEnabled()) {\n            String uiToken = ui.getCsrfToken();\n\n            if (uiToken == null || !uiToken.equals(requestToken)) {\n                return false;\n            }\n        }\n        return true;\n    }",
            "commit_message": "fix: use time-constant comparison for CSRF tokens (#9875)\n\nThis hardens the framework against a theoretical timing attack based on\r\ncomparing how quickly a request with an invalid CSRF token is rejected."
        },
        "CWE": "CWE-203",
        "CVE": "CVE-2021-31404"
    },
    {
        "data": {
            "function_name": "initialize",
            "function_code": "protected void initialize(Class<?> type, Type genericType, String paramName, Class<?> paramType, String defaultValue, AccessibleObject target, Annotation[] annotations, ResteasyProviderFactory factory)\n   {\n      this.type = type;\n      this.paramName = paramName;\n      this.paramType = paramType;\n      this.defaultValue = defaultValue;\n      this.target = target;\n      baseType = type;\n      baseGenericType = genericType;\n\n      //Step 1: try to find a conversion mechanism using the type as it is\n      if(initialize(annotations, factory))\n      {\n         return;\n      }\n\n      //Step2: try to find a conversion mechanism if the type is an array type\n      if (type.isArray())\n      {\n         isArray = true;\n         baseType = type.getComponentType();\n         if(initialize(annotations, factory))\n         {\n            return ;\n         }\n      }\n\n      //Step 3: try to find a conversion mechanism if the type is a collection type\n      collectionType = convertParameterTypeToCollectionType();\n      if (collectionType != null)\n      {\n         isCollection = true;\n         if (genericType instanceof ParameterizedType)\n         {\n            ParameterizedType zType = (ParameterizedType) baseGenericType;\n            baseType = Types.getRawType(zType.getActualTypeArguments()[0]);\n            baseGenericType = zType.getActualTypeArguments()[0];\n         }\n         else\n         {\n            baseType = String.class;\n            baseGenericType = null;\n         }\n         if(initialize(annotations, factory))\n         {\n            return;\n         }\n      }\n\n      throw new RuntimeException(Messages.MESSAGES.unableToFindConstructor(getParamSignature(), target, baseType.getName()));\n\n   }",
            "commit_message": "RESTEASY-2519"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2020-10688"
    },
    {
        "data": {
            "function_name": "getPointsFromRequest",
            "function_code": "private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {\n\n        String url = httpServletRequest.getRequestURI();\n        url = url.replaceFirst(\"/navigate/directions/v5/gh/\" + profile + \"/\", \"\");\n        url = url.replaceAll(\"\\\\?[*]\", \"\");\n\n        String[] pointStrings = url.split(\";\");\n\n        List<GHPoint> points = new ArrayList<>(pointStrings.length);\n        for (int i = 0; i < pointStrings.length; i++) {\n            points.add(GHPoint.fromStringLonLat(pointStrings[i]));\n        }\n\n        return points;\n    }",
            "commit_message": "avoid regex in navigate module (#2304)\n\n* replace two regexs with one indexOf\r\n\r\n* make check stricter\r\n\r\n* use @easbar's suggestion"
        },
        "CWE": "CWE-400",
        "CVE": "CVE-2021-29506"
    },
    {
        "data": {
            "function_name": "getPointsFromRequest",
            "function_code": "private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {\n\n        String url = httpServletRequest.getRequestURI();\n        url = url.replaceFirst(\"/navigate/directions/v5/gh/\" + profile + \"/\", \"\");\n        url = url.replaceAll(\"\\\\?[*]\", \"\");\n\n        String[] pointStrings = url.split(\";\");\n\n        List<GHPoint> points = new ArrayList<>(pointStrings.length);\n        for (int i = 0; i < pointStrings.length; i++) {\n            points.add(GHPoint.fromStringLonLat(pointStrings[i]));\n        }\n\n        return points;\n    }",
            "commit_message": "avoid regex in navigate module (#2304)\n\n* replace two regexs with one indexOf\r\n\r\n* make check stricter\r\n\r\n* use @easbar's suggestion"
        },
        "CWE": "CWE-400",
        "CVE": "CVE-2021-29506"
    },
    {
        "data": {
            "function_name": "main",
            "function_code": "public static void main(String[] args) {\n\t\t//test code\n\t\tString s;\n\n\t\t/*\n\t\tv.assertEquals(v.getProtocol(),\"files\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(),\"c:\");\n\t\t */\n\t\t//unknown protocol names\n\t\ts = \"files://c:\";\n\n\t\tVFSURIValidator v = new VFSURIValidator();\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"files://c:\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"FTPS://c:\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"ftps://c:\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"files123://c:\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"fiLE://c:\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\t//file tests\n\t\ts = \"file://c:\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"c:\");\n\n\t\ts = \"file://d:\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"d:\");\n\n\t\ts = \"file://e:\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"e:\");\n\n\t\ts = \"file://z:\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"z:\");\n\n\t\ts = \"file://c:/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"c:/\");\n\n\t\ts = \"file://d:/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"d:/\");\n\n\t\ts = \"file://e:/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"e:/\");\n\n\t\ts = \"file://z:/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"z:/\");\n\n\t\ts = \"file://c:/a\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"c:/a\");\n\n\t\ts = \"file://d:/a\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"d:/a\");\n\n\t\ts = \"file://e:/b\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"e:/b\");\n\n\t\ts = \"file://z:/b\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"z:/b\");\n\n\t\ts = \"FILE://c:\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"c:\");\n\n\t\ts = \"FILE://d:\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"d:\");\n\n\t\ts = \"FILE://e:\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"e:\");\n\n\t\ts = \"FILE://z:\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"z:\");\n\n\t\ts = \"FILE://c:/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"c:/\");\n\n\t\ts = \"FILE://d:/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"d:/\");\n\n\t\ts = \"FILE://e:/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"e:/\");\n\n\t\ts = \"FILE://z:/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"z:/\");\n\n\t\ts = \"FILE://c:/a\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"c:/a\");\n\n\t\ts = \"FILE://d:/a\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"d:/a\");\n\n\t\ts = \"FILE://e:/b\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"e:/b\");\n\n\t\ts = \"FILE://z:/b\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FILE\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"z:/b\");\n\n\t\t//ftp tests\n\t\ts = \"ftp://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"ftp\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"ftp://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"ftp\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"ftp://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"ftp\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"ftp://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"ftp://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"ftp\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"ftp://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"ftp\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"ftp://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"ftp://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"ftp\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"ftp://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"ftp\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"ftp: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"ftp:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"ftp:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"ftp://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"ftp://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\t//System.exit(10);\n\t\ts = \"FTP://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FTP\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"FTP://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FTP\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"FTP://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FTP\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"FTP://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"FTP://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"FTP://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"FTP://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"FTP://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"FTP://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"FTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"FTP: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"FTP:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"FTP:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"FTP://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"FTP://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\t//sftp tests\n\t\ts = \"sftp://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"sftp\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"sftp://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"sftp\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"sftp://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"sftp\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"sftp://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"sftp://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"sftp\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"sftp://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"sftp\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"sftp://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"sftp://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"sftp\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"sftp://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"sftp\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"sftp: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"sftp:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"sftp:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"sftp://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"sftp://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SFTP://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SFTP\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SFTP://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SFTP\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SFTP://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SFTP\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SFTP://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SFTP://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SFTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SFTP://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SFTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SFTP://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SFTP://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SFTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SFTP://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SFTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"SFTP: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SFTP:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\n\t\ts = \"SFTP:/ /user:pass:@machine\";\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SFTP://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SFTP://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\t//http tests\n\t\ts = \"http://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"http\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"http://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"http\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"http://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"http\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"http://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"http://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"http\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"http://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"http\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"http://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"http://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"http\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"http://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"http\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"http: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"http:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"http:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"http://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"http://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTP://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTP\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTP://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTP\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTP://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTP\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTP://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTP://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTP://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTP://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTP://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTP://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTP\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"HTTP: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTP:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTP:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTP://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTP://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\t//https tests\n\t\ts = \"https://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"https\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"https://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"https\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"https://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"https\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"https://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"https://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"https\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"https://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"https\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"https://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"https://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"https\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"https://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"https\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"https: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"https:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"https:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"https://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"https://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTPS://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTPS\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTPS://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTPS\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTPS://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTPS\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTPS://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTPS://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTPS\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTPS://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTPS\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTPS://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTPS://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTPS\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"HTTPS://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"HTTPS\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"HTTPS: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTPS:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTPS:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTPS://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"HTTPS://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\t//webdav tests\n\t\ts = \"webdav://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"webdav\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"webdav://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"webdav\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"webdav://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"webdav\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"webdav://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"webdav://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"webdav\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"webdav://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"webdav\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"webdav://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"webdav://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"webdav\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"webdav://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\n\t\ts = \"webdav: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"webdav:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"webdav:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"webdav://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"webdav://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"WEBDAV://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"WEBDAV\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"WEBDAV://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"WEBDAV\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"WEBDAV://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"WEBDAV\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"WEBDAV://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"WEBDAV://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"WEBDAV\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"WEBDAV://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"WEBDAV\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"WEBDAV://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"WEBDAV://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"WEBDAV\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"WEBDAV://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"WEBDAV\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"WEBDAV: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"WEBDAV:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"WEBDAV:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"WEBDAV://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"WEBDAV://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\t//smb tests\n\t\ts = \"smb://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"smb\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"smb://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"smb\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"smb://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"smb\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"smb://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"smb://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"smb\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"smb://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"smb\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"smb://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"smb://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"smb\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"smb://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"smb\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"smb: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"smb:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"smb:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"smb://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"smb://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SMB://machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SMB\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SMB://machine:1/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SMB\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"1\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SMB://machine:12345/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SMB\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"12345\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SMB://machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SMB://user:pass@machine/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SMB\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SMB://user:pass@machine:123/the_file\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SMB\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertEquals(v.getPort(), \"123\");\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SMB://user:pass@machine:/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SMB://user:pass:@machine/the_file\"; //can \":\" be part of a password?\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SMB\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_file\");\n\n\t\ts = \"SMB://user:pass:@machine/the_dir/\";\n\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"SMB\");\n\t\tv.assertEquals(v.getUser(), \"user\");\n\t\tv.assertEquals(v.getPassword(), \"pass:\");\n\t\tv.assertEquals(v.getHostname(), \"machine\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/the_dir/\");\n\n\t\ts = \"SMB: //user:pass:@machine/the_file\"; //failure tests\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SMB:/ /user:pass:@machine/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SMB:/ /user:pass:@machine\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SMB://user:pass:@:123/a\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"SMB://user:pass:@machine:a/the_file\";\n\n\t\tif (v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertNull(v.getProtocol());\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\t//add tests from Yves\n\t\ts = \"sftp://shell.sf.net\";\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"sftp\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"shell.sf.net\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"file:///C:/home/birdman\";\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"C:/home/birdman\");\n\n\t\ts = \"file:///home/birdman\";\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/home/birdman\");\n\n\t\ts = \"file://home/birdman\";\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(),\"file\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertNull(v.getHostname());\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(),\"home/birdman\");\n\n\t\ts = \"webdav://myserver.net/home/yves\";\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"webdav\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"myserver.net\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertEquals(v.getFile(), \"/home/yves\");\n\n\t\ts = \"ftp://ftp.ca.freebsd.org\";\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"ftp\");\n\t\tv.assertNull(v.getUser());\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"ftp.ca.freebsd.org\");\n\t\tv.assertNull(v.getPort());\n\t\tv.assertNull(v.getFile());\n\n\t\ts = \"sftp://yves@shell.sf.net:28\";\n\t\tif (!v.isValid(s)) {\n\t\t\tv.error_msg(s);\n\t\t}\n\t\tv.assertEquals(v.getProtocol(), \"sftp\");\n\t\tv.assertEquals(v.getUser(), \"yves\");\n\t\tv.assertNull(v.getPassword());\n\t\tv.assertEquals(v.getHostname(), \"shell.sf.net\");\n\t\tv.assertEquals(v.getPort(), \"28\");\n\t\tv.assertNull(v.getFile());\n\n\t\tSystem.out.println(\"all done\");\n\t}",
            "commit_message": "incorporated Yeting Li's fix for Potential Regex Denial of Service (ReDoS), see https://github.com/fracpete/vfsjfilechooser2/issues/7\npasswords can now also contain special characters (eg :), which have to be URL encoded (ie %3A)"
        },
        "CWE": "CWE-770",
        "CVE": "CVE-2021-29061"
    },
    {
        "data": {
            "function_name": "authenticate",
            "function_code": "@Override\n\tpublic Authenticated authenticate(UsernamePasswordToken token) {\n\t\tString fullName = null;\n\t\tString email = null;\n\t\tCollection<String> groupNames = null;\n        Collection<String> sshKeys = null;\n\n        Name userSearchBase;\n\t\ttry {\n\t\t\tuserSearchBase = new CompositeName().add(getUserSearchBase());\n\t\t} catch (InvalidNameException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \"{0}\", token.getUsername());\n        userSearchFilter = StringUtils.replace(userSearchFilter, \"\\\\\", \"\\\\\\\\\");\n        logger.debug(\"Evaluated user search filter: \" + userSearchFilter);\n        \n        SearchControls searchControls = new SearchControls();\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        List<String> attributeNames = new ArrayList<String>();\n        if (getUserFullNameAttribute() != null)\n            attributeNames.add(getUserFullNameAttribute());\n        \n        if (getUserSshKeyAttribute() != null)\n        \tattributeNames.add(getUserSshKeyAttribute());\n        \n        attributeNames.add(getUserEmailAttribute());\n        \n        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();\n            attributeNames.add(groupRetrieval.getUserGroupsAttribute());\n        }\n        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));\n        searchControls.setReturningObjFlag(true);\n\n        Hashtable<String, String> ldapEnv = new Hashtable<>();\n        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());\n        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        ldapEnv.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(Context.REFERRAL, \"follow\");\n        \n        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());\n        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());\n\n        DirContext ctx = null;\n        DirContext referralCtx = null;\n        try {\n            logger.debug(\"Binding to ldap url '\" + getLdapUrl() + \"'...\");\n            try {\n            \tctx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n        \t\tthrow new RuntimeException(\"Can not bind to ldap server '\" + getLdapUrl() + \"': \" + e.getMessage());\n            }\n            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);\n            if (results == null || !results.hasMore()) \n                throw new UnknownAccountException(\"Unknown account\");\n            \n            SearchResult searchResult = (SearchResult) results.next();\n            String userDN = searchResult.getNameInNamespace();\n            if (!searchResult.isRelative()) {\n            \tStringBuffer buffer = new StringBuffer();\n                buffer.append(StringUtils.substringBefore(searchResult.getName(), \"//\"));\n                buffer.append(\"//\");\n                buffer.append(StringUtils.substringBefore(\n                \t\tStringUtils.substringAfter(searchResult.getName(), \"//\"), \"/\"));\n                \n                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());\n                logger.debug(\"Binding to referral ldap url '\" + buffer.toString() + \"'...\");\n                referralCtx = new InitialDirContext(ldapEnv);\n            }\n            if (userDN.startsWith(\"ldap\")) {\n            \tuserDN = StringUtils.substringAfter(userDN, \"//\");\n            \tuserDN = StringUtils.substringAfter(userDN, \"/\");\n            }\n\n            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);\n            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));\n            DirContext userCtx = null;\n            try {\n                logger.debug(\"Authenticating user by binding as '\" + userDN + \"'...\");\n                userCtx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n            \tthrow new org.apache.shiro.authc.AuthenticationException(\"Unable to bind as '\" + userDN + \"'\", e);\n            } finally {\n                if (userCtx != null) {\n                    try {\n                        userCtx.close();\n                    } catch (NamingException e) {\n                    }\n                }\n            }\n\n            Attributes searchResultAttributes = searchResult.getAttributes();\n            \n            if (searchResultAttributes != null) {\n                if (getUserFullNameAttribute() != null) {\n                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());\n                    if (attribute != null && attribute.get() != null)\n                        fullName = (String) attribute.get();\n                }\n                \n                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());\n                if (attribute != null && attribute.get() != null)\n                    email = (String) attribute.get();\n                \n                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) \n                \tgroupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);\n                \n                if (getUserSshKeyAttribute() != null) \n                \tsshKeys = retrieveSshKeys(searchResultAttributes);\n            }\n            \n            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter) \n            \tgroupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);\n            \n            if (StringUtils.isBlank(email))\n            \tthrow new AccountException(\"Email is required but not available in ldap directory\");\n            else\n            \treturn new Authenticated(email, fullName, groupNames, sshKeys);\n        } catch (NamingException e) {\n        \tthrow new RuntimeException(e);\n        } finally {\n            if (ctx != null) {\n                try {\n                    ctx.close();\n                } catch (NamingException e) {\n                }\n            }\n            if (referralCtx != null) {\n                try {\n                    referralCtx.close();\n                } catch (NamingException e) {\n                }\n            }\n        }\n\t}",
            "commit_message": "Fix issue #304 - Potential information leak via Ldap injection when ldap\nauthenticator is enabled"
        },
        "CWE": "CWE-90",
        "CVE": "CVE-2021-32651"
    },
    {
        "data": {
            "function_name": "validateToken",
            "function_code": "public Claims validateToken(String token) throws AuthenticationException {\n        try {\n            RsaKeyUtil rsaKeyUtil = new RsaKeyUtil();\n            PublicKey publicKey = rsaKeyUtil.fromPemEncoded(keycloakPublicKey);\n\n            return Jwts.parser().setSigningKey(publicKey).parseJws(token.replace(\"Bearer \", \"\")).getBody();\n        } catch (Exception e){\n            throw new AuthenticationException(String.format(\"Failed to check user authorization for token: %s\", token), e);\n        }\n    }",
            "commit_message": "Use parseClaimsJws method instead of parseJws"
        },
        "CWE": "CWE-290",
        "CVE": "CVE-2021-32631"
    },
    {
        "data": {
            "function_name": "forbidCircularReferences",
            "function_code": "private void forbidCircularReferences(String patternName, List<String> path, String pattern) {\n        // first ensure that the pattern bank contains no simple circular references (i.e., any pattern\n        // containing an immediate reference to itself) as those can cause the remainder of this algorithm\n        // to recurse infinitely\n        for (Map.Entry<String, String> entry : patternBank.entrySet()) {\n            if (patternReferencesItself(entry.getValue(), entry.getKey())) {\n                throw new IllegalArgumentException(\"circular reference in pattern [\" + entry.getKey() + \"][\" + entry.getValue() + \"]\");\n            }\n        }\n\n        // next recursively check any other pattern names referenced in the pattern\n        innerForbidCircularReferences(patternName, path, pattern);\n    }",
            "commit_message": "Improve efficiency of Grok circular reference check (#74814)\n\nThis change is a tweak to #74581 which removes the N^2\nloop that was added in that PR."
        },
        "CWE": "CWE-674",
        "CVE": "CVE-2021-22144"
    },
    {
        "data": {
            "function_name": "evaluateFinalClientMessage",
            "function_code": "public ScramFinalServerMessage evaluateFinalClientMessage(final ScramInitialServerResult initialResult, final ScramFinalClientMessage clientMessage) throws AuthenticationMechanismException {\n        final boolean trace = saslScram.isTraceEnabled();\n\n        if (clientMessage.getMechanism() != mechanism) {\n            throw saslScram.mechUnmatchedMechanism(mechanism.toString(), clientMessage.getMechanism().toString());\n        }\n\n        ByteStringBuilder b = new ByteStringBuilder();\n\n        try {\n\n            final Mac mac = Mac.getInstance(getMechanism().getHmacName());\n            final MessageDigest messageDigest = MessageDigest.getInstance(getMechanism().getMessageDigestName());\n\n            // == verify proof ==\n\n            // client key\n            byte[] clientKey;\n            mac.reset();\n            byte[] saltedPassword = initialResult.getScramDigestPassword().getDigest();\n            mac.init(new SecretKeySpec(saltedPassword, mac.getAlgorithm()));\n            mac.update(ScramUtil.CLIENT_KEY_BYTES);\n            clientKey = mac.doFinal();\n            if(trace) saslScram.tracef(\"[S] Client key: %s%n\", ByteIterator.ofBytes(clientKey).hexEncode().drainToString());\n\n            // stored key\n            byte[] storedKey;\n            messageDigest.reset();\n            messageDigest.update(clientKey);\n            storedKey = messageDigest.digest();\n            if(trace) saslScram.tracef(\"[S] Stored key: %s%n\", ByteIterator.ofBytes(storedKey).hexEncode().drainToString());\n\n            // client signature\n            mac.reset();\n            mac.init(new SecretKeySpec(storedKey, mac.getAlgorithm()));\n            final byte[] clientFirstMessage = clientMessage.getInitialResponse().getRawMessageBytes();\n            final int clientFirstMessageBareStart = clientMessage.getInitialResponse().getInitialPartIndex();\n            mac.update(clientFirstMessage, clientFirstMessageBareStart, clientFirstMessage.length - clientFirstMessageBareStart);\n            if(trace) saslScram.tracef(\"[S] Using client first message: %s%n\", ByteIterator.ofBytes(copyOfRange(clientFirstMessage, clientFirstMessageBareStart, clientFirstMessage.length)).hexEncode().drainToString());\n            mac.update((byte) ',');\n            final byte[] serverFirstMessage = initialResult.getScramInitialChallenge().getRawMessageBytes();\n            mac.update(serverFirstMessage);\n            if(trace) saslScram.tracef(\"[S] Using server first message: %s%n\", ByteIterator.ofBytes(serverFirstMessage).hexEncode().drainToString());\n            mac.update((byte) ',');\n            final byte[] response = clientMessage.getRawMessageBytes();\n            final int proofOffset = clientMessage.getProofOffset();\n            mac.update(response, 0, proofOffset); // client-final-message-without-proof\n            if(trace) saslScram.tracef(\"[S] Using client final message without proof: %s%n\", ByteIterator.ofBytes(copyOfRange(response, 0, proofOffset)).hexEncode().drainToString());\n            byte[] clientSignature = mac.doFinal();\n            if(trace) saslScram.tracef(\"[S] Client signature: %s%n\", ByteIterator.ofBytes(clientSignature).hexEncode().drainToString());\n\n            // server key\n            byte[] serverKey;\n            mac.reset();\n            mac.init(new SecretKeySpec(saltedPassword, mac.getAlgorithm()));\n            mac.update(ScramUtil.SERVER_KEY_BYTES);\n            serverKey = mac.doFinal();\n            if(trace) saslScram.tracef(\"[S] Server key: %s%n\", ByteIterator.ofBytes(serverKey).hexEncode().drainToString());\n\n            // server signature\n            byte[] serverSignature;\n            mac.reset();\n            mac.init(new SecretKeySpec(serverKey, mac.getAlgorithm()));\n            mac.update(clientFirstMessage, clientFirstMessageBareStart, clientFirstMessage.length - clientFirstMessageBareStart);\n            mac.update((byte) ',');\n            mac.update(serverFirstMessage);\n            mac.update((byte) ',');\n            mac.update(response, 0, proofOffset); // client-final-message-without-proof\n            serverSignature = mac.doFinal();\n            if(trace) saslScram.tracef(\"[S] Server signature: %s%n\", ByteIterator.ofBytes(serverSignature).hexEncode().drainToString());\n\n            final byte[] recoveredClientProof = clientMessage.getRawClientProof();\n            if(trace) saslScram.tracef(\"[S] Client proof: %s%n\", ByteIterator.ofBytes(recoveredClientProof).hexEncode().drainToString());\n\n            // now check the proof\n            byte[] recoveredClientKey = clientSignature.clone();\n            ScramUtil.xor(recoveredClientKey, recoveredClientProof);\n            if(trace) saslScram.tracef(\"[S] Recovered client key: %s%n\", ByteIterator.ofBytes(recoveredClientKey).hexEncode().drainToString());\n            if (! Arrays.equals(recoveredClientKey, clientKey)) {\n                throw saslScram.mechAuthenticationRejectedInvalidProof();\n            }\n\n            String userName = clientMessage.getInitialResponse().getAuthenticationName();\n            String authorizationID = clientMessage.getInitialResponse().getAuthorizationId();\n            if (authorizationID == null || authorizationID.isEmpty()) {\n                authorizationID = userName;\n            } else {\n                ByteStringBuilder bsb = new ByteStringBuilder();\n                StringPrep.encode(authorizationID, bsb, StringPrep.PROFILE_SASL_QUERY | StringPrep.UNMAP_SCRAM_LOGIN_CHARS);\n                authorizationID = new String(bsb.toArray(), StandardCharsets.UTF_8);\n            }\n            final AuthorizeCallback authorizeCallback = new AuthorizeCallback(userName, authorizationID);\n            try {\n                MechanismUtil.handleCallbacks(saslScram, callbackHandler, authorizeCallback);\n            } catch (UnsupportedCallbackException e) {\n                throw saslScram.mechAuthorizationUnsupported(e);\n            }\n            if ( ! authorizeCallback.isAuthorized()) {\n                throw saslScram.mechAuthorizationFailed(userName, authorizationID);\n            }\n\n            // == send response ==\n            b.setLength(0);\n            b.append('v').append('=');\n            b.appendUtf8(ByteIterator.ofBytes(serverSignature).base64Encode());\n\n            return new ScramFinalServerMessage(serverSignature, b.toArray());\n        } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n            throw saslScram.mechMacAlgorithmNotSupported(e);\n        }\n    }",
            "commit_message": "Merge pull request #1549 from Syquel/ELY-2147\n\n[ELY-2147] Harden ScramServer against timing attacks"
        },
        "CWE": "CWE-203",
        "CVE": "CVE-2021-3642"
    },
    {
        "data": {
            "function_name": "modelMapper",
            "function_code": "private static Object modelMapper(Map<String, Object> data) throws IOException {\n    String kind = (String) data.get(\"kind\");\n    if (kind == null) {\n      throw new IOException(\"Missing kind in YAML file!\");\n    }\n    String apiVersion = (String) data.get(\"apiVersion\");\n    if (apiVersion == null) {\n      throw new IOException(\"Missing apiVersion in YAML file!\");\n    }\n\n    Class<?> clazz = ModelMapper.getApiTypeClass(apiVersion, kind);\n    if (clazz == null) {\n      throw new IOException(\n          \"Unknown apiVersionKind \" + apiVersion + \"/\" + kind + \" is it registered?\");\n    }\n    return loadAs(new StringReader(getSnakeYaml().dump(data)), clazz);\n  }",
            "commit_message": "Merge pull request #1676 from brendandburns/yaml\n\nUpdate the CustomConstructor class for SnakeYAML."
        },
        "CWE": "CWE-502",
        "CVE": "CVE-2021-25738"
    },
    {
        "data": {
            "function_name": "yamlPathToJson",
            "function_code": "private JsonNode yamlPathToJson(Path path) throws IOException {\n        Yaml reader = new Yaml();\n        ObjectMapper mapper = new ObjectMapper();\n        Path p;\n        \n        try (InputStream in = Files.newInputStream(path)) {\n        \treturn mapper.valueToTree(reader.load(in));\n        }\n    }",
            "commit_message": "Use Yaml SafeConstructor (#355)"
        },
        "CWE": "CWE-502",
        "CVE": "CVE-2021-41110"
    },
    {
        "data": {
            "function_name": "parse",
            "function_code": "public Cron parse(final String expression) {\n        Preconditions.checkNotNull(expression, \"Expression must not be null\");\n        final String replaced = expression.replaceAll(\"\\\\s+\", \" \").trim();\n        if (StringUtils.isEmpty(replaced)) {\n            throw new IllegalArgumentException(\"Empty expression!\");\n        }\n\n        if(expression.contains(\"||\")) {\n            List<Cron> crons = Arrays.stream(expression.split(\"\\\\|\\\\|\")).map(this::parse).collect(Collectors.toList());\n            return new CompositeCron(crons);\n        }\n        if(expression.contains(\"|\")){\n            List<String> crons = new ArrayList<>();\n            int cronscount = Arrays.stream(expression.split(\"\\\\s+\")).mapToInt(s->s.split(\"\\\\|\").length).max().orElse(0);\n            for(int j=0; j<cronscount; j++){\n                StringBuilder builder = new StringBuilder();\n                for(String s : expression.split(\"\\\\s+\")){\n                    if(s.contains(\"|\")){\n                        builder.append(String.format(\"%s \", s.split(\"\\\\|\")[j]));\n                    }else{\n                        builder.append(String.format(\"%s \", s));\n                    }\n                }\n                crons.add(builder.toString().trim());\n            }\n            return new CompositeCron(crons.stream().map(this::parse).collect(Collectors.toList()));\n        }else{\n            final String[] expressionParts = replaced.toUpperCase().split(\" \");\n            final int expressionLength = expressionParts.length;\n            String fieldWithTrailingCommas = Arrays.stream(expressionParts).filter(x -> x.endsWith(\",\")).findAny().orElse(null);\n            if(fieldWithTrailingCommas!=null){\n                throw new IllegalArgumentException(String.format(\"Invalid field value! Trailing commas not permitted! '%s'\", fieldWithTrailingCommas));\n            }\n            final List<CronParserField> fields = expressions.get(expressionLength);\n            if (fields == null) {\n                throw new IllegalArgumentException(\n                        String.format(\"Cron expression contains %s parts but we expect one of %s\", expressionLength, expressions.keySet()));\n            }\n            try {\n\n                final int size = expressionParts.length;\n                final List<CronField> results = new ArrayList<>(size + 1);\n                for (int j = 0; j < size; j++) {\n                    results.add(fields.get(j).parse(expressionParts[j]));\n                }\n                return new SingleCron(cronDefinition, results).validate();\n            } catch (final IllegalArgumentException e) {\n                throw new IllegalArgumentException(String.format(\"Failed to parse '%s'. %s\", expression, e.getMessage()), e);\n            }\n        }\n    }",
            "commit_message": "Merge pull request #494 from NielsDoucet/RCE-fix\n\nResolve RCE vulnerability."
        },
        "CWE": "CWE-94",
        "CVE": "CVE-2021-41269"
    },
    {
        "data": {
            "function_name": "addContentToRepo",
            "function_code": "protected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    CloseableHttpClient externalHttpClient = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        List<String> clusterUrls = new LinkedList<>();\n        try {\n          // Note that we are not checking ports here.\n          clusterUrls = organizationDirectoryService.getOrganization(uri.toURL()).getServers()\n                          .keySet()\n                          .stream()\n                          .collect(Collectors.toUnmodifiableList());\n        } catch (NotFoundException e) {\n          logger.warn(\"Unable to determine cluster members, will not be able to authenticate any downloads from them\", e);\n        }\n\n        if (uri.toString().matches(downloadSource)) {\n          //NB: We're creating a new client here with *different* auth than the system auth creds\n          externalHttpClient = getAuthedHttpClient();\n          response = externalHttpClient.execute(get);\n        } else if (clusterUrls.contains(uri.getScheme() + \"://\" + uri.getHost())) {\n          // Only using the system-level httpclient and digest credentials against our own servers\n          response = httpClient.execute(get);\n        } else {\n          //NB: No auth here at all\n          externalHttpClient = getNoAuthHttpClient();\n          response = externalHttpClient.execute(get);\n        }\n\n        if (null == response) {\n          // If you get here then chances are you're using a mock httpClient which does not have appropriate\n          // mocking to respond to the URL you are feeding it.  Try adding that URL to the mock and see if that works.\n          throw new IOException(\"Null response object from the http client, refer to code for explanation\");\n        }\n\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n      } else {\n        in = uri.toURL().openStream();\n      }\n      String fileName = FilenameUtils.getName(uri.getPath());\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        fileName = getContentDispositionFileName(response);\n\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        throw new IOException(\"No filename extension found: \" + fileName);\n      return addContentToRepo(mp, elementId, fileName, in);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (externalHttpClient != null) {\n        externalHttpClient.close();\n      }\n      httpClient.close(response);\n    }\n  }",
            "commit_message": "Merge pull request from GHSA-59g4-hpg3-3gcp\n\nEnsure local files are not addable"
        },
        "CWE": "CWE-552",
        "CVE": "CVE-2021-43821"
    },
    {
        "data": {
            "function_name": "parseDocument",
            "function_code": "public static Document parseDocument(String fileName)\n        throws XMLException {\n        return parseDocument(new java.io.File(fileName));\n    }",
            "commit_message": "dbeaver/dbeaver-ee#1166 prevent XXE"
        },
        "CWE": "CWE-611",
        "CVE": "CVE-2021-3836"
    },
    {
        "data": {
            "function_name": "createUser",
            "function_code": "@POST\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response createUser(final UserRepresentation rep) {\n        // first check if user has manage rights\n        try {\n            auth.users().requireManage();\n        }\n        catch (ForbiddenException exception) {\n            // if user does not have manage rights, fallback to fine grain admin permissions per group\n            if (rep.getGroups() != null) {\n                // if groups is part of the user rep, check if admin has manage_members and manage_membership on each group\n                for (String groupPath : rep.getGroups()) {\n                    GroupModel group = KeycloakModelUtils.findGroupByPath(realm, groupPath);\n                    if (group != null) {\n                        auth.groups().requireManageMembers(group);\n                        auth.groups().requireManageMembership(group);\n                    } else {\n                        return ErrorResponse.error(String.format(\"Group %s not found\", groupPath), Response.Status.BAD_REQUEST);\n                    }\n                }\n            } else {\n                // propagate exception if no group specified\n                throw exception;\n            }\n        }\n\n        String username = rep.getUsername();\n        if(realm.isRegistrationEmailAsUsername()) {\n            username = rep.getEmail();\n        }\n        if (ObjectUtil.isBlank(username)) {\n            return ErrorResponse.error(\"User name is missing\", Response.Status.BAD_REQUEST);\n        }\n\n        // Double-check duplicated username and email here due to federation\n        if (session.users().getUserByUsername(realm, username) != null) {\n            return ErrorResponse.exists(\"User exists with same username\");\n        }\n        if (rep.getEmail() != null && !realm.isDuplicateEmailsAllowed()) {\n            try {\n                if(session.users().getUserByEmail(realm, rep.getEmail()) != null) {\n                    return ErrorResponse.exists(\"User exists with same email\");\n                }\n            } catch (ModelDuplicateException e) {\n                return ErrorResponse.exists(\"User exists with same email\");\n            }\n        }\n\n        UserProfileProvider profileProvider = session.getProvider(UserProfileProvider.class);\n\n        UserProfile profile = profileProvider.create(USER_API, rep.toAttributes());\n\n        try {\n            Response response = UserResource.validateUserProfile(profile, null, session);\n            if (response != null) {\n                return response;\n            }\n\n            UserModel user = profile.create();\n\n            UserResource.updateUserFromRep(profile, user, rep, session, false);\n            RepresentationToModel.createFederatedIdentities(rep, session, realm, user);\n            RepresentationToModel.createGroups(rep, realm, user);\n\n            RepresentationToModel.createCredentials(rep, session, realm, user, true);\n            adminEvent.operation(OperationType.CREATE).resourcePath(session.getContext().getUri(), user.getId()).representation(rep).success();\n\n            if (session.getTransactionManager().isActive()) {\n                session.getTransactionManager().commit();\n            }\n\n            return Response.created(session.getContext().getUri().getAbsolutePathBuilder().path(user.getId()).build()).build();\n        } catch (ModelDuplicateException e) {\n            if (session.getTransactionManager().isActive()) {\n                session.getTransactionManager().setRollbackOnly();\n            }\n            return ErrorResponse.exists(\"User exists with same username or email\");\n        } catch (PasswordPolicyNotMetException e) {\n            if (session.getTransactionManager().isActive()) {\n                session.getTransactionManager().setRollbackOnly();\n            }\n            return ErrorResponse.error(\"Password policy not met\", Response.Status.BAD_REQUEST);\n        } catch (ModelException me){\n            if (session.getTransactionManager().isActive()) {\n                session.getTransactionManager().setRollbackOnly();\n            }\n            logger.warn(\"Could not create user\", me);\n            return ErrorResponse.error(\"Could not create user\", Response.Status.BAD_REQUEST);\n        }\n    }",
            "commit_message": "Verify fine-grained admin permissions feature is enabled before checking fine-grained permissions when creating users\n\nCo-authored-by: stianst <stianst@gmail.com>"
        },
        "CWE": "CWE-863",
        "CVE": "CVE-2021-4133"
    },
    {
        "data": {
            "function_name": "parseXml",
            "function_code": "private Document parseXml(String xmlContent) {\n\t\ttry {\n\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tDocument document = builder.parse(new InputSource(new StringReader(xmlContent)));\n\n\t\t\tdocument.getDocumentElement().normalize();\n\n\t\t\treturn document;\n\t\t} catch (Exception e) {\n\t\t\tthrow new JadxRuntimeException(\"Can not parse xml content\", e);\n\t\t}\n\t}",
            "commit_message": "fix: use secure xml parser for process manifest"
        },
        "CWE": "CWE-611",
        "CVE": "CVE-2022-0219"
    },
    {
        "data": {
            "function_name": "getValidatingXmlParser",
            "function_code": "public static DocumentBuilder getValidatingXmlParser(File schemaFile) {\n    DocumentBuilder db = null;\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n\n      SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n      Schema schema = factory.newSchema(schemaFile);\n      dbf.setSchema(schema);\n\n      db = dbf.newDocumentBuilder();\n      db.setErrorHandler(new SAXErrorHandler());\n\n    } catch (ParserConfigurationException e) {\n      log.warnf(\"%s: Unable to create XML parser\\n\", XMLUtils.class.getName());\n      log.warn(e);\n\n    } catch (SAXException e) {\n      log.warnf(\"%s: XML parsing exception while loading schema %s\\n\", XMLUtils.class.getName(),schemaFile.getPath());\n      log.warn(e);\n\n    } catch(UnsupportedOperationException e) {\n      log.warnf(\"%s: API error while setting up XML parser. Check your JAXP version\\n\", XMLUtils.class.getName());\n      log.warn(e);\n    }\n\n    return db;\n  }",
            "commit_message": "Fix XML schema vulnerability"
        },
        "CWE": "CWE-611",
        "CVE": "CVE-2022-0239"
    },
    {
        "data": {
            "function_name": "getValidatingXmlParser",
            "function_code": "public static DocumentBuilder getValidatingXmlParser(File schemaFile) {\n    DocumentBuilder db = null;\n    try {\n      DocumentBuilderFactory dbf = safeDocumentBuilderFactory();\n\n      SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n      Schema schema = factory.newSchema(schemaFile);\n      dbf.setSchema(schema);\n\n      db = dbf.newDocumentBuilder();\n      db.setErrorHandler(new SAXErrorHandler());\n\n    } catch (ParserConfigurationException e) {\n      log.warnf(\"%s: Unable to create XML parser\\n\", XMLUtils.class.getName());\n      log.warn(e);\n\n    } catch (SAXException e) {\n      log.warnf(\"%s: XML parsing exception while loading schema %s\\n\", XMLUtils.class.getName(),schemaFile.getPath());\n      log.warn(e);\n\n    } catch(UnsupportedOperationException e) {\n      log.warnf(\"%s: API error while setting up XML parser. Check your JAXP version\\n\", XMLUtils.class.getName());\n      log.warn(e);\n    }\n\n    return db;\n  }",
            "commit_message": "Fix XML schema vulnerability"
        },
        "CWE": "CWE-611",
        "CVE": "CVE-2022-0239"
    },
    {
        "data": {
            "function_name": "unzipFilesToPath",
            "function_code": "public static void unzipFilesToPath(String jarPath, String destinationDir) throws IOException {\n        File file = new File(jarPath);\n        try (JarFile jar = new JarFile(file)) {\n\n            // fist get all directories,\n            // then make those directory on the destination Path\n            /*for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {\n                JarEntry entry = (JarEntry) enums.nextElement();\n\n                String fileName = destinationDir + File.separator + entry.getName();\n                File f = new File(fileName);\n\n                if (fileName.endsWith(\"/\")) {\n                    f.mkdirs();\n                }\n\n            }*/\n\n            //now create all files\n            for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {\n                JarEntry entry = enums.nextElement();\n\n                String fileName = destinationDir + File.separator + entry.getName();\n                File f = new File(fileName);\n\n                if (!f.getCanonicalPath().startsWith(destinationDir)) {\n                    System.out.println(\"Zip Slip exploit detected. Skipping entry \" + entry.getName());\n                    continue;\n                }\n\n                File parent = f.getParentFile();\n                if (!parent.exists()) {\n                    parent.mkdirs();\n                }\n\n                if (!fileName.endsWith(\"/\")) {\n                    try (InputStream is = jar.getInputStream(entry);\n                         FileOutputStream fos = new FileOutputStream(f)) {\n                        // write contents of 'is' to 'fos'\n                        while (is.available() > 0) {\n                            fos.write(is.read());\n                        }\n                    }\n                }\n            }\n        }\n    }",
            "commit_message": "Improve Zip Slip detection"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-21675"
    },
    {
        "data": {
            "function_name": "initializeVelocity",
            "function_code": "private void initializeVelocity() {\n\t\tif (velocityEngine == null) {\n\t\t\tvelocityEngine = new VelocityEngine();\n\t\t\t\n\t\t\tProperties props = new Properties();\n\t\t\tprops.setProperty(RuntimeConstants.RUNTIME_LOG, \"startup_wizard_vel.log\");\n\t\t\t// Linux requires setting logging properties to initialize Velocity Context.\n\t\t\tprops.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM_CLASS,\n\t\t\t    \"org.apache.velocity.runtime.log.CommonsLogLogChute\");\n\t\t\tprops.setProperty(CommonsLogLogChute.LOGCHUTE_COMMONS_LOG_NAME, \"initial_wizard_velocity\");\n\t\t\t\n\t\t\t// so the vm pages can import the header/footer\n\t\t\tprops.setProperty(RuntimeConstants.RESOURCE_LOADER, \"class\");\n\t\t\tprops.setProperty(\"class.resource.loader.description\", \"Velocity Classpath Resource Loader\");\n\t\t\tprops.setProperty(\"class.resource.loader.class\",\n\t\t\t    \"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader\");\n\t\t\t\n\t\t\ttry {\n\t\t\t\tvelocityEngine.init(props);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error(\"velocity init failed, because: \" + e);\n\t\t\t}\n\t\t}\n\t}",
            "commit_message": "Fix bug"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-23612"
    },
    {
        "data": {
            "function_name": "run",
            "function_code": "@Override\n      public Void run() throws Exception {\n        getHadoopTokens(state, Optional.absent(), cred);\n        return null;\n      }",
            "commit_message": "[GOBBLIN-1495] Fix NPE when trying to fetch Hadoop tokens for cluster with no remote namenodes (#3341)"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2021-36151"
    },
    {
        "data": {
            "function_name": "readHeaders",
            "function_code": "private void readHeaders(final long fileLength) throws IOException, RarException {\n        this.markHead = null;\n        this.newMhd = null;\n        this.headers.clear();\n        this.currentHeaderIndex = 0;\n        int toRead = 0;\n\n        //keep track of positions already processed for\n        //more robustness against corrupt files\n        final Set<Long> processedPositions = new HashSet<>();\n        while (true) {\n            int size = 0;\n            long newpos = 0;\n            RawDataIo rawData = new RawDataIo(channel);\n            final byte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);\n\n            // if header is encrypted,there is a 8-byte salt before each header\n            if (newMhd != null && newMhd.isEncrypted()) {\n                byte[] salt = new byte[8];\n                rawData.readFully(salt, 8);\n                try {\n                    Cipher cipher = Rijndael.buildDecipherer(password, salt);\n                    rawData.setCipher(cipher);\n                } catch (Exception e) {\n                    throw new InitDeciphererFailedException(e);\n                }\n            }\n\n            final long position = this.channel.getPosition();\n\n            // Weird, but is trying to read beyond the end of the file\n            if (position >= fileLength) {\n                break;\n            }\n\n            // logger.info(\"\\n--------reading header--------\");\n            size = rawData.readFully(baseBlockBuffer, baseBlockBuffer.length);\n\n            if (size == 0) {\n                break;\n            }\n            final BaseBlock block = new BaseBlock(baseBlockBuffer);\n\n            block.setPositionInFile(position);\n\n            UnrarHeadertype headerType = block.getHeaderType();\n            if (headerType == null) {\n                logger.warn(\"unknown block header!\");\n                throw new CorruptHeaderException();\n            }\n            switch (headerType) {\n\n                case MarkHeader:\n                    this.markHead = new MarkHeader(block);\n                    if (!this.markHead.isSignature()) {\n                        if (markHead.getVersion() == RARVersion.V5) {\n                            logger.warn(\"Support for rar version 5 is not yet implemented!\");\n                            throw new UnsupportedRarV5Exception();\n                        } else {\n                            throw new BadRarArchiveException();\n                        }\n                    }\n                    this.headers.add(this.markHead);\n                    // markHead.print();\n                    break;\n\n                case MainHeader:\n                    toRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc\n                        : MainHeader.mainHeaderSize;\n                    final byte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(mainbuff, mainbuff.length);\n                    final MainHeader mainhead = new MainHeader(block, mainbuff);\n                    this.headers.add(mainhead);\n                    this.newMhd = mainhead;\n                    break;\n\n                case SignHeader:\n                    toRead = SignHeader.signHeaderSize;\n                    final byte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(signBuff, signBuff.length);\n                    final SignHeader signHead = new SignHeader(block, signBuff);\n                    this.headers.add(signHead);\n                    break;\n\n                case AvHeader:\n                    toRead = AVHeader.avHeaderSize;\n                    final byte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(avBuff, avBuff.length);\n                    final AVHeader avHead = new AVHeader(block, avBuff);\n                    this.headers.add(avHead);\n                    break;\n\n                case CommHeader:\n                    toRead = CommentHeader.commentHeaderSize;\n                    final byte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(commBuff, commBuff.length);\n                    final CommentHeader commHead = new CommentHeader(block, commBuff);\n                    this.headers.add(commHead);\n\n                    newpos = commHead.getPositionInFile() + commHead.getHeaderSize(isEncrypted());\n                    this.channel.setPosition(newpos);\n\n                    if (processedPositions.contains(newpos)) {\n                        throw new BadRarArchiveException();\n                    }\n                    processedPositions.add(newpos);\n\n                    break;\n                case EndArcHeader:\n\n                    toRead = 0;\n                    if (block.hasArchiveDataCRC()) {\n                        toRead += EndArcHeader.endArcArchiveDataCrcSize;\n                    }\n                    if (block.hasVolumeNumber()) {\n                        toRead += EndArcHeader.endArcVolumeNumberSize;\n                    }\n                    EndArcHeader endArcHead;\n                    if (toRead > 0) {\n                        final byte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                        rawData.readFully(endArchBuff, endArchBuff.length);\n                        endArcHead = new EndArcHeader(block, endArchBuff);\n                    } else {\n                        endArcHead = new EndArcHeader(block, null);\n                    }\n                    this.headers.add(endArcHead);\n                    return;\n\n                default:\n                    final byte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);\n                    rawData.readFully(blockHeaderBuffer, blockHeaderBuffer.length);\n                    final BlockHeader blockHead = new BlockHeader(block,\n                        blockHeaderBuffer);\n\n                    switch (blockHead.getHeaderType()) {\n                        case NewSubHeader:\n                        case FileHeader:\n                            toRead = blockHead.getHeaderSize(false)\n                                - BlockHeader.BaseBlockSize\n                                - BlockHeader.blockHeaderSize;\n                            final byte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                            rawData.readFully(fileHeaderBuffer, fileHeaderBuffer.length);\n\n                            final FileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);\n                            this.headers.add(fh);\n                            newpos = fh.getPositionInFile() + fh.getHeaderSize(isEncrypted()) + fh.getFullPackSize();\n                            this.channel.setPosition(newpos);\n\n                            if (processedPositions.contains(newpos)) {\n                                throw new BadRarArchiveException();\n                            }\n                            processedPositions.add(newpos);\n                            break;\n\n                        case ProtectHeader:\n                            toRead = blockHead.getHeaderSize(false)\n                                - BlockHeader.BaseBlockSize\n                                - BlockHeader.blockHeaderSize;\n                            final byte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                            rawData.readFully(protectHeaderBuffer, protectHeaderBuffer.length);\n                            final ProtectHeader ph = new ProtectHeader(blockHead, protectHeaderBuffer);\n                            newpos = ph.getPositionInFile() + ph.getHeaderSize(isEncrypted()) + ph.getDataSize();\n                            this.channel.setPosition(newpos);\n\n                            if (processedPositions.contains(newpos)) {\n                                throw new BadRarArchiveException();\n                            }\n                            processedPositions.add(newpos);\n                            break;\n\n                        case SubHeader: {\n                            final byte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);\n                            rawData.readFully(subHeadbuffer, subHeadbuffer.length);\n                            final SubBlockHeader subHead = new SubBlockHeader(blockHead,\n                                subHeadbuffer);\n                            subHead.print();\n                            switch (subHead.getSubType()) {\n                                case MAC_HEAD: {\n                                    final byte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);\n                                    rawData.readFully(macHeaderbuffer, macHeaderbuffer.length);\n                                    final MacInfoHeader macHeader = new MacInfoHeader(subHead,\n                                        macHeaderbuffer);\n                                    macHeader.print();\n                                    this.headers.add(macHeader);\n\n                                    break;\n                                }\n                                // TODO implement other subheaders\n                                case BEEA_HEAD:\n                                    break;\n                                case EA_HEAD: {\n                                    final byte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);\n                                    rawData.readFully(eaHeaderBuffer, eaHeaderBuffer.length);\n                                    final EAHeader eaHeader = new EAHeader(subHead,\n                                        eaHeaderBuffer);\n                                    eaHeader.print();\n                                    this.headers.add(eaHeader);\n\n                                    break;\n                                }\n                                case NTACL_HEAD:\n                                    break;\n                                case STREAM_HEAD:\n                                    break;\n                                case UO_HEAD:\n                                    toRead = subHead.getHeaderSize(false);\n                                    toRead -= BaseBlock.BaseBlockSize;\n                                    toRead -= BlockHeader.blockHeaderSize;\n                                    toRead -= SubBlockHeader.SubBlockHeaderSize;\n                                    final byte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                                    rawData.readFully(uoHeaderBuffer, uoHeaderBuffer.length);\n                                    final UnixOwnersHeader uoHeader = new UnixOwnersHeader(\n                                        subHead, uoHeaderBuffer);\n                                    uoHeader.print();\n                                    this.headers.add(uoHeader);\n                                    break;\n                                default:\n                                    break;\n                            }\n\n                            break;\n                        }\n                        default:\n                            logger.warn(\"Unknown Header\");\n                            throw new NotRarArchiveException();\n\n                    }\n            }\n            // logger.info(\"\\n--------end header--------\");\n        }\n    }",
            "commit_message": "fix: invalid subheader type would throw npe and make the extract loop\n\ncloses #73"
        },
        "CWE": "CWE-835",
        "CVE": "CVE-2022-23596"
    },
    {
        "data": {
            "function_name": "execute",
            "function_code": "@Override\n            public void execute(Runnable command) {\n                internal.runOnContext(new Handler<Void>() {\n                    @Override\n                    public void handle(Void unused) {\n                        command.run();\n                    }\n                });\n            }",
            "commit_message": "Use the correct context for RR"
        },
        "CWE": "CWE-863",
        "CVE": "CVE-2022-0981"
    },
    {
        "data": {
            "function_name": "processStyleTag",
            "function_code": "private boolean processStyleTag(Element ele, Node parentNode) {\n        /*\n         * Invoke the css parser on this element.\n         */\n        CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());\n\n        try {\n            Node firstChild = ele.getFirstChild();\n            if (firstChild != null) {\n\n                String toScan = firstChild.getNodeValue();\n                CleanResults cr = styleScanner.scanStyleSheet(toScan, policy.getMaxInputSize());\n                errorMessages.addAll(cr.getErrorMessages());\n\n                /*\n                 * If IE gets an empty style tag, i.e. <style/> it will\n                 * break all CSS on the page. I wish I was kidding. So,\n                 * if after validation no CSS properties are left, we\n                 * would normally be left with an empty style tag and\n                 * break all CSS. To prevent that, we have this check.\n                 */\n\n                final String cleanHTML = cr.getCleanHTML();\n\n                if (cleanHTML == null || cleanHTML.equals(\"\")) {\n                    firstChild.setNodeValue(\"/* */\");\n                } else {\n                    firstChild.setNodeValue(cleanHTML);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException e) {\n\n            /*\n             * ParseException shouldn't be possible anymore, but we'll leave it\n             * here because I (Arshan) am hilariously dumb sometimes.\n             * Batik can throw NumberFormatExceptions (see bug #48).\n             */\n\n            addError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(ele.getFirstChild().getNodeValue())});\n            parentNode.removeChild(ele);\n            return true;\n        }\n        return false;\n    }",
            "commit_message": "Support multiple children handling on style tags"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-28367"
    },
    {
        "data": {
            "function_name": "processStyleTag",
            "function_code": "private boolean processStyleTag(Element ele, Node parentNode) {\n        /*\n         * Invoke the css parser on this element.\n         */\n        CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());\n\n        try {\n            if (ele.getChildNodes().getLength() > 0) {\n                StringBuffer toScan = new StringBuffer();\n\n                for (int i = 0; i < ele.getChildNodes().getLength(); i++) {\n                    Node childNode = ele.getChildNodes().item(i);\n                    if (toScan.length() > 0) {\n                        toScan.append(\"\\n\");\n                    }\n                    toScan.append(childNode.getTextContent());\n                }\n\n                CleanResults cr = styleScanner.scanStyleSheet(toScan.toString(), policy.getMaxInputSize());\n                errorMessages.addAll(cr.getErrorMessages());\n\n                /*\n                 * If IE gets an empty style tag, i.e. <style/> it will\n                 * break all CSS on the page. I wish I was kidding. So,\n                 * if after validation no CSS properties are left, we\n                 * would normally be left with an empty style tag and\n                 * break all CSS. To prevent that, we have this check.\n                 */\n\n                String cleanHTML = cr.getCleanHTML();\n                cleanHTML = cleanHTML == null || cleanHTML.equals(\"\") ? \"/* */\" : cleanHTML;\n\n                ele.getFirstChild().setNodeValue(cleanHTML);\n                /*\n                 * Remove every other node after cleaning CSS, there will\n                 * be only one node in the end, as it always should have.\n                 */\n                for (int i = 1; i < ele.getChildNodes().getLength(); i++) {\n                    Node childNode = ele.getChildNodes().item(i);\n                    ele.removeChild(childNode);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException e) {\n\n            /*\n             * ParseException shouldn't be possible anymore, but we'll leave it\n             * here because I (Arshan) am hilariously dumb sometimes.\n             * Batik can throw NumberFormatExceptions (see bug #48).\n             */\n\n            addError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(ele.getFirstChild().getNodeValue())});\n            parentNode.removeChild(ele);\n            return true;\n        }\n        return false;\n    }",
            "commit_message": "Fix child node removal on style tag processing"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-29577"
    },
    {
        "data": {
            "function_name": "clean",
            "function_code": "private String clean(String svg) {\n\t\tsvg = svg.toLowerCase().replaceAll(\"\\\\s\", \"\");\n\t\tif (svg.contains(\"<script>\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg.contains(\"</script>\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg.contains(\"<foreignobject\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg.contains(\"</foreignobject>\"))\n\t\t\treturn EMPTY_SVG;\n\t\treturn svg;\n\t}",
            "commit_message": "wip"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-1231"
    },
    {
        "data": {
            "function_name": "saveFile",
            "function_code": "private boolean saveFile(int convertedAttempt, File artifact, MultipartFile multipartFile, boolean shouldUnzip) throws IOException {\n        try (InputStream inputStream = multipartFile.getInputStream()) {\n            return artifactsService.saveFile(artifact, inputStream, shouldUnzip, convertedAttempt);\n        }\n    }",
            "commit_message": "#000 - Validate stage counter during upload artifacts"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2021-43290"
    },
    {
        "data": {
            "function_name": "saveFile",
            "function_code": "private boolean saveFile(int convertedAttempt, File artifact, MultipartFile multipartFile, boolean shouldUnzip) throws IOException {\n        try (InputStream inputStream = multipartFile.getInputStream()) {\n            return artifactsService.saveFile(artifact, inputStream, shouldUnzip, convertedAttempt);\n        }\n    }",
            "commit_message": "#000 - Validate stage counter during upload artifacts"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2021-43289"
    },
    {
        "data": {
            "function_name": "saveFile",
            "function_code": "private boolean saveFile(int convertedAttempt, File artifact, MultipartFile multipartFile, boolean shouldUnzip) throws IOException {\n        try (InputStream inputStream = multipartFile.getInputStream()) {\n            return artifactsService.saveFile(artifact, inputStream, shouldUnzip, convertedAttempt);\n        }\n    }",
            "commit_message": "#000 - Validate stage counter during upload artifacts"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2021-43290"
    },
    {
        "data": {
            "function_name": "saveFile",
            "function_code": "private boolean saveFile(int convertedAttempt, File artifact, MultipartFile multipartFile, boolean shouldUnzip) throws IOException {\n        try (InputStream inputStream = multipartFile.getInputStream()) {\n            return artifactsService.saveFile(artifact, inputStream, shouldUnzip, convertedAttempt);\n        }\n    }",
            "commit_message": "#000 - Validate stage counter during upload artifacts"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2021-43289"
    },
    {
        "data": {
            "function_name": "scanPI",
            "function_code": "otected void scanPI() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanPI: \");\n            }\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1008\", null);\n            }\n\n            // scan processing instruction\n            String target = scanName(true);\n            if (target != null && !target.equalsIgnoreCase(\"xml\")) {\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '\\r' || c == '\\n') {\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    if (c == -1) {\n                        break;\n                    }\n                    if (c != ' ' && c != '\\t') {\n                    \tfCurrentEntity.rewind();\n                        break;\n                    }\n                }\n                fStringBuffer.clear();\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '?' || c == '/') {\n                        char c0 = (char)c;\n                        c = fCurrentEntity.read();\n                        if (c == '>') {\n                            break;\n                        }\n                        fStringBuffer.append(c0);\n                        fCurrentEntity.rewind();\n                        continue;\n                    }\n                    else if (c == '\\r' || c == '\\n') {\n                        fStringBuffer.append('\\n');\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    else if (c == -1) {\n                        break;\n                    }\n                    else {\n                        appendChar(fStringBuffer, c);\n                    }\n                }\n                XMLString data = fStringBuffer;\n                if (fDocumentHandler != null) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.processingInstruction(target, data, locationAugs());\n                }\n            }\n\n            // scan xml/text declaration\n            else {\n                int beginLineNumber = fBeginLineNumber;\n                int beginColumnNumber = fBeginColumnNumber;\n                int beginCharacterOffset = fBeginCharacterOffset;\n                fAttributes.removeAllAttributes();\n                int aindex = 0;\n                while (scanPseudoAttribute(fAttributes)) {\n                \t// if we haven't scanned a value, remove the entry as values have special signification\n                \tif (fAttributes.getValue(aindex).length() == 0) {\n                \t\tfAttributes.removeAttributeAt(aindex); \n                \t}\n                \telse {\n\t                    fAttributes.getName(aindex,fQName);\n\t                    fQName.rawname = fQName.rawname.toLowerCase();\n\t                    fAttributes.setName(aindex,fQName);\n\t                    aindex++;\n                \t}\n                }\n                if (fDocumentHandler != null) {\n                    String version = fAttributes.getValue(\"version\");\n                    String encoding = fAttributes.getValue(\"encoding\");\n                    String standalone = fAttributes.getValue(\"standalone\");\n\n                    // if the encoding is successfully changed, the stream will be processed again\n                    // with the right encoding an we will come here again but without need to change the encoding\n                    final boolean xmlDeclNow = fIgnoreSpecifiedCharset || !changeEncoding(encoding);\n                    if (xmlDeclNow) {\n\t                    fBeginLineNumber = beginLineNumber;\n\t                    fBeginColumnNumber = beginColumnNumber;\n\t                    fBeginCharacterOffset = beginCharacterOffset;\n\t                    fEndLineNumber = fCurrentEntity.getLineNumber();\n\t                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n\t                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n\t                    fDocumentHandler.xmlDecl(version, encoding, standalone,\n\t                                             locationAugs());\n                    }\n                }\n            }\n\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanPI: \");\n            }\n        } /",
            "commit_message": "fix: ensure ill-formed PIs are parsed correctly"
        },
        "CWE": "CWE-400",
        "CVE": "CVE-2022-24839"
    },
    {
        "data": {
            "function_name": "handleLoginResponse",
            "function_code": "protected Response handleLoginResponse(String samlResponse, SAMLDocumentHolder holder, ResponseType responseType, String relayState, String clientId) {\n\n            try {\n                AuthenticationSessionModel authSession;\n                if (clientId != null && ! clientId.trim().isEmpty()) {\n                    authSession = samlIdpInitiatedSSO(clientId);\n                } else {\n                    authSession = callback.getAndVerifyAuthenticationSession(relayState);\n                }\n                session.getContext().setAuthenticationSession(authSession);\n\n                KeyManager.ActiveRsaKey keys = session.keys().getActiveRsaKey(realm);\n                if (! isSuccessfulSamlResponse(responseType)) {\n                    String statusMessage = responseType.getStatus() == null ? Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR : responseType.getStatus().getStatusMessage();\n                    return callback.error(statusMessage);\n                }\n                if (responseType.getAssertions() == null || responseType.getAssertions().isEmpty()) {\n                    return callback.error(Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);\n                }\n\n                boolean assertionIsEncrypted = AssertionUtil.isAssertionEncrypted(responseType);\n\n                if (config.isWantAssertionsEncrypted() && !assertionIsEncrypted) {\n                    logger.error(\"The assertion is not encrypted, which is required.\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SAML_RESPONSE);\n                    return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                }\n\n                Element assertionElement;\n\n                if (assertionIsEncrypted) {\n                    // This methods writes the parsed and decrypted assertion back on the responseType parameter:\n                    assertionElement = AssertionUtil.decryptAssertion(holder, responseType, keys.getPrivateKey());\n                } else {\n                    /* We verify the assertion using original document to handle cases where the IdP\n                    includes whitespace and/or newlines inside tags. */\n                    assertionElement = DocumentUtil.getElement(holder.getSamlDocument(), new QName(JBossSAMLConstants.ASSERTION.get()));\n                }\n\n                boolean signed = AssertionUtil.isSignedElement(assertionElement);\n                final boolean assertionSignatureNotExistsWhenRequired = config.isWantAssertionsSigned() && !signed;\n                final boolean signatureNotValid = signed && config.isValidateSignature() && !AssertionUtil.isSignatureValid(assertionElement, getIDPKeyLocator());\n                final boolean hasNoSignatureWhenRequired = ! signed && config.isValidateSignature() && ! containsUnencryptedSignature(holder);\n\n                if (assertionSignatureNotExistsWhenRequired || signatureNotValid || hasNoSignatureWhenRequired) {\n                    logger.error(\"validation failed\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SIGNATURE);\n                    return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                }\n\n                AssertionType assertion = responseType.getAssertions().get(0).getAssertion();\n                NameIDType subjectNameID = getSubjectNameID(assertion);\n                String principal = getPrincipal(assertion);\n\n                if (principal == null) {\n                    logger.errorf(\"no principal in assertion; expected: %s\", expectedPrincipalType());\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SAML_RESPONSE);\n                    return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                }\n\n                //Map<String, String> notes = new HashMap<>();\n                BrokeredIdentityContext identity = new BrokeredIdentityContext(principal);\n                identity.getContextData().put(SAML_LOGIN_RESPONSE, responseType);\n                identity.getContextData().put(SAML_ASSERTION, assertion);\n                identity.setAuthenticationSession(authSession);\n\n                identity.setUsername(principal);\n\n                //SAML Spec 2.2.2 Format is optional\n                if (subjectNameID != null && subjectNameID.getFormat() != null && subjectNameID.getFormat().toString().equals(JBossSAMLURIConstants.NAMEID_FORMAT_EMAIL.get())) {\n                    identity.setEmail(subjectNameID.getValue());\n                }\n\n                if (config.isStoreToken()) {\n                    identity.setToken(samlResponse);\n                }\n\n                ConditionsValidator.Builder cvb = new ConditionsValidator.Builder(assertion.getID(), assertion.getConditions(), destinationValidator)\n                        .clockSkewInMillis(1000 * config.getAllowedClockSkew());\n                try {\n                    String issuerURL = getEntityId(session.getContext().getUri(), realm);\n                    cvb.addAllowedAudience(URI.create(issuerURL));\n                    // getDestination has been validated to match request URL already so it matches SAML endpoint\n                    if (responseType.getDestination() != null) {\n                        cvb.addAllowedAudience(URI.create(responseType.getDestination()));\n                    }\n                } catch (IllegalArgumentException ex) {\n                    // warning has been already emitted in DeploymentBuilder\n                }\n                if (! cvb.build().isValid()) {\n                    logger.error(\"Assertion expired.\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SAML_RESPONSE);\n                    return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.EXPIRED_CODE);\n                }\n\n                AuthnStatementType authn = null;\n                for (Object statement : assertion.getStatements()) {\n                    if (statement instanceof AuthnStatementType) {\n                        authn = (AuthnStatementType)statement;\n                        identity.getContextData().put(SAML_AUTHN_STATEMENT, authn);\n                        break;\n                    }\n                }\n                if (assertion.getAttributeStatements() != null ) {\n                    String email = getX500Attribute(assertion, X500SAMLProfileConstants.EMAIL);\n                    if (email != null)\n                        identity.setEmail(email);\n                }\n\n                String brokerUserId = config.getAlias() + \".\" + principal;\n                identity.setBrokerUserId(brokerUserId);\n                identity.setIdpConfig(config);\n                identity.setIdp(provider);\n                if (authn != null && authn.getSessionIndex() != null) {\n                    identity.setBrokerSessionId(identity.getBrokerUserId() + \".\" + authn.getSessionIndex());\n                 }\n\n\n                return callback.authenticated(identity);\n            } catch (WebApplicationException e) {\n                return e.getResponse();\n            } catch (Exception e) {\n                throw new IdentityBrokerException(\"Could not process response from SAML identity provider.\", e);\n            }\n        }",
            "commit_message": "KEYCLOAK-17495 Do not include principal in the reference to broker sessionId"
        },
        "CWE": "CWE-613",
        "CVE": "CVE-2021-3461"
    },
    {
        "data": {
            "function_name": "handleLoginResponse",
            "function_code": "protected Response handleLoginResponse(String samlResponse, SAMLDocumentHolder holder, ResponseType responseType, String relayState, String clientId) {\n\n            try {\n                AuthenticationSessionModel authSession;\n                if (clientId != null && ! clientId.trim().isEmpty()) {\n                    authSession = samlIdpInitiatedSSO(clientId);\n                } else {\n                    authSession = callback.getAndVerifyAuthenticationSession(relayState);\n                }\n                session.getContext().setAuthenticationSession(authSession);\n\n                KeyManager.ActiveRsaKey keys = session.keys().getActiveRsaKey(realm);\n                if (! isSuccessfulSamlResponse(responseType)) {\n                    String statusMessage = responseType.getStatus() == null ? Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR : responseType.getStatus().getStatusMessage();\n                    return callback.error(statusMessage);\n                }\n                if (responseType.getAssertions() == null || responseType.getAssertions().isEmpty()) {\n                    return callback.error(Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);\n                }\n\n                boolean assertionIsEncrypted = AssertionUtil.isAssertionEncrypted(responseType);\n\n                if (config.isWantAssertionsEncrypted() && !assertionIsEncrypted) {\n                    logger.error(\"The assertion is not encrypted, which is required.\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SAML_RESPONSE);\n                    return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                }\n\n                Element assertionElement;\n\n                if (assertionIsEncrypted) {\n                    // This methods writes the parsed and decrypted assertion back on the responseType parameter:\n                    assertionElement = AssertionUtil.decryptAssertion(holder, responseType, keys.getPrivateKey());\n                } else {\n                    /* We verify the assertion using original document to handle cases where the IdP\n                    includes whitespace and/or newlines inside tags. */\n                    assertionElement = DocumentUtil.getElement(holder.getSamlDocument(), new QName(JBossSAMLConstants.ASSERTION.get()));\n                }\n\n                boolean signed = AssertionUtil.isSignedElement(assertionElement);\n                final boolean assertionSignatureNotExistsWhenRequired = config.isWantAssertionsSigned() && !signed;\n                final boolean signatureNotValid = signed && config.isValidateSignature() && !AssertionUtil.isSignatureValid(assertionElement, getIDPKeyLocator());\n                final boolean hasNoSignatureWhenRequired = ! signed && config.isValidateSignature() && ! containsUnencryptedSignature(holder);\n\n                if (assertionSignatureNotExistsWhenRequired || signatureNotValid || hasNoSignatureWhenRequired) {\n                    logger.error(\"validation failed\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SIGNATURE);\n                    return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                }\n\n                AssertionType assertion = responseType.getAssertions().get(0).getAssertion();\n                NameIDType subjectNameID = getSubjectNameID(assertion);\n                String principal = getPrincipal(assertion);\n\n                if (principal == null) {\n                    logger.errorf(\"no principal in assertion; expected: %s\", expectedPrincipalType());\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SAML_RESPONSE);\n                    return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                }\n\n                //Map<String, String> notes = new HashMap<>();\n                BrokeredIdentityContext identity = new BrokeredIdentityContext(principal);\n                identity.getContextData().put(SAML_LOGIN_RESPONSE, responseType);\n                identity.getContextData().put(SAML_ASSERTION, assertion);\n                identity.setAuthenticationSession(authSession);\n\n                identity.setUsername(principal);\n\n                //SAML Spec 2.2.2 Format is optional\n                if (subjectNameID != null && subjectNameID.getFormat() != null && subjectNameID.getFormat().toString().equals(JBossSAMLURIConstants.NAMEID_FORMAT_EMAIL.get())) {\n                    identity.setEmail(subjectNameID.getValue());\n                }\n\n                if (config.isStoreToken()) {\n                    identity.setToken(samlResponse);\n                }\n\n                ConditionsValidator.Builder cvb = new ConditionsValidator.Builder(assertion.getID(), assertion.getConditions(), destinationValidator)\n                        .clockSkewInMillis(1000 * config.getAllowedClockSkew());\n                try {\n                    String issuerURL = getEntityId(session.getContext().getUri(), realm);\n                    cvb.addAllowedAudience(URI.create(issuerURL));\n                    // getDestination has been validated to match request URL already so it matches SAML endpoint\n                    if (responseType.getDestination() != null) {\n                        cvb.addAllowedAudience(URI.create(responseType.getDestination()));\n                    }\n                } catch (IllegalArgumentException ex) {\n                    // warning has been already emitted in DeploymentBuilder\n                }\n                if (! cvb.build().isValid()) {\n                    logger.error(\"Assertion expired.\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SAML_RESPONSE);\n                    return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.EXPIRED_CODE);\n                }\n\n                AuthnStatementType authn = null;\n                for (Object statement : assertion.getStatements()) {\n                    if (statement instanceof AuthnStatementType) {\n                        authn = (AuthnStatementType)statement;\n                        identity.getContextData().put(SAML_AUTHN_STATEMENT, authn);\n                        break;\n                    }\n                }\n                if (assertion.getAttributeStatements() != null ) {\n                    String email = getX500Attribute(assertion, X500SAMLProfileConstants.EMAIL);\n                    if (email != null)\n                        identity.setEmail(email);\n                }\n\n                String brokerUserId = config.getAlias() + \".\" + principal;\n                identity.setBrokerUserId(brokerUserId);\n                identity.setIdpConfig(config);\n                identity.setIdp(provider);\n                if (authn != null && authn.getSessionIndex() != null) {\n                    identity.setBrokerSessionId(identity.getBrokerUserId() + \".\" + authn.getSessionIndex());\n                 }\n\n\n                return callback.authenticated(identity);\n            } catch (WebApplicationException e) {\n                return e.getResponse();\n            } catch (Exception e) {\n                throw new IdentityBrokerException(\"Could not process response from SAML identity provider.\", e);\n            }\n        }",
            "commit_message": "KEYCLOAK-17495 Do not include principal in the reference to broker sessionId"
        },
        "CWE": "CWE-613",
        "CVE": "CVE-2021-3461"
    },
    {
        "data": {
            "function_name": "addContentToRepo",
            "function_code": "protected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    CloseableHttpClient externalHttpClient = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        List<String> clusterUrls = new LinkedList<>();\n        try {\n          // Note that we are not checking ports here.\n          clusterUrls = organizationDirectoryService.getOrganization(uri.toURL()).getServers()\n                          .keySet()\n                          .stream()\n                          .collect(Collectors.toUnmodifiableList());\n        } catch (NotFoundException e) {\n          logger.warn(\"Unable to determine cluster members, will not be able to authenticate any downloads from them\", e);\n        }\n\n        if (uri.toString().matches(downloadSource)) {\n          //NB: We're creating a new client here with *different* auth than the system auth creds\n          externalHttpClient = getAuthedHttpClient();\n          response = externalHttpClient.execute(get);\n        } else if (clusterUrls.contains(uri.getScheme() + \"://\" + uri.getHost())) {\n          // Only using the system-level httpclient and digest credentials against our own servers\n          response = httpClient.execute(get);\n        } else {\n          //NB: No auth here at all\n          externalHttpClient = getNoAuthHttpClient();\n          response = externalHttpClient.execute(get);\n        }\n\n        if (null == response) {\n          // If you get here then chances are you're using a mock httpClient which does not have appropriate\n          // mocking to respond to the URL you are feeding it.  Try adding that URL to the mock and see if that works.\n          throw new IOException(\"Null response object from the http client, refer to code for explanation\");\n        }\n\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n        //If it does not start with file, or we're in test mode (ie, to allow arbitrary file:// access)\n      } else if (!uri.toString().startsWith(\"file\") || testMode) {\n        in = uri.toURL().openStream();\n      } else {\n        throw new IOException(\"Refusing to fetch files from the local filesystem\");\n      }\n      String fileName = FilenameUtils.getName(uri.getPath());\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        fileName = getContentDispositionFileName(response);\n\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        throw new IOException(\"No filename extension found: \" + fileName);\n      return addContentToRepo(mp, elementId, fileName, in);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (externalHttpClient != null) {\n        externalHttpClient.close();\n      }\n      httpClient.close(response);\n    }\n  }",
            "commit_message": "Merge pull request from GHSA-qm6v-cg9v-53j3\n\nThis patch fixes the issue that users can pass URLs from other tenants\nto the ingest service which will check only against the other\norganization but not against the one currently active. This allows users\nto easily ingest media from other tenants."
        },
        "CWE": "CWE-287",
        "CVE": "CVE-2022-29237"
    },
    {
        "data": {
            "function_name": "checkConnection",
            "function_code": "public void checkConnection(UrlArgument repositoryURL) {\n        execute(createCommandLine(\"hg\").withArgs(\"id\", \"--id\").withArg(repositoryURL).withNonArgSecrets(secrets).withEncoding(\"utf-8\"), new NamedProcessTag(repositoryURL.forDisplay()));\n    }",
            "commit_message": "Improve escaping of arguments when constructing Hg command calls"
        },
        "CWE": "CWE-77",
        "CVE": "CVE-2022-29184"
    },
    {
        "data": {
            "function_name": "compileMustache",
            "function_code": "public static String compileMustache(Map<String, Object> context, String template) {\n\t\tif (context == null || StringUtils.isBlank(template)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tWriter writer = new StringWriter();\n\t\ttry {\n\t\t\tMustache.compiler().escapeHTML(false).emptyStringIsFalse(true).compile(template).execute(context, writer);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\twriter.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tlogger.error(null, e);\n\t\t\t}\n\t\t}\n\t\treturn writer.toString();\n\t}",
            "commit_message": "added option to escape HTML when compiling Mustache templates"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-1782"
    },
    {
        "data": {
            "function_name": "getChildTextValue",
            "function_code": "private Object getChildTextValue(final Node node) {\n        for (Node child : asIterable(node.getChildNodes())) {\n            if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {\n                // Support for <rdf:Alt><rdf:li> -> return a Map<String, Object> keyed on xml:lang\n                Map<String, Object> alternatives = new LinkedHashMap<String, Object>();\n                for (Node alternative : asIterable(child.getChildNodes())) {\n                    if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {\n                        NamedNodeMap attributes = alternative.getAttributes();\n                        Node key = attributes.getNamedItem(\"xml:lang\");\n                        alternatives.put(key == null ? null : key.getTextContent(), getChildTextValue(alternative));\n                    }\n                }\n\n                return alternatives;\n            }\n            else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {\n                // Support for <rdf:Seq><rdf:li> -> return array\n                // Support for <rdf:Bag><rdf:li> -> return array/unordered collection (how can a serialized collection not have order?)\n                List<Object> seq = new ArrayList<Object>();\n\n                for (Node sequence : asIterable(child.getChildNodes())) {\n                    if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {\n                        Object value = getChildTextValue(sequence);\n                        seq.add(value);\n                    }\n                }\n\n                // TODO: Strictly a bag should not be a list, but there's no Bag type (or similar) in Java.\n                // Consider something like Google collections Multiset or Apache commons Bag (the former seems more well-defined)\n                // Note: Collection does not have defined equals() semantics, and so using\n                // Collections.unmodifiableCollection() doesn't work for comparing values (uses Object.equals())\n                return Collections.unmodifiableList(seq);\n            }\n        }\n\n        // Need to support rdf:parseType=\"Resource\" here as well...\n        if (isResourceType(node)) {\n            return parseAsResource(node);\n        }\n\n        Node child = node.getFirstChild();\n        String strVal = child != null ? child.getNodeValue() : null;\n        return strVal != null ? strVal.trim() : \"\";\n    }",
            "commit_message": "Avoid fetching external resources in XMPReader."
        },
        "CWE": "CWE-611",
        "CVE": "CVE-2021-23792"
    },
    {
        "data": {
            "function_name": "createTempFile",
            "function_code": "@SuppressJava6Requirement(reason = \"Guarded by version check\")\n    public static File createTempFile(String prefix, String suffix, File directory) throws IOException {\n        if (javaVersion() >= 7) {\n            if (directory == null) {\n                return Files.createTempFile(prefix, suffix).toFile();\n            }\n            return Files.createTempFile(directory.toPath(), prefix, suffix).toFile();\n        }\n        if (directory == null) {\n            return File.createTempFile(prefix, suffix);\n        }\n        File file = File.createTempFile(prefix, suffix, directory);\n        // Try to adjust the perms, if this fails there is not much else we can do...\n        file.setReadable(false, false);\n        file.setReadable(true, true);\n        return file;\n    }",
            "commit_message": "Merge pull request from GHSA-269q-hmxg-m83q\n\n* Correctly modify permission for temporary files when using Java 6 in all cases\n\nMotivation:\n\n[GHSA-5mcr-gq6c-3hq2](https://github.com/netty/netty/security/advisories/GHSA-5mcr-gq6c-3hq2) did not correctly fix all cases for temprory files when running on java 6.\n\nModifications:\n\n- Add correctly adjust perms in all cases\n- Add logging if adjusting of permissions fails\n\nResult:\n\nFixes https://github.com/netty/netty/security/advisories/GHSA-269q-hmxg-m83q\n\n* Throw on failure"
        },
        "CWE": "CWE-668",
        "CVE": "CVE-2022-24823"
    },
    {
        "data": {
            "function_name": "addAccept",
            "function_code": "64(name);\n        if (Arrays.binarySearch(this.acceptHashCodes, hash) >= 0) {\n            return;\n        }\n\n        long[] hashCodes = new long[this.acceptHashCodes.length + 1];\n        hashCodes[hashCodes.length - 1] = hash;\n        System.arraycopy(this.acceptHashCodes, 0, hashCodes, 0, this.acceptHashCodes.length);\n        Arrays.sort(hashCodes);\n        this.acceptHashCodes = hashCodes;\n    }\n\n    public Class<?> checkAutoType(Class type) {\n        if (get(type) != null) {\n            return type;\n        }\n\n        return checkAutoType(type.g",
            "commit_message": "bug fix for autotype"
        },
        "CWE": "CWE-502",
        "CVE": "CVE-2022-25845"
    },
    {
        "data": {
            "function_name": "saveblog",
            "function_code": "\tString tags = getPara(\"tags\");\n\t\t// \u5220\u9664\u4fb5\u5165\u811a\u672c\n\t\tcontent = JFlyFoxUtils.delScriptTag(content);\n\t\ttitle = HtmlUtils.delHTMLTag(title);\n\t\ttags = HtmlUtils.delHTMLTag(tags);\n\n\t\t// \u8fd9\u91cc\u6ca1\u6709\u5fc5\u8981\u63d0\u793a\u592a\u7cbe\u51c6~\u56e0\u4e3a\u524d\u53f0\u6709\u9a8c\u8bc1~\u7ed5\u8fc7\u7684\u90fd\u4e0d\u662f\u597d\u4eba\u54e6\n\t\tif (content == null || HtmlUtils.delHTMLTag(content).length() > 2000 //\n\t\t\t\t|| title == null || title.length() > 200 //\n\t\t\t\t|| tags == null || tags.length() > 200 //\n\t\t) {\n\t\t\tjson.put(\"msg\", \"\u535a\u5ba2\u4fe1\u606f\u9519\u8bef\uff0c\u8bf7\u8f93\u5165\u6b63\u786e\u6570\u636e\uff01\");\n\t\t\trenderJson(json.toJSONString());\n\t\t\treturn;\n\t\t}\n\n\t\tmodel.setUpdateTime(getNow());\n\t\tif (pid != null && pid > 0) { // \u66f4\u65b0\n\t\t\t// \u7ba1\u7406\u5458\u6216\u8005\u81ea\u5df1\u624d\u80fd\u4fee\u6539\n\t\t\tif (!isAdmin(user) //\n\t\t\t\t\t&& model.getCreateId().intValue() != user.getUserid().intValue()) {\n\t\t\t\tjson.put(\"msg\", \"\u4f60\u6ca1\u6709\u6743\u9650\u4fee\u6539\u535a\u6587\uff01\");\n\t\t\t\trenderJson(json.toJSONString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmodel.update();\n\t\t} else { // \u65b0\u589e\n\t\t\tmodel.remove(\"id\");\n\t\t\tif (model.getFolderId() == null || model.getFolderId() <= 0) {\n\t\t\t\tmodel.setFolderId(JFlyFoxUtils.MENU_BLOG); // \u535a\u6587\u76ee\u5f55\n\t\t\t}\n\t\t\tmodel.setStatus(\"1\"); // \u663e\u793a\n\t\t\tmodel.setType(11);\n\t\t\tmodel.setIsComment(1); // \u80fd\u8bc4\u8bba\n\t\t\tmodel.setIsRecommend(2);// \u4e0d\u63a8\u8350\n\t\t\tmodel.setSort(20); // \u6392\u5e8f\n\t\t\tmodel.set(\"approve_status\", ArticleConstant.APPROVE_STATUS_PASS); // \u9700\u8981\u5ba1\u6838\u6539\u4e3aupdate\n\t\t\tmodel.setPublishTime(DateUtils.getNow(\"yyyy-MM-dd\")); // \u53d1\u5e03\u65f6\u95f4\n\t\t\tmodel.setPublishUser(user.getUserName()); // \u53d1\u5e03\u4eba\n\t\t\tmodel.setCreateId(getSessionUser().getUserid());\n\t\t\tmodel.setCreateTime(getNow());\n\t\t\tmodel.save();\n\t\t}\n\n\t\t// \u4fdd\u5b58tags\n\t\tDb.update(\" delete from tb_tags where article_id = ?\", model.getInt(\"id\"));\n\t\tif (StrUtils.isNotEmpty(tags)) {\n\t\t\tString[] tagsArr = tags.split(\",\");\n\t\t\tfor (int i = 0; i < tagsArr.length; i++) {\n\t\t\t\tString tagname = tagsArr[i];\n\t\t\t\t// \u6700\u591a5\u4e2a\n\t\t\t\tif (i >= 5) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (StrUtils.isEmpty(tagname)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tTbTags tbTags = new TbTags();\n\t\t\t\ttbTags.put(\"tagname\", tagname);\n\t\t\t\ttbTags.put(\"article_id\", model.getInt(\"id\"));\n\t\t\t\ttbTags.put(\"create_id\", getSessionUser().getUserid());\n\t\t\t\ttbTags.put(\"create_time\", getNow());\n\t\t\t\ttbTags.save();\n\n\t\t\t}\n\t\t}\n\n\t\tjson.put(\"status\", 1);// \u6210\u529f\n\t\trenderJson(json.toJSONString());\n\t}\n\n\t/**\n\t * \u8df3\u8f6c\u5230\u7f16\u8f91\u535a\u6587\u9875\u9762\n\t * \n\t * 2015\u5e746\u670817\u65e5 \u4e0b\u53489:53:04 flyfox 369191470@qq.com\n\t */\n\t@Before(FrontInterceptor.class)\n\tpublic void delblog() {\n\t\tSysUser user = (SysUser) getSessionUser();\n\t\tInteger id = getParaToInt();\n\t\tif (user == null || id == null) {\n\t\t\tredirect(CommonController.firstPage);\n\t\t\treturn;\n\t\t}\n\n\t\tTbArticle model = TbArticle.dao.findById(getParaToInt());\n\t\tsetAttr(\"model\", model);\n\t\t// \u4e0d\u662f\u81ea\u5df1\u7684\u6587\u7ae0\u4e5f\u60f3\u4fee\u6539,\u603b\u6709\u4e0d\u6000\u597d\u610f\u7684\u4eba\u54e6\n\t\tif (model.getCreateId() != user.getUserid()) {\n\t\t\tSystem.err.println(\"####userid(\" + user.getUserid() + \")\u975e\u6cd5\u7f16\u8f91\u5185\u5bb9\");\n\t\t\tredirect(CommonController.firstPage);\n\t\t\treturn;\n\t\t}\n\n\t\t// \u5220\u9664\u8bc4\u8bba~\n\t\tnew CommentService().deleteComment(id);\n\t\t// \u5220\u9664\u6587\u7ae0\n\t\tTbArticle.d",
            "commit_message": "\u66f4\u65b0xss"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-29648"
    },
    {
        "data": {
            "function_name": "handle",
            "function_code": "@Override\n    public void handle(final RoutingContext ctx) {\n\n        if (currentManagedContext.isActive()) {\n            handleWithIdentity(ctx);\n        } else {\n\n            currentManagedContext.activate();\n            handleWithIdentity(ctx);\n\n            ctx.response().bodyEndHandler((e) -> {\n                currentManagedContext.terminate();\n            });\n        }\n    }",
            "commit_message": "Merge pull request #26777 from phillip-kruger/jwt-issue\n\nGraphQL: Make sure the context terminate"
        },
        "CWE": "CWE-444",
        "CVE": "CVE-2022-2466"
    },
    {
        "data": {
            "function_name": "handleEvent",
            "function_code": "public void handleEvent(final StreamSourceChannel channel) {\n        if(connection.getOriginalSinkConduit().isWriteShutdown() || connection.getOriginalSourceConduit().isReadShutdown()) {\n            safeClose(connection);\n            channel.suspendReads();\n            return;\n        }\n\n        PooledByteBuffer existing = connection.getExtraBytes();\n\n        final PooledByteBuffer pooled = existing == null ? connection.getByteBufferPool().allocate() : existing;\n        final ByteBuffer buffer = pooled.getBuffer();\n        boolean free = true;\n        boolean bytesRead = false;\n        try {\n            int res;\n            do {\n                if (existing == null) {\n                    buffer.clear();\n                    res = channel.read(buffer);\n                } else {\n                    res = buffer.remaining();\n                }\n                if (res == 0) {\n\n                    if(bytesRead && parseTimeoutUpdater != null) {\n                        parseTimeoutUpdater.failedParse();\n                    }\n                    if (!channel.isReadResumed()) {\n                        channel.getReadSetter().set(this);\n                        channel.resumeReads();\n                    }\n                    return;\n                }\n                if (res == -1) {\n                    channel.shutdownReads();\n                    final StreamSinkChannel responseChannel = connection.getChannel().getSinkChannel();\n                    responseChannel.shutdownWrites();\n                    safeClose(connection);\n                    return;\n                }\n                bytesRead = true;\n                //TODO: we need to handle parse errors\n                if (existing != null) {\n                    existing = null;\n                    connection.setExtraBytes(null);\n                } else {\n                    buffer.flip();\n                }\n                int begin = buffer.remaining();\n                if(httpServerExchange == null) {\n                    httpServerExchange = new HttpServerExchange(connection, maxEntitySize);\n                }\n                parser.parse(buffer, state, httpServerExchange);\n\n                read += begin - buffer.remaining();\n                if (buffer.hasRemaining()) {\n                    free = false;\n                    connection.setExtraBytes(pooled);\n                }\n                if (read > maxRequestSize) {\n                    UndertowLogger.REQUEST_LOGGER.requestHeaderWasTooLarge(connection.getPeerAddress(), maxRequestSize);\n                    safeClose(connection);\n                    return;\n                }\n            } while (!state.isComplete());\n\n            if(parseTimeoutUpdater != null) {\n                parseTimeoutUpdater.requestStarted();\n            }\n            if (state.prefix != AjpRequestParser.FORWARD_REQUEST) {\n                if (state.prefix == AjpRequestParser.CPING) {\n                    UndertowLogger.REQUEST_LOGGER.debug(\"Received CPING, sending CPONG\");\n                    handleCPing();\n                } else if (state.prefix == AjpRequestParser.CPONG) {\n                    UndertowLogger.REQUEST_LOGGER.debug(\"Received CPONG, starting next request\");\n                    state = new AjpRequestParseState();\n                    channel.getReadSetter().set(this);\n                    channel.resumeReads();\n                } else {\n                    UndertowLogger.REQUEST_LOGGER.ignoringAjpRequestWithPrefixCode(state.prefix);\n                    safeClose(connection);\n                }\n                return;\n            }\n\n            // we remove ourselves as the read listener from the channel;\n            // if the http handler doesn't set any then reads will suspend, which is the right thing to do\n            channel.getReadSetter().set(null);\n            channel.suspendReads();\n\n            final HttpServerExchange httpServerExchange = this.httpServerExchange;\n            final AjpServerResponseConduit responseConduit = new AjpServerResponseConduit(connection.getChannel().getSinkChannel().getConduit(), connection.getByteBufferPool(), httpServerExchange, new ConduitListener<AjpServerResponseConduit>() {\n                @Override\n                public void handleEvent(AjpServerResponseConduit channel) {\n                    Connectors.terminateResponse(httpServerExchange);\n                }\n            }, httpServerExchange.getRequestMethod().equals(Methods.HEAD));\n            connection.getChannel().getSinkChannel().setConduit(responseConduit);\n            connection.getChannel().getSourceChannel().setConduit(createSourceConduit(connection.getChannel().getSourceChannel().getConduit(), responseConduit, httpServerExchange));\n            //we need to set the write ready handler. This allows the response conduit to wrap it\n            responseConduit.setWriteReadyHandler(writeReadyHandler);\n\n            connection.setSSLSessionInfo(state.createSslSessionInfo());\n            httpServerExchange.setSourceAddress(state.createPeerAddress());\n            httpServerExchange.setDestinationAddress(state.createDestinationAddress());\n            if(scheme != null) {\n                httpServerExchange.setRequestScheme(scheme);\n            }\n            if(state.attributes != null) {\n                httpServerExchange.putAttachment(HttpServerExchange.REQUEST_ATTRIBUTES, state.attributes);\n            }\n            AjpRequestParseState oldState = state;\n            state = null;\n            this.httpServerExchange = null;\n            httpServerExchange.setPersistent(true);\n\n            if(recordRequestStartTime) {\n                Connectors.setRequestStartTime(httpServerExchange);\n            }\n            connection.setCurrentExchange(httpServerExchange);\n            if(connectorStatistics != null) {\n                connectorStatistics.setup(httpServerExchange);\n            }\n            if(!Connectors.areRequestHeadersValid(httpServerExchange.getRequestHeaders())) {\n                oldState.badRequest = true;\n                UndertowLogger.REQUEST_IO_LOGGER.debugf(\"Invalid AJP request from %s, request contained invalid headers\", connection.getPeerAddress());\n            }\n\n            if(oldState.badRequest) {\n                httpServerExchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                httpServerExchange.endExchange();\n                handleBadRequest();\n                safeClose(connection);\n            } else {\n                Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);\n            }\n        } catch (BadRequestException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.failedToParseRequest(e);\n            handleBadRequest();\n            safeClose(connection);\n        } catch (IOException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n            handleInternalServerError();\n            safeClose(connection);\n        } catch (Throwable t) {\n            UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(t);\n            handleInternalServerError();\n            safeClose(connection);\n        } finally {\n            if (free) pooled.close();\n        }\n    }",
            "commit_message": "[UNDERTOW-2060] fix double AJP response"
        },
        "CWE": "CWE-252",
        "CVE": "CVE-2022-1319"
    },
    {
        "data": {
            "function_name": "setCloseListener",
            "function_code": "public void setCloseListener(final ChannelListener<? super StreamConnection> listener) {\n        ChannelListener<? super StreamConnection> currentListener;\n        ChannelListener<? super StreamConnection> newListener;\n        do {\n            newListener = listener;\n            currentListener = closeListener.get();\n            if (currentListener != null) {\n                // channel is closed, just invoke the new listener and do not update closeListener\n                if (currentListener == INVOKED_CLOSE_LISTENER_FLAG) {\n                    ChannelListeners.invokeChannelListener(this, listener);\n                    return;\n                } else {\n                    newListener = mergeListeners(currentListener, listener);\n                }\n            }\n        } while (!closeListener.compareAndSet(currentListener, newListener));\n    }",
            "commit_message": "Merge pull request #291 from OrangeDog/patch-1"
        },
        "CWE": "CWE-770",
        "CVE": "CVE-2022-0084"
    },
    {
        "data": {
            "function_name": "getId",
            "function_code": "@Override\n    public String getId() {\n        return PROVIDER_ID;\n    }",
            "commit_message": "Prevent security flaw using passwordless authentication\n\nIf you register without an password or delete your last token your account can be hijacked. This is can be done by simply trying to login in that moment where the account is without a token. You get the \"normal\" registration dialog and can capture the complete account."
        },
        "CWE": "CWE-287",
        "CVE": "CVE-2021-3632"
    },
    {
        "data": {
            "function_name": "authenticate",
            "function_code": "@Override\n    public void authenticate(AuthenticationFlowContext context) {\n\n        X509Certificate[] certs = getCertificateChain(context);\n        if (certs == null || certs.length == 0) {\n            logger.debug(\"[ValidateX509CertificateUsername:authenticate] x509 client certificate is not available for mutual SSL.\");\n            context.getEvent().error(Errors.USER_NOT_FOUND);\n            Response challengeResponse = errorResponse(Response.Status.UNAUTHORIZED.getStatusCode(), \"invalid_request\", \"X509 client certificate is missing.\");\n            context.failure(AuthenticationFlowError.INVALID_USER, challengeResponse);\n            return;\n        }\n\n        saveX509CertificateAuditDataToAuthSession(context, certs[0]);\n        recordX509CertificateAuditDataViaContextEvent(context);\n\n        X509AuthenticatorConfigModel config = null;\n        if (context.getAuthenticatorConfig() != null && context.getAuthenticatorConfig().getConfig() != null) {\n            config = new X509AuthenticatorConfigModel(context.getAuthenticatorConfig());\n        }\n        if (config == null) {\n            logger.warn(\"[ValidateX509CertificateUsername:authenticate] x509 Client Certificate Authentication configuration is not available.\");\n            context.getEvent().error(Errors.USER_NOT_FOUND);\n            Response challengeResponse = errorResponse(Response.Status.UNAUTHORIZED.getStatusCode(), \"invalid_request\", \"Configuration is missing.\");\n            context.failure(AuthenticationFlowError.INVALID_USER, challengeResponse);\n            return;\n        }\n        // Validate X509 client certificate\n        try {\n            CertificateValidator.CertificateValidatorBuilder builder = certificateValidationParameters(context.getSession(), config);\n            CertificateValidator validator = builder.build(certs);\n            validator.checkRevocationStatus()\n                    .validateKeyUsage()\n                    .validateExtendedKeyUsage();\n        } catch(Exception e) {\n            logger.error(e.getMessage(), e);\n            // TODO use specific locale to load error messages\n            Response challengeResponse = errorResponse(Response.Status.UNAUTHORIZED.getStatusCode(), \"invalid_request\", e.getMessage());\n            context.failure(AuthenticationFlowError.INVALID_USER, challengeResponse);\n            return;\n        }\n\n        Object userIdentity = getUserIdentityExtractor(config).extractUserIdentity(certs);\n        if (userIdentity == null) {\n            context.getEvent().error(Errors.INVALID_USER_CREDENTIALS);\n            logger.errorf(\"[ValidateX509CertificateUsername:authenticate] Unable to extract user identity from certificate.\");\n            // TODO use specific locale to load error messages\n            String errorMessage = \"Unable to extract user identity from specified certificate\";\n            Response challengeResponse = errorResponse(Response.Status.UNAUTHORIZED.getStatusCode(), \"invalid_request\", errorMessage);\n            context.failure(AuthenticationFlowError.INVALID_USER, challengeResponse);\n            return;\n        }\n        UserModel user;\n        try {\n            context.getEvent().detail(Details.USERNAME, userIdentity.toString());\n            context.getAuthenticationSession().setAuthNote(AbstractUsernameFormAuthenticator.ATTEMPTED_USERNAME, userIdentity.toString());\n            user = getUserIdentityToModelMapper(config).find(context, userIdentity);\n        }\n        catch(ModelDuplicateException e) {\n            logger.modelDuplicateException(e);\n            String errorMessage = String.format(\"X509 certificate authentication's failed. Reason: \\\"%s\\\"\", e.getMessage());\n            Response challengeResponse = errorResponse(Response.Status.UNAUTHORIZED.getStatusCode(), \"invalid_request\", errorMessage);\n            context.failure(AuthenticationFlowError.INVALID_USER, challengeResponse);\n            return;\n        }\n        catch(Exception e) {\n            logger.error(e.getMessage(), e);\n            String errorMessage = String.format(\"X509 certificate authentication's failed. Reason: \\\"%s\\\"\", e.getMessage());\n            Response challengeResponse = errorResponse(Response.Status.UNAUTHORIZED.getStatusCode(), \"invalid_request\", errorMessage);\n            context.failure(AuthenticationFlowError.INVALID_USER, challengeResponse);\n            return;\n        }\n        if (user == null) {\n            context.getEvent().error(Errors.INVALID_USER_CREDENTIALS);\n            Response challengeResponse = errorResponse(Response.Status.UNAUTHORIZED.getStatusCode(), \"invalid_grant\", \"Invalid user credentials\");\n            context.failure(AuthenticationFlowError.INVALID_USER, challengeResponse);\n            return;\n        }\n\n        String bruteForceError = getDisabledByBruteForceEventError(context.getProtector(), context.getSession(), context.getRealm(), user);\n        if (bruteForceError != null) {\n            context.getEvent().user(user);\n            context.getEvent().error(bruteForceError);\n            Response challengeResponse = errorResponse(Response.Status.BAD_REQUEST.getStatusCode(), \"invalid_grant\", \"Invalid user credentials\");\n            context.failure(AuthenticationFlowError.INVALID_USER, challengeResponse);\n            return;\n        }\n\n        if (!user.isEnabled()) {\n            context.getEvent().user(user);\n            context.getEvent().error(Errors.USER_DISABLED);\n            Response challengeResponse = errorResponse(Response.Status.BAD_REQUEST.getStatusCode(), \"invalid_grant\", \"Account disabled\");\n            context.failure(AuthenticationFlowError.INVALID_USER, challengeResponse);\n            return;\n        }\n        context.setUser(user);\n        context.success();\n    }",
            "commit_message": "KEYCLOAK-16450 X509 Direct Grant Auth does not verify certificate timestamp validity"
        },
        "CWE": "CWE-295",
        "CVE": "CVE-2020-35509"
    },
    {
        "data": {
            "function_name": "run",
            "function_code": "@Override\n            public void run() {\n                try {\n                    if (singleBuffer.remaining() > 1) {\n                        final CloseReason.CloseCode code = CloseReason.CloseCodes.getCloseCode(singleBuffer.getShort());\n                        final String reasonPhrase = singleBuffer.remaining() > 1 ? new UTF8Output(singleBuffer).extract() : null;\n                        session.closeInternal(new CloseReason(code, reasonPhrase));\n                    } else {\n                        session.closeInternal(new CloseReason(CloseReason.CloseCodes.NO_STATUS_CODE, null));\n                    }\n                } catch (IOException e) {\n                    invokeOnError(e);\n                } finally {\n                    pooled.close();\n                }\n            }",
            "commit_message": "[UNDERTOW-1935] - buffer leak on incoming websocket PONG message"
        },
        "CWE": "CWE-400",
        "CVE": "CVE-2021-3690"
    },
    {
        "data": {
            "function_name": "loadFile",
            "function_code": "private ByteBuffer loadFile(final File file) {\n        try {\n            return ByteBuffer.wrap(Files.readAllBytes(file.toPath()));\n        }\n        catch(IOException ex) {\n            return null;\n        }\n    }",
            "commit_message": "vuln-fix: Partial Path Traversal Vulnerability\n\nThis fixes a partial path traversal vulnerability.\n\nReplaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nTo demonstrate this vulnerability, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: Medium\nCVSSS: 6.1\nDetection: CodeQL & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.PartialPathTraversalVulnerability)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/13\n\nCo-authored-by: Moderne <team@moderne.io>"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-36007"
    },
    {
        "data": {
            "function_name": "refreshRow",
            "function_code": "@Override\n  public void refreshRow() throws SQLException {\n    checkUpdateable();\n    if (onInsertRow) {\n      throw new PSQLException(GT.tr(\"Can''t refresh the insert row.\"),\n          PSQLState.INVALID_CURSOR_STATE);\n    }\n\n    if (isBeforeFirst() || isAfterLast() || castNonNull(rows, \"rows\").isEmpty()) {\n      return;\n    }\n\n    StringBuilder selectSQL = new StringBuilder(\"select \");\n\n    ResultSetMetaData rsmd = getMetaData();\n    PGResultSetMetaData pgmd = (PGResultSetMetaData) rsmd;\n    for (int i = 1; i <= rsmd.getColumnCount(); i++) {\n      if (i > 1) {\n        selectSQL.append(\", \");\n      }\n      selectSQL.append(pgmd.getBaseColumnName(i));\n    }\n    selectSQL.append(\" from \").append(onlyTable).append(tableName).append(\" where \");\n\n    List<PrimaryKey> primaryKeys = castNonNull(this.primaryKeys, \"primaryKeys\");\n    int numKeys = primaryKeys.size();\n\n    for (int i = 0; i < numKeys; i++) {\n\n      PrimaryKey primaryKey = primaryKeys.get(i);\n      selectSQL.append(primaryKey.name).append(\" = ?\");\n\n      if (i < numKeys - 1) {\n        selectSQL.append(\" and \");\n      }\n    }\n    String sqlText = selectSQL.toString();\n    if (connection.getLogger().isLoggable(Level.FINE)) {\n      connection.getLogger().log(Level.FINE, \"selecting {0}\", sqlText);\n    }\n    // because updateable result sets do not yet support binary transfers we must request refresh\n    // with updateable result set to get field data in correct format\n    PreparedStatement selectStatement = null;\n    try {\n      selectStatement = connection.prepareStatement(sqlText,\n          ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);\n\n      for (int i = 0; i < numKeys; i++) {\n        selectStatement.setObject(i + 1, primaryKeys.get(i).getValue());\n      }\n\n      PgResultSet rs = (PgResultSet) selectStatement.executeQuery();\n\n      if (rs.next()) {\n        // we know that the row is updatable as it was tested above.\n        if ( rs.thisRow == null ) {\n          rowBuffer = null;\n        } else {\n          rowBuffer = castNonNull(rs.thisRow).updateableCopy();\n        }\n      }\n\n      castNonNull(rows).set(currentRow, castNonNull(rowBuffer));\n      thisRow = rowBuffer;\n\n      connection.getLogger().log(Level.FINE, \"done updates\");\n\n      rs.close();\n    } finally {\n      JdbcBlackHole.close(selectStatement);\n    }\n  }",
            "commit_message": "Merge pull request from GHSA-r38f-c4h4-hqq2\n\nFixes SQL generated in PgResultSet.refresh() to escape column identifiers so as to prevent SQL injection.\n\nPreviously, the column names for both key and data columns in the table were copied as-is into the generated\nSQL. This allowed a malicious table with column names that include statement terminator to be parsed and\nexecuted as multiple separate commands.\n\nAlso adds a new test class ResultSetRefreshTest to verify this change."
        },
        "CWE": "CWE-89",
        "CVE": "CVE-2022-31197"
    },
    {
        "data": {
            "function_name": "unzip",
            "function_code": "public static String unzip(File zipfile) throws IOException {\n    \treturn unzip(zipfile, null);\n    }",
            "commit_message": "[DS-4131] Better path handling in ItemImport zips"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-31195"
    },
    {
        "data": {
            "function_name": "unzip",
            "function_code": "public static String unzip(File zipfile) throws IOException {\n    \treturn unzip(zipfile, null);\n    }",
            "commit_message": "[DS-4131] Better path handling in ItemImport zips"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-31195"
    },
    {
        "data": {
            "function_name": "call",
            "function_code": "@Override\n\t\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\t\tFile artifactsDir = getBuild().getArtifactsDir();\n\t\t\t\t\t\tfor (FileUpload upload: uploads) {\n\t\t\t\t\t\t\tString filePath = FilenameUtils.sanitizeFilename(upload.getFileName());\n\t\t\t\t\t\t\tif (directory != null)\n\t\t\t\t\t\t\t\tfilePath = directory + \"/\" + filePath;\n\t\t\t\t\t\t\tFile file = new File(artifactsDir, filePath);\n\t\t\t\t\t\t\tFileUtils.createDir(file.getParentFile());\n\t\t\t\t\t\t\ttry (\tInputStream is = upload.getInputStream();\n\t\t\t\t\t\t\t\t\tOutputStream os = new FileOutputStream(file)) {\n\t\t\t\t\t\t\t\tIOUtils.copy(is, os);\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tupload.release();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}",
            "commit_message": "Fix issue #842 - A security vulnerability relating to path traversal"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-38301"
    },
    {
        "data": {
            "function_name": "newResourceResponse",
            "function_code": "@Override\n\tprotected ResourceResponse newResourceResponse(Attributes attributes) {\n\t\tPageParameters params = attributes.getParameters();\n\n\t\tLong projectId = params.get(PARAM_PROJECT).toLong();\n\t\tProject project = OneDev.getInstance(ProjectManager.class).load(projectId);\n\t\t\n\t\tLong buildNumber = params.get(PARAM_BUILD).toOptionalLong();\n\t\t\n\t\tif (buildNumber == null)\n\t\t\tthrow new IllegalArgumentException(\"build number has to be specified\");\n\t\t\n\t\tBuild build = OneDev.getInstance(BuildManager.class).find(project, buildNumber);\n\n\t\tif (build == null) {\n\t\t\tString message = String.format(\"Unable to find build (project: %s, build number: %d)\", \n\t\t\t\t\tproject.getPath(), buildNumber);\n\t\t\tthrow new EntityNotFoundException(message);\n\t\t}\n\t\t\n\t\tif (!SecurityUtils.canAccess(build))\n\t\t\tthrow new UnauthorizedException();\n\t\t\n\t\tList<String> pathSegments = new ArrayList<>();\n\n\t\tfor (int i = 0; i < params.getIndexedCount(); i++) {\n\t\t\tString pathSegment = params.get(i).toString();\n\t\t\tif (pathSegment.length() != 0)\n\t\t\t\tpathSegments.add(pathSegment);\n\t\t}\n\t\t\n\t\tif (pathSegments.isEmpty())\n\t\t\tthrow new ExplicitException(\"Artifact path has to be specified\");\n\t\t\n\t\tString artifactPath = Joiner.on(\"/\").join(pathSegments);\n\t\t\n\t\tFile artifactsDir = build.getArtifactsDir();\n\t\tFile artifactFile = new File(artifactsDir, artifactPath);\n\t\tif (!artifactFile.exists() || artifactFile.isDirectory()) {\n\t\t\tString message = String.format(\"Specified artifact path does not exist or is a directory (project: %s, build number: %d, path: %s)\", \n\t\t\t\t\tproject.getPath(), build.getNumber(), artifactPath);\n\t\t\tthrow new ExplicitException(message);\n\t\t}\n\t\t\t\n\t\tResourceResponse response = new ResourceResponse();\n\t\ttry (InputStream is = new BufferedInputStream(new FileInputStream(artifactFile))) {\n\t\t\tresponse.setContentType(ContentDetector.detectMediaType(is, artifactPath).toString());\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t\tresponse.disableCaching();\n\t\t\n\t\ttry {\n\t\t\tresponse.setFileName(URLEncoder.encode(artifactFile.getName(), StandardCharsets.UTF_8.name()));\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t\tresponse.setContentLength(artifactFile.length());\n\t\t\n\t\tresponse.setWriteCallback(new WriteCallback() {\n\n\t\t\t@Override\n\t\t\tpublic void writeData(Attributes attributes) throws IOException {\n\t\t\t\tLockUtils.read(build.getArtifactsLockKey(), new Callable<Void>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\t\ttry (InputStream is = new FileInputStream(artifactFile)) {\n\t\t\t\t\t\t\tIOUtils.copy(is, attributes.getResponse().getOutputStream());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t}\t\t\t\n\t\t\t\n\t\t});\n\n\t\treturn response;\n\t}",
            "commit_message": "Fix XSS attach for published artifacts"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-39207"
    },
    {
        "data": {
            "function_name": "unzip",
            "function_code": "public static void unzip(File input, File destinationDir) throws IOException {\n\t\ttry (ZipInputStream zipInput = new ZipInputStream(new BufferedInputStream(new FileInputStream(input)))) {\n\t\t\tZipEntry entry;\n\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\tFile dest = new File(destinationDir, entry.getName());\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\tFileMisc.mkdirs(dest);\n\t\t\t\t} else {\n\t\t\t\t\tFileMisc.mkdirs(dest.getParentFile());\n\t\t\t\t\ttry (OutputStream output = new BufferedOutputStream(new FileOutputStream(dest))) {\n\t\t\t\t\t\tcopy(zipInput, output);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "commit_message": "[SECURITY] Fix Zip Slip Vulnerability (#198)"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-26049"
    },
    {
        "data": {
            "function_name": "download",
            "function_code": "private File download(String driverFileUrl, String parentDir) {\n        Path parentDirPath = Paths.get(parentDir);\n        try {\n            Files.createDirectories(parentDirPath);\n        } catch (IOException e) {\n            log.error(\"\u4e0b\u8f7d\u9a71\u52a8\u65f6\u521b\u5efa\u76ee\u5f55\u5931\u8d25\", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(e);\n        }\n\n        // download\n        try {\n            return restTemplate.execute(driverFileUrl, HttpMethod.GET, null, response -> {\n                if (response.getStatusCode().is2xxSuccessful()) {\n                    String prefix = System.currentTimeMillis() + \"\";\n                    String originFileName = response.getHeaders().getContentDisposition().getFilename();\n                    String filename;\n                    if (originFileName == null) {\n                        URL url = new URL(driverFileUrl);\n                        String nameFromUrl = FilenameUtils.getName(url.getPath());\n                        if (StringUtils.endsWith(nameFromUrl, \".jar\")) {\n                            filename = prefix + \"-\" + nameFromUrl;\n                        } else {\n                            filename = prefix + \".jar\";\n                        }\n                    } else {\n                        filename = prefix + \"-\" + originFileName;\n                    }\n                    File targetFile = Paths.get(parentDir, filename).toFile();\n                    FileOutputStream out = new FileOutputStream(targetFile);\n                    StreamUtils.copy(response.getBody(), out);\n                    IOUtils.closeQuietly(out, ex -> log.error(\"close file error\", ex));\n                    log.info(\"{} download success \", targetFile);\n                    return targetFile;\n                } else {\n                    log.error(\"{} download error from {}: {} \", parentDir, driverFileUrl, response);\n                    throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(\"\u9a71\u52a8\u4e0b\u8f7d\u5931\u8d25\uff1a\"\n                            + response.getStatusCode()\n                            + \", \"\n                            + response.getStatusText());\n                }\n            });\n        } catch (RestClientException e) {\n            log.error(parentDir + \" download driver error\", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(e.getMessage());\n        }\n    }\n\n    public void deleteByDatabaseTy",
            "commit_message": "fix: security vulnerability SSRF (#256)"
        },
        "CWE": "CWE-918",
        "CVE": "CVE-2022-31196"
    },
    {
        "data": {
            "function_name": "config",
            "function_code": "@RequestMapping(params = \"action=\" + ACTION_CONFIG)\n    @ResponseBody\n    public UeditorConfig config(HttpServletRequest request) {\n        String urlPrefix = siteComponent.getSite(request.getServerName()).getSitePath();\n        UeditorConfig config = new UeditorConfig();\n        config.setImageActionName(ACTION_UPLOAD);\n        config.setSnapscreenActionName(ACTION_UPLOAD);\n        config.setScrawlActionName(ACTION_UPLOAD_SCRAW);\n        config.setVideoActionName(ACTION_UPLOAD);\n        config.setFileActionName(ACTION_UPLOAD);\n        config.setCatcherActionName(ACTION_CATCHIMAGE);\n        config.setImageManagerActionName(ACTION_LISTFILE);\n        config.setFileManagerActionName(ACTION_LISTFILE);\n        config.setImageFieldName(FIELD_NAME);\n        config.setScrawlFieldName(FIELD_NAME);\n        config.setCatcherFieldName(FIELD_NAME);\n        config.setVideoFieldName(FIELD_NAME);\n        config.setFileFieldName(FIELD_NAME);\n        config.setImageUrlPrefix(urlPrefix);\n        config.setScrawlUrlPrefix(urlPrefix);\n        config.setSnapscreenUrlPrefix(urlPrefix);\n        config.setCatcherUrlPrefix(urlPrefix);\n        config.setVideoUrlPrefix(urlPrefix);\n        config.setFileUrlPrefix(urlPrefix);\n        config.setImageManagerUrlPrefix(urlPrefix);\n        config.setFileManagerUrlPrefix(urlPrefix);\n        config.setImageAllowFiles(IMAGE_ALLOW_FILES);\n        config.setCatcherAllowFiles(IMAGE_ALLOW_FILES);\n        config.setVideoAllowFiles(VIDEO_ALLOW_FILES);\n        config.setFileAllowFiles(ALLOW_FILES);\n        config.setImageManagerAllowFiles(IMAGE_ALLOW_FILES);\n        config.setFileManagerAllowFiles(ALLOW_FILES);\n        return config;\n    }",
            "commit_message": "https://github.com/sanluan/PublicCMS/issues/51"
        },
        "CWE": "CWE-918",
        "CVE": "CVE-2021-27693"
    },
    {
        "data": {
            "function_name": "tryUnpackZipFile",
            "function_code": "private boolean tryUnpackZipFile(final File importSandboxDirectory, final MultipartFile multipartFile) {\n        /* Extract ZIP contents */\n        ZipEntry zipEntry = null;\n        InputStream inputStream = null;\n        ZipInputStream zipInputStream = null;\n        boolean foundEntry = false;\n        try {\n            inputStream = ServiceUtilities.ensureInputSream(multipartFile);\n            zipInputStream = new ZipInputStream(inputStream);\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                foundEntry = true;\n                final File destFile = new File(importSandboxDirectory, zipEntry.getName());\n                if (!zipEntry.isDirectory()) {\n                    ServiceUtilities.ensureFileCreated(destFile);\n                    final FileOutputStream destOutputStream = new FileOutputStream(destFile);\n                    try {\n                        ByteStreams.copy(zipInputStream, destOutputStream);\n                    }\n                    finally {\n                        ServiceUtilities.ensureClose(destOutputStream);\n                    }\n                    zipInputStream.closeEntry();\n                }\n            }\n        }\n        catch (final EOFException e) {\n            /* (Might get this if the ZIP file is truncated for some reason) */\n            return false;\n        }\n        catch (final ZipException e) {\n            return false;\n        }\n        catch (final IOException e) {\n            throw QtiWorksRuntimeException.unexpectedException(e);\n        }\n        finally {\n            ServiceUtilities.ensureClose(zipInputStream, inputStream);\n        }\n        return foundEntry;\n    }",
            "commit_message": "vuln-fix: Zip Slip Vulnerability\n\nThis fixes a Zip-Slip vulnerability.\n\nThis change does one of two things. This change either\n\n1. Inserts a guard to protect against Zip Slip.\nOR\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: High\nCVSSS: 7.4\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\n\nCo-authored-by: Moderne <team@moderne.io>"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-39367"
    },
    {
        "data": {
            "function_name": "getJdbc",
            "function_code": "public String getJdbc() {\n        if(StringUtils.isEmpty(extraParams.trim())){\n            return \"jdbc:mysql://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getHost().trim())\n                    .replace(\"PORT\", getPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }else {\n            return \"jdbc:mysql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getHost().trim())\n                    .replace(\"PORT\", getPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n    }",
            "commit_message": "fix(\u6570\u636e\u6e90): Mysql jdbc\u53cd\u5e8f\u5217\u5316\u6f0f\u6d1e"
        },
        "CWE": "CWE-502",
        "CVE": "CVE-2022-39312"
    },
    {
        "data": {
            "function_name": "handleRequest",
            "function_code": "@Override\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            RemoteInvocation invocation = readRemoteInvocation(request);\n\n            if (!authorized(request, response, invocation)) {\n                return;\n            }\n\n            RemoteInvocationResult result = invokeAndCreateResult(invocation, getProxy());\n            writeRemoteInvocationResult(request, response, result);\n        } catch (ClassNotFoundException ex) {\n            throw new NestedServletException(\"Class not found during deserialization\", ex);\n        }\n    }",
            "commit_message": "Disable RMI endpoint by default\n\nThis endpoint can be enabled by including `gocd.agent.remoting.legacy=true` in the\n`-Dgocd.agent.extra.properties` property for the server process."
        },
        "CWE": "CWE-502",
        "CVE": "CVE-2022-39311"
    },
    {
        "data": {
            "function_name": "readHeaders",
            "function_code": "private void readHeaders(long fileLength) throws IOException, RarException {\n\t\tmarkHead = null;\n\t\tnewMhd = null;\n\t\theaders.clear();\n\t\tcurrentHeaderIndex = 0;\n\t\tint toRead = 0;\n\n\t\twhile (true) {\n\t\t\tint size = 0;\n\t\t\tlong newpos = 0;\n\t\t\tbyte[] baseBlockBuffer = new byte[BaseBlock.BaseBlockSize];\n\n\t\t\tlong position = rof.getPosition();\n\n\t\t\t// Weird, but is trying to read beyond the end of the file\n\t\t\tif (position >= fileLength) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// logger.info(\"\\n--------reading header--------\");\n\t\t\tsize = rof.readFully(baseBlockBuffer, BaseBlock.BaseBlockSize);\n\t\t\tif (size == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBaseBlock block = new BaseBlock(baseBlockBuffer);\n\n\t\t\tblock.setPositionInFile(position);\n\n\t\t\tswitch (block.getHeaderType()) {\n\n\t\t\tcase MarkHeader:\n\t\t\t\tmarkHead = new MarkHeader(block);\n\t\t\t\tif (!markHead.isSignature()) {\n\t\t\t\t\tthrow new RarException(\n\t\t\t\t\t\t\tRarException.RarExceptionType.badRarArchive);\n\t\t\t\t}\n\t\t\t\theaders.add(markHead);\n\t\t\t\t// markHead.print();\n\t\t\t\tbreak;\n\n\t\t\tcase MainHeader:\n\t\t\t\ttoRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc\n\t\t\t\t\t\t: MainHeader.mainHeaderSize;\n\t\t\t\tbyte[] mainbuff = new byte[toRead];\n\t\t\t\trof.readFully(mainbuff, toRead);\n\t\t\t\tMainHeader mainhead = new MainHeader(block, mainbuff);\n\t\t\t\theaders.add(mainhead);\n\t\t\t\tthis.newMhd = mainhead;\n\t\t\t\tif (newMhd.isEncrypted()) {\n\t\t\t\t\tthrow new RarException(\n\t\t\t\t\t\t\tRarExceptionType.rarEncryptedException);\n\t\t\t\t}\n\t\t\t\t// mainhead.print();\n\t\t\t\tbreak;\n\n\t\t\tcase SignHeader:\n\t\t\t\ttoRead = SignHeader.signHeaderSize;\n\t\t\t\tbyte[] signBuff = new byte[toRead];\n\t\t\t\trof.readFully(signBuff, toRead);\n\t\t\t\tSignHeader signHead = new SignHeader(block, signBuff);\n\t\t\t\theaders.add(signHead);\n\t\t\t\t// logger.info(\"HeaderType: SignHeader\");\n\n\t\t\t\tbreak;\n\n\t\t\tcase AvHeader:\n\t\t\t\ttoRead = AVHeader.avHeaderSize;\n\t\t\t\tbyte[] avBuff = new byte[toRead];\n\t\t\t\trof.readFully(avBuff, toRead);\n\t\t\t\tAVHeader avHead = new AVHeader(block, avBuff);\n\t\t\t\theaders.add(avHead);\n\t\t\t\t// logger.info(\"headertype: AVHeader\");\n\t\t\t\tbreak;\n\n\t\t\tcase CommHeader:\n\t\t\t\ttoRead = CommentHeader.commentHeaderSize;\n\t\t\t\tbyte[] commBuff = new byte[toRead];\n\t\t\t\trof.readFully(commBuff, toRead);\n\t\t\t\tCommentHeader commHead = new CommentHeader(block, commBuff);\n\t\t\t\theaders.add(commHead);\n\t\t\t\t// logger.info(\"method: \"+commHead.getUnpMethod()+\"; 0x\"+\n\t\t\t\t// Integer.toHexString(commHead.getUnpMethod()));\n\t\t\t\tnewpos = commHead.getPositionInFile()\n\t\t\t\t\t\t+ commHead.getHeaderSize();\n\t\t\t\trof.setPosition(newpos);\n\n\t\t\t\tbreak;\n\t\t\tcase EndArcHeader:\n\n\t\t\t\ttoRead = 0;\n\t\t\t\tif (block.hasArchiveDataCRC()) {\n\t\t\t\t\ttoRead += EndArcHeader.endArcArchiveDataCrcSize;\n\t\t\t\t}\n\t\t\t\tif (block.hasVolumeNumber()) {\n\t\t\t\t\ttoRead += EndArcHeader.endArcVolumeNumberSize;\n\t\t\t\t}\n\t\t\t\tEndArcHeader endArcHead;\n\t\t\t\tif (toRead > 0) {\n\t\t\t\t\tbyte[] endArchBuff = new byte[toRead];\n\t\t\t\t\trof.readFully(endArchBuff, toRead);\n\t\t\t\t\tendArcHead = new EndArcHeader(block, endArchBuff);\n\t\t\t\t\t// logger.info(\"HeaderType: endarch\\ndatacrc:\"+\n\t\t\t\t\t// endArcHead.getArchiveDataCRC());\n\t\t\t\t} else {\n\t\t\t\t\t// logger.info(\"HeaderType: endarch - no Data\");\n\t\t\t\t\tendArcHead = new EndArcHeader(block, null);\n\t\t\t\t}\n\t\t\t\theaders.add(endArcHead);\n\t\t\t\t// logger.info(\"\\n--------end header--------\");\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\t\t\t\tbyte[] blockHeaderBuffer = new byte[BlockHeader.blockHeaderSize];\n\t\t\t\trof.readFully(blockHeaderBuffer, BlockHeader.blockHeaderSize);\n\t\t\t\tBlockHeader blockHead = new BlockHeader(block,\n\t\t\t\t\t\tblockHeaderBuffer);\n\n\t\t\t\tswitch (blockHead.getHeaderType()) {\n\t\t\t\tcase NewSubHeader:\n\t\t\t\tcase FileHeader:\n\t\t\t\t\ttoRead = blockHead.getHeaderSize()\n\t\t\t\t\t\t\t- BlockHeader.BaseBlockSize\n\t\t\t\t\t\t\t- BlockHeader.blockHeaderSize;\n\t\t\t\t\tbyte[] fileHeaderBuffer = new byte[toRead];\n\t\t\t\t\trof.readFully(fileHeaderBuffer, toRead);\n\n\t\t\t\t\tFileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);\n\t\t\t\t\theaders.add(fh);\n\t\t\t\t\tnewpos = fh.getPositionInFile() + fh.getHeaderSize()\n\t\t\t\t\t\t\t+ fh.getFullPackSize();\n\t\t\t\t\trof.setPosition(newpos);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ProtectHeader:\n\t\t\t\t\ttoRead = blockHead.getHeaderSize()\n\t\t\t\t\t\t\t- BlockHeader.BaseBlockSize\n\t\t\t\t\t\t\t- BlockHeader.blockHeaderSize;\n\t\t\t\t\tbyte[] protectHeaderBuffer = new byte[toRead];\n\t\t\t\t\trof.readFully(protectHeaderBuffer, toRead);\n\t\t\t\t\tProtectHeader ph = new ProtectHeader(blockHead,\n\t\t\t\t\t\t\tprotectHeaderBuffer);\n\n\t\t\t\t\tnewpos = ph.getPositionInFile() + ph.getHeaderSize()\n\t\t\t\t\t\t\t+ ph.getDataSize();\n\t\t\t\t\trof.setPosition(newpos);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SubHeader: {\n\t\t\t\t\tbyte[] subHeadbuffer = new byte[SubBlockHeader.SubBlockHeaderSize];\n\t\t\t\t\trof.readFully(subHeadbuffer,\n\t\t\t\t\t\t\tSubBlockHeader.SubBlockHeaderSize);\n\t\t\t\t\tSubBlockHeader subHead = new SubBlockHeader(blockHead,\n\t\t\t\t\t\t\tsubHeadbuffer);\n\t\t\t\t\tsubHead.print();\n\t\t\t\t\tswitch (subHead.getSubType()) {\n\t\t\t\t\tcase MAC_HEAD: {\n\t\t\t\t\t\tbyte[] macHeaderbuffer = new byte[MacInfoHeader.MacInfoHeaderSize];\n\t\t\t\t\t\trof.readFully(macHeaderbuffer,\n\t\t\t\t\t\t\t\tMacInfoHeader.MacInfoHeaderSize);\n\t\t\t\t\t\tMacInfoHeader macHeader = new MacInfoHeader(subHead,\n\t\t\t\t\t\t\t\tmacHeaderbuffer);\n\t\t\t\t\t\tmacHeader.print();\n\t\t\t\t\t\theaders.add(macHeader);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// TODO implement other subheaders\n\t\t\t\t\tcase BEEA_HEAD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EA_HEAD: {\n\t\t\t\t\t\tbyte[] eaHeaderBuffer = new byte[EAHeader.EAHeaderSize];\n\t\t\t\t\t\trof.readFully(eaHeaderBuffer, EAHeader.EAHeaderSize);\n\t\t\t\t\t\tEAHeader eaHeader = new EAHeader(subHead,\n\t\t\t\t\t\t\t\teaHeaderBuffer);\n\t\t\t\t\t\teaHeader.print();\n\t\t\t\t\t\theaders.add(eaHeader);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase NTACL_HEAD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase STREAM_HEAD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UO_HEAD:\n\t\t\t\t\t\ttoRead = subHead.getHeaderSize();\n\t\t\t\t\t\ttoRead -= BaseBlock.BaseBlockSize;\n\t\t\t\t\t\ttoRead -= BlockHeader.blockHeaderSize;\n\t\t\t\t\t\ttoRead -= SubBlockHeader.SubBlockHeaderSize;\n\t\t\t\t\t\tbyte[] uoHeaderBuffer = new byte[toRead];\n\t\t\t\t\t\trof.readFully(uoHeaderBuffer, toRead);\n\t\t\t\t\t\tUnixOwnersHeader uoHeader = new UnixOwnersHeader(\n\t\t\t\t\t\t\t\tsubHead, uoHeaderBuffer);\n\t\t\t\t\t\tuoHeader.print();\n\t\t\t\t\t\theaders.add(uoHeader);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.warning(\"Unknown Header\");\n\t\t\t\t\tthrow new RarException(RarExceptionType.notRarArchive);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t// logger.info(\"\\n--------end header--------\");\n\t\t}\n\t}",
            "commit_message": "make Archive slightly more robust against corrupt files.  Add (#8)\n\nunit test file from Apache Tika."
        },
        "CWE": "CWE-399",
        "CVE": "CVE-2018-12418"
    },
    {
        "data": {
            "function_name": "process",
            "function_code": "blic void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      bytes = IOUtils.toByteArray(in);\n    }\n\n",
            "commit_message": "Fixed potential security vulnerability reported by Snyk Security Research Team\n\nThis is an arbitrary file write vulnerability, that can be achieved using a specially crafted zip archive, that holds path traversal filenames. So when the filename gets concatenated to the target extraction directory, the final path ends up outside of the target folder."
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2018-1002201"
    },
    {
        "data": {
            "function_name": "getResolvedIndexPattern",
            "function_code": "public Set<String> getResolvedIndexPattern(final User user, final IndexNameExpressionResolver resolver, final ClusterService cs, final boolean appendUnresolved) {\n            final String unresolved = getUnresolvedIndexPattern(user);\n            final ImmutableSet.Builder<String> resolvedIndices = new ImmutableSet.Builder<>();\n\n            final WildcardMatcher matcher = WildcardMatcher.from(unresolved);\n            if (!(matcher instanceof WildcardMatcher.Exact)) {\n                final String[] aliasesForPermittedPattern = cs.state().getMetadata().getIndicesLookup().entrySet().stream()\n                        .filter(e -> e.getValue().getType() == ALIAS)\n                        .filter(e -> matcher.test(e.getKey()))\n                        .map(e -> e.getKey())\n                        .toArray(String[]::new);\n                if (aliasesForPermittedPattern.length > 0) {\n                    final String[] resolvedAliases = resolver.concreteIndexNames(cs.state(), IndicesOptions.lenientExpandOpen(), aliasesForPermittedPattern);\n                    resolvedIndices.addAll(Arrays.asList(resolvedAliases));\n                }\n            }\n\n            if (Strings.isNotBlank(unresolved)) {\n                final String[] resolvedIndicesFromPattern = resolver.concreteIndexNames(cs.state(), IndicesOptions.lenientExpandOpen(), unresolved);\n                resolvedIndices.addAll(Arrays.asList(resolvedIndicesFromPattern));\n            }\n\n            if (appendUnresolved || resolvedIndices.build().isEmpty()) {\n                resolvedIndices.add(unresolved);\n            }\n            return resolvedIndices.build();\n        }",
            "commit_message": "Merge pull request from GHSA-wmx7-x4jp-9jgg\n\n* Resolving backing indices of data streams when resolving for aliases\n\n* Fixing resolution of indices for non-wild card scenarios / exact matches\n\n* Adding tests for DLS/FLS/Field-Masking on Data Streams\n\nCo-authored-by: Sandesh Kumar <kusandes@amazon.com>"
        },
        "CWE": "CWE-863",
        "CVE": "CVE-2022-41918"
    },
    {
        "data": {
            "function_name": "copy",
            "function_code": "public static void copy(InputStream input, File output) throws IOException {\n\t\tFileOutputStream fos = new FileOutputStream(output);\n\t\tIOUtils.copy(input, fos);\n\t\tfos.flush();\n\t\tfos.close();\n\t}",
            "commit_message": "Fix Temporary Directory Hijacking or Information Disclosure Vulnerability\n\nfix #332"
        },
        "CWE": "CWE-377",
        "CVE": "CVE-2022-3969"
    },
    {
        "data": {
            "function_name": "createTempDir",
            "function_code": "public static File createTempDir(int port) throws IOException {\n        File tempDir = File.createTempFile(\"portofino.tomcat.\", \".\" + port);\n        tempDir.delete();\n        tempDir.mkdir();\n        tempDir.deleteOnExit();\n        return tempDir;\n    }",
            "commit_message": "vuln-fix: Temporary Directory Hijacking or Information Disclosure\n\n\n\nThis fixes either Temporary Directory Hijacking, or Temporary Directory Local Information Disclosure.\n\nWeakness: CWE-379: Creation of Temporary File in Directory with Insecure Permissions\nSeverity: High\nCVSSS: 7.3\nDetection: CodeQL & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.UseFilesCreateTempDirectory)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/10\n\n\nCo-authored-by: Moderne <team@moderne.io>"
        },
        "CWE": "CWE-668",
        "CVE": "CVE-2022-3952"
    },
    {
        "data": {
            "function_name": "normalize",
            "function_code": "protected String normalize(String path) {\n        if (path == null) {\n            return null;\n        }\n\n        String rv = path;\n        // starts with a double-slash\n        if (rv.indexOf(\"//\") == 0) {\n            rv = rv.replace(\"//\", \"/\");\n        }\n        // starts with dot-slash\n        if (rv.indexOf(\"./\") == 0) {\n            rv = rv.replaceFirst(\"./\", \"/\");\n        }\n        // has /WEB-INF or /META-INF\n        final String RV = rv.toUpperCase();\n        int index = RV.indexOf(\"/WEB-INF/\");\n        if (index != -1 || RV.endsWith(\"/WEB-INF\")) {\n            return \"/WEB-INF\";\n        }\n\n        // Normalize the slashes and add leading slash if necessary\n        if (rv.indexOf('\\\\') >= 0) {\n            rv = rv.replace('\\\\', '/');\n        }\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            int idx = rv.indexOf(\"/../\");\n            if (idx < 0) {\n                break;\n            }\n            if (idx == 0) {\n                return null;  // negative relative path\n            }\n            int index2 = rv.lastIndexOf('/', idx - 1);\n            rv = rv.substring(0, index2) + rv.substring(idx + 3);\n        }\n\n        // Resolve occurrences of \"/./\" example if the path looks like /app/./some/./something/./my.jsp\n        //then after processing should look like /app/some/something/my.jsp\n        rv = evaluateNormalizedPathWithSinglePoint(rv);\n\n        //if the path don't start with / then include it\n        if(!rv.startsWith(\"/\")) {\n            rv = \"/\" + rv;\n        }\n\n        // Return the normalized path that we have completed\n        return rv;\n    }",
            "commit_message": "Merge pull request #5989 from luiseufrasio/FISH-6603\n\nFish-6603 New 0-day vulnerability exploit using ROOT context root deployments"
        },
        "CWE": "CWE-552",
        "CVE": "CVE-2022-45129"
    },
    {
        "data": {
            "function_name": "submitForm",
            "function_code": "private void submitForm() {\n        ApplicationContext ac = AppUtil.getApplicationContext();\n        WorkflowUserManager workflowUserManager = (WorkflowUserManager) ac.getBean(\"workflowUserManager\");\n        UserDao userDao = (UserDao) ac.getBean(\"userDao\");\n        User userObject = userDao.getUser(workflowUserManager.getCurrentUsername());\n        User currentUser = null;\n        if (userObject != null) {\n            currentUser = new User();\n            BeanUtils.copyProperties(userObject, currentUser);\n        }\n        ExtDirectoryManager directoryManager = (ExtDirectoryManager) AppUtil.getApplicationContext().getBean(\"directoryManager\");\n           \n        Collection<String> errors = new ArrayList<String>();\n        Collection<String> passwordErrors = new ArrayList<String>();\n        \n        boolean authenticated = false;\n        if (currentUser != null) {\n            if (!currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                HttpServletRequest request = WorkflowUtil.getHttpServletRequest();\n                if (request != null) {\n                    HttpSession session = request.getSession(false);\n                    if (session != null) {\n                        session.invalidate();\n                        authenticated = false;\n                    }\n                }\n            } else {\n                try {\n                    if (directoryManager.authenticate(currentUser.getUsername(), getRequestParameterString(\"oldPassword\"))) {\n                        authenticated = true;\n                    }\n                } catch (Exception e) { }\n            }\n        }\n        UserSecurity us = DirectoryUtil.getUserSecurity();\n        \n        if (\"\".equals(getPropertyString(\"f_firstName\"))) {\n            currentUser.setFirstName(getRequestParameterString(\"firstName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_lastName\"))) {\n            currentUser.setLastName(getRequestParameterString(\"lastName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_email\"))) {\n            currentUser.setEmail(getRequestParameterString(\"email\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_timeZone\"))) {\n            currentUser.setTimeZone(getRequestParameterString(\"timeZone\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_locale\"))) {\n            currentUser.setLocale(getRequestParameterString(\"locale\"));\n        }\n\n        if (!authenticated) {\n            if (errors == null) {\n                errors = new ArrayList<String>();\n            }\n            errors.add(ResourceBundleUtil.getMessage(\"console.directory.user.error.label.authenticationFailed\"));\n        } else {\n            if (us != null) {\n                errors = us.validateUserOnProfileUpdate(currentUser);\n            }\n\n            if (getRequestParameterString(\"password\") != null && !getRequestParameterString(\"password\").isEmpty() && us != null) {\n                passwordErrors = us.validatePassword(getRequestParameterString(\"username\"),  getRequestParameterString(\"oldPassword\"), getRequestParameterString(\"password\"), getRequestParameterString(\"confirmPassword\")); \n            }\n        }\n\n        setProperty(\"errors\", errors);\n        if (passwordErrors != null && !passwordErrors.isEmpty()) {\n            setProperty(\"passwordErrors\", passwordErrors);\n        }\n        \n        if (authenticated && (passwordErrors != null && passwordErrors.isEmpty()) && (errors != null && errors.isEmpty())) {\n            if (\"\".equals(getPropertyString(\"f_password\"))) {\n                if (getRequestParameterString(\"password\") != null && getRequestParameterString(\"confirmPassword\") != null && getRequestParameterString(\"password\").length() > 0 && getRequestParameterString(\"password\").equals(getRequestParameterString(\"confirmPassword\"))) {\n                    if (us != null) {\n                        currentUser.setPassword(us.encryptPassword(getRequestParameterString(\"username\"), getRequestParameterString(\"password\")));\n                    } else {\n                        currentUser.setPassword(StringUtil.md5Base16(getRequestParameterString(\"password\")));\n                    }\n                    currentUser.setConfirmPassword(getRequestParameterString(\"password\"));\n                }\n            }\n\n            if (currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                userDao.updateUser(currentUser);\n                if (us != null) {\n                    us.updateUserProfilePostProcessing(currentUser);\n                }\n                \n                setAlertMessage(getPropertyString(\"message\"));\n                setProperty(\"headerTitle\", getPropertyString(\"label\"));\n                if (getPropertyString(\"redirectURL\") != null && !getPropertyString(\"redirectURL\").isEmpty()) {\n                    setProperty(\"view\", \"redirect\");\n                    boolean redirectToParent = \"Yes\".equals(getPropertyString(\"showInPopupDialog\"));\n                    setRedirectUrl(getPropertyString(\"redirectURL\"), redirectToParent);\n                } else {\n                    setProperty(\"saved\", \"true\");\n                    viewForm(null);\n                }\n            }\n        } else {\n            viewForm(currentUser);\n        }\n    }",
            "commit_message": "Fixed: wflow-core - User Profile Menu - Prevent XSS. T1604 @7.0-SNAPSHOT"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-4859"
    },
    {
        "data": {
            "function_name": "submitForm",
            "function_code": "private void submitForm() {\n        ApplicationContext ac = AppUtil.getApplicationContext();\n        WorkflowUserManager workflowUserManager = (WorkflowUserManager) ac.getBean(\"workflowUserManager\");\n        UserDao userDao = (UserDao) ac.getBean(\"userDao\");\n        User userObject = userDao.getUser(workflowUserManager.getCurrentUsername());\n        User currentUser = null;\n        if (userObject != null) {\n            currentUser = new User();\n            BeanUtils.copyProperties(userObject, currentUser);\n        }\n        ExtDirectoryManager directoryManager = (ExtDirectoryManager) AppUtil.getApplicationContext().getBean(\"directoryManager\");\n           \n        Collection<String> errors = new ArrayList<String>();\n        Collection<String> passwordErrors = new ArrayList<String>();\n        \n        boolean authenticated = false;\n        if (currentUser != null) {\n            if (!currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                HttpServletRequest request = WorkflowUtil.getHttpServletRequest();\n                if (request != null) {\n                    HttpSession session = request.getSession(false);\n                    if (session != null) {\n                        session.invalidate();\n                        authenticated = false;\n                    }\n                }\n            } else {\n                try {\n                    if (directoryManager.authenticate(currentUser.getUsername(), getRequestParameterString(\"oldPassword\"))) {\n                        authenticated = true;\n                    }\n                } catch (Exception e) { }\n            }\n        }\n        UserSecurity us = DirectoryUtil.getUserSecurity();\n        \n        if (\"\".equals(getPropertyString(\"f_firstName\"))) {\n            currentUser.setFirstName(getRequestParameterString(\"firstName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_lastName\"))) {\n            currentUser.setLastName(getRequestParameterString(\"lastName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_email\"))) {\n            currentUser.setEmail(getRequestParameterString(\"email\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_timeZone\"))) {\n            currentUser.setTimeZone(getRequestParameterString(\"timeZone\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_locale\"))) {\n            currentUser.setLocale(getRequestParameterString(\"locale\"));\n        }\n\n        if (!authenticated) {\n            if (errors == null) {\n                errors = new ArrayList<String>();\n            }\n            errors.add(ResourceBundleUtil.getMessage(\"console.directory.user.error.label.authenticationFailed\"));\n        } else {\n            if (us != null) {\n                errors = us.validateUserOnProfileUpdate(currentUser);\n            }\n\n            if (getRequestParameterString(\"password\") != null && !getRequestParameterString(\"password\").isEmpty() && us != null) {\n                passwordErrors = us.validatePassword(getRequestParameterString(\"username\"),  getRequestParameterString(\"oldPassword\"), getRequestParameterString(\"password\"), getRequestParameterString(\"confirmPassword\")); \n            }\n        }\n\n        setProperty(\"errors\", errors);\n        if (passwordErrors != null && !passwordErrors.isEmpty()) {\n            setProperty(\"passwordErrors\", passwordErrors);\n        }\n        \n        if (authenticated && (passwordErrors != null && passwordErrors.isEmpty()) && (errors != null && errors.isEmpty())) {\n            if (\"\".equals(getPropertyString(\"f_password\"))) {\n                if (getRequestParameterString(\"password\") != null && getRequestParameterString(\"confirmPassword\") != null && getRequestParameterString(\"password\").length() > 0 && getRequestParameterString(\"password\").equals(getRequestParameterString(\"confirmPassword\"))) {\n                    if (us != null) {\n                        currentUser.setPassword(us.encryptPassword(getRequestParameterString(\"username\"), getRequestParameterString(\"password\")));\n                    } else {\n                        currentUser.setPassword(StringUtil.md5Base16(getRequestParameterString(\"password\")));\n                    }\n                    currentUser.setConfirmPassword(getRequestParameterString(\"password\"));\n                }\n            }\n\n            if (currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                userDao.updateUser(currentUser);\n                if (us != null) {\n                    us.updateUserProfilePostProcessing(currentUser);\n                }\n                \n                setAlertMessage(getPropertyString(\"message\"));\n                setProperty(\"headerTitle\", getPropertyString(\"label\"));\n                if (getPropertyString(\"redirectURL\") != null && !getPropertyString(\"redirectURL\").isEmpty()) {\n                    setProperty(\"view\", \"redirect\");\n                    boolean redirectToParent = \"Yes\".equals(getPropertyString(\"showInPopupDialog\"));\n                    setRedirectUrl(getPropertyString(\"redirectURL\"), redirectToParent);\n                } else {\n                    setProperty(\"saved\", \"true\");\n                    viewForm(null);\n                }\n            }\n        } else {\n            viewForm(currentUser);\n        }\n    }",
            "commit_message": "Fixed: wflow-core - User Profile Menu - Prevent XSS. T1604 @7.0-SNAPSHOT"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-4859"
    },
    {
        "data": {
            "function_name": "submitForm",
            "function_code": "private void submitForm() {\n        ApplicationContext ac = AppUtil.getApplicationContext();\n        WorkflowUserManager workflowUserManager = (WorkflowUserManager) ac.getBean(\"workflowUserManager\");\n        UserDao userDao = (UserDao) ac.getBean(\"userDao\");\n        User userObject = userDao.getUser(workflowUserManager.getCurrentUsername());\n        User currentUser = null;\n        if (userObject != null) {\n            currentUser = new User();\n            BeanUtils.copyProperties(userObject, currentUser);\n        }\n        ExtDirectoryManager directoryManager = (ExtDirectoryManager) AppUtil.getApplicationContext().getBean(\"directoryManager\");\n           \n        Collection<String> errors = new ArrayList<String>();\n        Collection<String> passwordErrors = new ArrayList<String>();\n        \n        boolean authenticated = false;\n        if (currentUser != null) {\n            if (!currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                HttpServletRequest request = WorkflowUtil.getHttpServletRequest();\n                if (request != null) {\n                    HttpSession session = request.getSession(false);\n                    if (session != null) {\n                        session.invalidate();\n                        authenticated = false;\n                    }\n                }\n            } else {\n                try {\n                    if (directoryManager.authenticate(currentUser.getUsername(), getRequestParameterString(\"oldPassword\"))) {\n                        authenticated = true;\n                    }\n                } catch (Exception e) { }\n            }\n        }\n        UserSecurity us = DirectoryUtil.getUserSecurity();\n        \n        if (\"\".equals(getPropertyString(\"f_firstName\"))) {\n            currentUser.setFirstName(getRequestParameterString(\"firstName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_lastName\"))) {\n            currentUser.setLastName(getRequestParameterString(\"lastName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_email\"))) {\n            currentUser.setEmail(getRequestParameterString(\"email\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_timeZone\"))) {\n            currentUser.setTimeZone(getRequestParameterString(\"timeZone\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_locale\"))) {\n            currentUser.setLocale(getRequestParameterString(\"locale\"));\n        }\n\n        if (!authenticated) {\n            if (errors == null) {\n                errors = new ArrayList<String>();\n            }\n            errors.add(ResourceBundleUtil.getMessage(\"console.directory.user.error.label.authenticationFailed\"));\n        } else {\n            if (us != null) {\n                errors = us.validateUserOnProfileUpdate(currentUser);\n            }\n\n            if (getRequestParameterString(\"password\") != null && !getRequestParameterString(\"password\").isEmpty() && us != null) {\n                passwordErrors = us.validatePassword(getRequestParameterString(\"username\"),  getRequestParameterString(\"oldPassword\"), getRequestParameterString(\"password\"), getRequestParameterString(\"confirmPassword\")); \n            }\n        }\n\n        setProperty(\"errors\", errors);\n        if (passwordErrors != null && !passwordErrors.isEmpty()) {\n            setProperty(\"passwordErrors\", passwordErrors);\n        }\n        \n        if (authenticated && (passwordErrors != null && passwordErrors.isEmpty()) && (errors != null && errors.isEmpty())) {\n            if (\"\".equals(getPropertyString(\"f_password\"))) {\n                if (getRequestParameterString(\"password\") != null && getRequestParameterString(\"confirmPassword\") != null && getRequestParameterString(\"password\").length() > 0 && getRequestParameterString(\"password\").equals(getRequestParameterString(\"confirmPassword\"))) {\n                    if (us != null) {\n                        currentUser.setPassword(us.encryptPassword(getRequestParameterString(\"username\"), getRequestParameterString(\"password\")));\n                    } else {\n                        currentUser.setPassword(StringUtil.md5Base16(getRequestParameterString(\"password\")));\n                    }\n                    currentUser.setConfirmPassword(getRequestParameterString(\"password\"));\n                }\n            }\n\n            if (currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                userDao.updateUser(currentUser);\n                if (us != null) {\n                    us.updateUserProfilePostProcessing(currentUser);\n                }\n                \n                setAlertMessage(getPropertyString(\"message\"));\n                setProperty(\"headerTitle\", getPropertyString(\"label\"));\n                if (getPropertyString(\"redirectURL\") != null && !getPropertyString(\"redirectURL\").isEmpty()) {\n                    setProperty(\"view\", \"redirect\");\n                    boolean redirectToParent = \"Yes\".equals(getPropertyString(\"showInPopupDialog\"));\n                    setRedirectUrl(getPropertyString(\"redirectURL\"), redirectToParent);\n                } else {\n                    setProperty(\"saved\", \"true\");\n                    viewForm(null);\n                }\n            }\n        } else {\n            viewForm(currentUser);\n        }\n    }",
            "commit_message": "Fixed: wflow-core - User Profile Menu - Prevent XSS. T1604 @7.0-SNAPSHOT"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-4859"
    },
    {
        "data": {
            "function_name": "documentBuilder",
            "function_code": "@Bean\n    public DocumentBuilder documentBuilder() throws ParserConfigurationException {\n        DocumentBuilderFactory domFactory =  DocumentBuilderFactory.newInstance();\n        domFactory.setNamespaceAware(true);\n        return domFactory.newDocumentBuilder();\n    }",
            "commit_message": "Merge pull request #97 from radiovideo/XXE-vulnerability-fix\n\nFix DocumentBuilderFactory XXE vulnerability"
        },
        "CWE": "CWE-611",
        "CVE": "CVE-2021-4295"
    },
    {
        "data": {
            "function_name": "main",
            "function_code": "public static void main(String[] args) throws IOException, GitAPIException {\n        final File localPath;\n        try (Repository repository = CookbookHelper.createNewRepository()) {\n            localPath = repository.getWorkTree();\n\n            System.out.println(\"Repository at \" + repository.getWorkTree());\n\n            File untrackedFile = File.createTempFile(\"untracked\", \".txt\", repository.getWorkTree());\n            File untrackedDir = File.createTempFile(\"untrackedDir\", \"\", repository.getWorkTree());\n            if(!untrackedDir.delete()) {\n                throw new IOException(\"Could not delete file \" + untrackedDir);\n            }\n            if(!untrackedDir.mkdirs()) {\n                throw new IOException(\"Could not create directory \" + untrackedDir);\n            }\n\n            System.out.println(\"Untracked exists: \" + untrackedFile.exists() + \" Dir: \" + untrackedDir.exists() + \"/\" + untrackedDir.isDirectory());\n\n            try (Git git = new Git(repository)) {\n                Set<String> removed = git.clean().setCleanDirectories(true).call();\n                for(String item : removed) {\n                \tSystem.out.println(\"Removed: \" + item);\n                }\n                System.out.println(\"Removed \" + removed.size() + \" items\");\n            }\n\n            System.out.println(\"Untracked after: \" + untrackedFile.exists() + \" Dir: \" + untrackedDir.exists() + \"/\" + untrackedDir.isDirectory());\n        }\n\n        // clean up here to not keep using more and more disk-space for these samples\n        FileUtils.deleteDirectory(localPath);\n    }",
            "commit_message": "Merge pull request #86 from BulkSecurityGeneratorProjectV2/fix/JLL/temporary_directory_hijacking_or_temporary_directory_information_disclosure\n\n[SECURITY] Fix Temporary Directory Hijacking or Information Disclosure Vulnerability"
        },
        "CWE": "CWE-668",
        "CVE": "CVE-2022-4817"
    },
    {
        "data": {
            "function_name": "unZipIt",
            "function_code": "public static void unZipIt(String resourceName, String outputFolder) {\n\n\t\tbyte[] buffer = new byte[1024];\n\n\t\ttry {\n\t\t\tZipInputStream zis = new ZipInputStream(CreateResources.class.getResourceAsStream(resourceName));\n\t\t\tZipEntry ze = zis.getNextEntry();\n\n\t\t\twhile (ze != null) {\n\t\t\t\tString fileName = ze.getName();\n\t\t\t\tFile newFile = new File(outputFolder + File.separator + fileName);\n\t\t\t\t// System.out.println(\"file unzip : \"+ newFile.getAbsoluteFile());\n\t\t\t\tif (ze.isDirectory()) {\n\t\t\t\t\tString temp = newFile.getAbsolutePath();\n\t\t\t\t\tnew File(temp).mkdirs();\n\t\t\t\t} else {\n\t\t\t\t\tString directory = newFile.getParent();\n\t\t\t\t\tif (directory != null) {\n\t\t\t\t\t\tFile d = new File(directory);\n\t\t\t\t\t\tif (!d.exists()) {\n\t\t\t\t\t\t\td.mkdirs();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFileOutputStream fos = new FileOutputStream(newFile);\n\t\t\t\t\tint len;\n\t\t\t\t\twhile ((len = zis.read(buffer)) > 0) {\n\t\t\t\t\t\tfos.write(buffer, 0, len);\n\t\t\t\t\t}\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t\tze = zis.getNextEntry();\n\t\t\t}\n\n\t\t\tzis.closeEntry();\n\t\t\tzis.close();\n\n\t\t} catch (IOException ex) {\n\t\t\tlogger.error(\"Error while extracting the reosurces: \" + ex.getMessage());\n\t\t}\n\n\t}",
            "commit_message": "vuln-fix: Zip Slip Vulnerability\n\nThis fixes a Zip-Slip vulnerability.\n\nThis change does one of two things. This change either\n\n1. Inserts a guard to protect against Zip Slip.\nOR\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: High\nCVSSS: 7.4\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\n\nCo-authored-by: Moderne <team@moderne.io>"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-4772"
    },
    {
        "data": {
            "function_name": "setNotes",
            "function_code": "public void setNotes(String notes) {\n        this.notes = notes;\n    }",
            "commit_message": "RA1865 - Fixing reflected XSS in the notes section (#39)\n\n* Fixing reflective XSS in the notes section\r\n\r\n* using owasp encoder for HTML encoding\r\n\r\n* Escaping HTML using WebUtil\r\n\r\n* Update api/src/main/java/org/openmrs/module/appointmentscheduling/AppointmentRequest.java\r\n\r\nCo-authored-by: Brandon Istenes <brandonesbox@gmail.com>\r\n\r\n* Update api/src/main/java/org/openmrs/module/appointmentscheduling/AppointmentRequest.java\r\n\r\nCo-authored-by: Brandon Istenes <brandonesbox@gmail.com>\r\n\r\nCo-authored-by: Anupam Devulapalli <anupam.8010@gmail.com>\r\nCo-authored-by: Mark Goodrich <mgoodrich@pih.org>\r\nCo-authored-by: Brandon Istenes <brandonesbox@gmail.com>"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-4727"
    },
    {
        "data": {
            "function_name": "setNotes",
            "function_code": "public void setNotes(String notes) {\n        this.notes = notes;\n    }",
            "commit_message": "RA1865 - Fixing reflected XSS in the notes section (#39)\n\n* Fixing reflective XSS in the notes section\r\n\r\n* using owasp encoder for HTML encoding\r\n\r\n* Escaping HTML using WebUtil\r\n\r\n* Update api/src/main/java/org/openmrs/module/appointmentscheduling/AppointmentRequest.java\r\n\r\nCo-authored-by: Brandon Istenes <brandonesbox@gmail.com>\r\n\r\n* Update api/src/main/java/org/openmrs/module/appointmentscheduling/AppointmentRequest.java\r\n\r\nCo-authored-by: Brandon Istenes <brandonesbox@gmail.com>\r\n\r\nCo-authored-by: Anupam Devulapalli <anupam.8010@gmail.com>\r\nCo-authored-by: Mark Goodrich <mgoodrich@pih.org>\r\nCo-authored-by: Brandon Istenes <brandonesbox@gmail.com>"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2022-4727"
    },
    {
        "data": {
            "function_name": "deployWar",
            "function_code": "public boolean deployWar(File warFile, File deployTarDir) {\n\tString context = warFile.getName();\n\tassert context.toLowerCase().endsWith(DEPLOY_ARCH_EXT);\n\tcontext = context.substring(0, context.length() - DEPLOY_ARCH_EXT.length());\n\tFile failedMark = new File(deployTarDir, context + DEPLOY_FAILED_EXT); \n\tif (failedMark.exists() && failedMark.lastModified() > warFile.lastModified())\n\t    return false; // skipping deploy failed\n\n\tserver.log(\"Deploying \" + context);\n\tZipFile zipFile = null;\n\tFile deployDir = new File(deployTarDir, context);\n\tboolean noincremental = System.getProperty(DEF_DEPLOY_NOINCREMENTAL) != null;\n\tif (assureDir(deployDir) == false) {\n\t    server.log(\"Can't reach deployment dir \" + deployDir);\n\t    return false;\n\t}\n\tException lastException = null;\n\tdeploy: do {\n\t    try {\n\t\t// some overhead didn't check that doesn't exist\n\t\tzipFile = new ZipFile(warFile);\n\t\tEnumeration<? extends ZipEntry> entries = zipFile.entries();\n\t\twhile (entries.hasMoreElements()) {\n\t\t    ZipEntry ze = entries.nextElement();\n\t\t    String en = ze.getName();\n\t\t    if (File.separatorChar == '/')\n\t\t\ten = en.replace('\\\\', File.separatorChar);\n\t\t    File outFile = new File(deployDir, en);\n\t\t    if (ze.isDirectory()) {\n\t\t\toutFile.mkdirs();\n\t\t    } else {\n\t\t\tOutputStream os = null;\n\t\t\tInputStream is = null;\n\t\t\tFile parentFile = outFile.getParentFile();\n\t\t\tif (parentFile.exists() == false)\n\t\t\t    parentFile.mkdirs();\n\t\t\tif (outFile.exists() && outFile.lastModified() >= ze.getTime()) {\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (noincremental) {\n\t\t\t    deleteFiles(deployDir, deployDir.list());\n\t\t\t    noincremental = false;\n\t\t\t    continue deploy;\n\t\t\t}\n\t\t\ttry {\n\t\t\t    os = new FileOutputStream(outFile);\n\t\t\t    is = zipFile.getInputStream(ze);\n\t\t\t    copyStream(is, os);\n\t\t\t} catch (IOException ioe2) {\n\t\t\t    server.log(\"Problem in extracting \" + en + \" \" + ioe2);\t\t\t    \n\t\t\t    // TODO decide to propagate the exception up and stop deployment?\n\t\t\t    lastException = ioe2;\n\t\t\t} finally {\n\t\t\t    try {\n\t\t\t\tos.close();\n\t\t\t    } catch (Exception e2) {\n\n\t\t\t    }\n\t\t\t    try {\n\t\t\t\tis.close();\n\t\t\t    } catch (Exception e2) {\n\n\t\t\t    }\n\t\t\t}\n\t\t\toutFile.setLastModified(ze.getTime());\n\t\t    }\n\t\t}\n\t    } catch (ZipException ze) {\n\t\tserver.log(\"Invalid .war format\");\n\t\tlastException = ze;\n\t    } catch (IOException ioe) {\n\t\tserver.log(\"Can't read \" + warFile + \"/ \" + ioe);\n\t\tlastException = ioe;\n\t    } finally {\n\t\ttry {\n\t\t    zipFile.close();\n\t\t} catch (Exception e) {\n\n\t\t}\n\t\tzipFile = null;\n\t    }\n\t} while (false);\n\tif (lastException == null) {\n\t\tdeployDir.setLastModified(warFile.lastModified());\n\t\treturn true;\n\t} \n\tdeployDir.setLastModified(0);\n\treturn false;\n    }",
            "commit_message": "the a Path Traversal vulnerability reported by Google"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-4594"
    },
    {
        "data": {
            "function_name": "unpackJar",
            "function_code": "public static void unpackJar(File fjar, File fout) throws IOException {\n    \n      JarFile jf = new JarFile(fjar);\n      Enumeration<JarEntry> en = jf.entries();\n\n      while (en.hasMoreElements()) {\n         JarEntry je = en.nextElement();\n         java.io.File f = new File(fout,  je.getName());\n         if (je.isDirectory()) {\n            f.mkdirs();\n            continue;\n\n         } else {\n            // f.getParentFile().mkdirs();\n\n            if (f.getPath().indexOf(\"META-INF\") >= 0) {\n               // skip it\n            } else {\n            f.getParentFile().mkdirs();\n            java.io.InputStream is = jf.getInputStream(je);\n            java.io.FileOutputStream fos = new FileOutputStream(f);\n\n            // EFF - buffering, file channels??\n            while (is.available() > 0) {\n               fos.write(is.read());\n            }\n            fos.close();\n            is.close();\n         }\n         }\n      }\n\n    //  E.info(\"unpacked jar to \" + fout);\n\n       \n   }",
            "commit_message": "vuln-fix: Zip Slip Vulnerability\n\nThis fixes a Zip-Slip vulnerability.\n\nThis change does one of two things. This change either\n\n1. Inserts a guard to protect against Zip Slip.\nOR\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: High\nCVSSS: 7.4\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\n\nCo-authored-by: Moderne <team@moderne.io>"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-4583"
    },
    {
        "data": {
            "function_name": "feed",
            "function_code": "plicationException {\n        StringBuffer xml = new StringBuffer();\n        String finded = \"\";\n        String[] keywords;\n        boolean noResult = true;\n\n        int page = 1, pageSize = 20, startIndex = (page - 1) * pageSize;\n        if (this.request.getParameter(\"page\") == null\n                || this.request.getParameter(\"page\").toString().trim().length() <= 0) {\n            page = 1;\n        } else {\n            page = Integer.parseInt(this.request.getParameter(\"page\").toString());\n        }\n\n        if (query.trim().length() > 0) {\n            keywords = query.split(\" \");\n        } else {\n            return \"<result>Error</result>\";\n        }\n\n        String condition = \"\";\n        for (int i = 0; i < keywords.length; i++) {\n            if (condition.trim().length() == 0) {\n                condition = \" content like '%\" + keywords[i] + \"%' \";\n            } else {\n                condition += \" or content like '%\" + keywords[i] + \"%' \";\n            }\n        }\n\n        String SQL = \"SELECT a.*,b.book_name FROM bible as a left join book as b on a.book_id=b.book_id where \"\n                + condition\n                + \" order by a.book_id,a.chapter_id limit \"\n                + startIndex\n                + \",\" + pageSize;\n        // String look = \"SELECT FOUND_ROWS() AS size\";\n\n        bible bible = new bible();\n        Table vtable = bible.find(SQL, new Object[]{});\n        noResult = vtable.size() > 0;\n\n        /*\n         * Row found=bible.findOne(look, new Object[]{});\n         *\n         * Pager pager = new Pager(); pager.pageSize = pageSize; pager.currentPage =\n         * page; pager.size=found.getFieldInfo(\"size\").intValue();\n         * pager.setListSize(vtable.size());\n         */\n\n        Field field;\n        int next = startIndex + 1;// \u6b64\u4f4d\u7f6e\u5373\u4e3a\u5f53\u524d\u9875\u7684\u7b2c\u4e00\u6761\u8bb0\u5f55\u7684ID\n\n        for (Enumeration<Row> table = vtable.elements(); table.hasMoreElements(); ) {\n            Row row = table.nextElement();\n            Iterator<Field> iterator = row.iterator();\n\n            while (iterator.hasNext()) {\n                field = iterator.next();\n                finded = field.get(\"content\").value().toString();\n\n                for (int j = 0; j < keywords.length; j++) {\n                    finded = StringUtilities.sign(finded, keywords[j]);\n                }\n\n                xml.append(\"<item id=\\\"\" + next + \"\\\" chapterid=\\\"\"\n                        + field.get(\"chapter_id\").value().toString() + \"\\\" bookid=\\\"\"\n                        + field.get(\"book_id\").value().toString() + \"\\\" \"\n                        + field.get(\"book_name\").value().toString() + \" partid=\\\"\"\n                        + field.get(\"part_id\").value().toString() + \"\\\">\" + finded\n                        + \"</item>\\r\\n\");\n                next++;\n            }\n        }\n\n        for (int k = 0; k < keywords.length && noResult; k++) {\n            keyword keyword = new keyword();\n            keyword.setKeyword(keywords[k]);\n            Row findRow = keyword.findOne(\n                    \"SELECT id,visit FROM keyword WHERE keyword='\" + keywords[k] + \"'\",\n                    new Object[]{});\n\n            if (findRow.size() == 0) {\n                keyword.setVisit(0);\n                keyword.append();\n            } else {\n                keyword.setId(findRow.getFieldInfo(\"id\"));\n                keyword.setVisit(findRow.getFieldInfo(\"visit\").intValue() + 1);\n                keyword.update();\n            }\n        }\n\n        return xml.toString();\n    }\n\n    public Object advanced(String query) throws ApplicationException {",
            "commit_message": "Fixed the SQL Injection issue."
        },
        "CWE": "CWE-707",
        "CVE": "CVE-2022-4454"
    },
    {
        "data": {
            "function_name": "setObject",
            "function_code": "@Override\n    public T setObject(K name, Object value) {\n        V convertedValue = checkNotNull(fromObject(name, value), \"convertedValue\");\n        return set(name, convertedValue);\n    }",
            "commit_message": "Merge pull request from GHSA-hh82-3pmq-7frp\n\nMotivation:\nThe setObject methods that took arrays and iterators as arguments provided a way to bypass value validation.\n\nModification:\nAdd the missing value validation checks.\n\nResult:\nIt is no longer possibel to bypass value validation in DefaultHeaders based implementations, including DefaultHttpHeaders."
        },
        "CWE": "CWE-113",
        "CVE": "CVE-2022-41915"
    },
    {
        "data": {
            "function_name": "setObject",
            "function_code": "@Override\n    public T setObject(K name, Object value) {\n        V convertedValue = checkNotNull(fromObject(name, value), \"convertedValue\");\n        return set(name, convertedValue);\n    }",
            "commit_message": "Merge pull request from GHSA-hh82-3pmq-7frp\n\nMotivation:\nThe setObject methods that took arrays and iterators as arguments provided a way to bypass value validation.\n\nModification:\nAdd the missing value validation checks.\n\nResult:\nIt is no longer possibel to bypass value validation in DefaultHeaders based implementations, including DefaultHttpHeaders."
        },
        "CWE": "CWE-113",
        "CVE": "CVE-2022-41915"
    },
    {
        "data": {
            "function_name": "setObject",
            "function_code": "@Override\n    public T setObject(K name, Object value) {\n        V convertedValue = checkNotNull(fromObject(name, value), \"convertedValue\");\n        return set(name, convertedValue);\n    }",
            "commit_message": "Merge pull request from GHSA-hh82-3pmq-7frp\n\nMotivation:\nThe setObject methods that took arrays and iterators as arguments provided a way to bypass value validation.\n\nModification:\nAdd the missing value validation checks.\n\nResult:\nIt is no longer possibel to bypass value validation in DefaultHeaders based implementations, including DefaultHttpHeaders."
        },
        "CWE": "CWE-113",
        "CVE": "CVE-2022-41915"
    },
    {
        "data": {
            "function_name": "getLoginUrl",
            "function_code": "@Override\n    public String getLoginUrl() {\n        return \"securityRealm/commenceLogin\";\n    }",
            "commit_message": "[SECURITY-2982] fix session fixation vulnerability\n\nhttps://issues.jenkins.io/browse/SECURITY-2982"
        },
        "CWE": "CWE-384",
        "CVE": "CVE-2023-24427"
    },
    {
        "data": {
            "function_name": "getLoginUrl",
            "function_code": "@Override\n    public String getLoginUrl() {\n        return \"securityRealm/commenceLogin\";\n    }",
            "commit_message": "[SECURITY-2982] fix session fixation vulnerability\n\nhttps://issues.jenkins.io/browse/SECURITY-2982"
        },
        "CWE": "CWE-613",
        "CVE": "CVE-2023-24426"
    },
    {
        "data": {
            "function_name": "getLoginUrl",
            "function_code": "@Override\n    public String getLoginUrl() {\n        return \"securityRealm/commenceLogin\";\n    }",
            "commit_message": "[SECURITY-2982] fix session fixation vulnerability\n\nhttps://issues.jenkins.io/browse/SECURITY-2982"
        },
        "CWE": "CWE-384",
        "CVE": "CVE-2023-24427"
    },
    {
        "data": {
            "function_name": "getLoginUrl",
            "function_code": "@Override\n    public String getLoginUrl() {\n        return \"securityRealm/commenceLogin\";\n    }",
            "commit_message": "[SECURITY-2982] fix session fixation vulnerability\n\nhttps://issues.jenkins.io/browse/SECURITY-2982"
        },
        "CWE": "CWE-613",
        "CVE": "CVE-2023-24426"
    },
    {
        "data": {
            "function_name": "execute",
            "function_code": "public void execute(Transaction t) throws SQLException {\n\t\t\t//Statement st = t.getConnection().createStatement();\n\t\t\tStatement st = t.getConnection().prepareStatement(query, variables);\n\t\t\ttry {\n\t\t\t\tResultSet rs = st.executeQuery(query);\n\t\t\t\tResultSetMetaData metaData = rs.getMetaData();\n\t\t\t\twhile (rs.next()) {\n\t\t\t\t\tMap map = new HashMap();\n\t\t\t\t\tfor (int i = 0; i < metaData.getColumnCount(); i++) {\n\t\t\t\t\t\tmap.put(metaData.getColumnLabel(i + 1), rs.getString(i + 1));\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(map);\n\t\t\t\t}\n\t        } finally {\n\t            st.close();\n\t        }\n\t\t}",
            "commit_message": "Prevent SQL-injection"
        },
        "CWE": "CWE-89",
        "CVE": "CVE-2013-10013"
    },
    {
        "data": {
            "function_name": "getAllRealOraclePackage",
            "function_code": "private List<OraclePackage> getAllRealOraclePackage(OBridgeConfiguration c) {\n        String query = \"select object_name from user_objects where object_type = 'PACKAGE' and object_name like '\" + c.getPackagesLike() + \"'\";\n        return jdbcTemplate.query(query, (resultSet, i) -> {\n            OraclePackage p = new OraclePackage();\n            p.setName(resultSet.getString(\"object_name\"));\n            p.setProcedureList(getAllProcedure(resultSet.getString(\"object_name\"), \"\"));\n            return p;\n        });\n    }",
            "commit_message": "sql injection fix."
        },
        "CWE": "CWE-89",
        "CVE": "CVE-2018-25075"
    },
    {
        "data": {
            "function_name": "getTeachersWithoutClass",
            "function_code": "public ArrayList<Pair<Integer,String> > getTeachersWithoutClass() {\n                ArrayList<Pair<Integer,String> > teachers = new ArrayList<Pair<Integer,String> >();\n                try {\n                        stmt = c.createStatement();\n                        ResultSet rs = stmt.executeQuery(\"SELECT imie,nazwisko,id from (SELECT imie,nazwisko,n.id,id_wychowawcy from nauczyciele n left join klasy k on n.id=k.id_wychowawcy) f where id_wychowawcy is null;\");\n                        while (rs.next()) {\n                                Pair<Integer,String> pair = new Pair<Integer, String>(rs.getInt(\"id\"),rs.getString(\"imie\")+\" \"+rs.getString(\"nazwisko\"));\n                               // System.out.println(pair.getX()+\" \"+pair.getY());\n                                teachers.add(pair);\n                        }\n//                        System.out.println(\"success\");\n                        rs.close();\n                        stmt.close();\n                } catch (Exception e) {\n                        e.printStackTrace();\n                        System.err.println(e.getClass().getName() + \": \" + e.getMessage());\n                }\n                return teachers;\n        }",
            "commit_message": "fuck sql injection"
        },
        "CWE": "CWE-89",
        "CVE": "CVE-2015-10047"
    },
    {
        "data": {
            "function_name": "setAttributes",
            "function_code": "@Override\n        public void setAttributes(Node node, String tagName, Map<String, String> attributes) {\n            if (node instanceof Link) {\n                Link l = (Link) node;\n                String destination = StringUtils.trimToEmpty(l.getDestination());\n                if (UrlUtils.isAbsoluteUrl(destination)) {\n                    attributes.put(\"target\", \"_blank\");\n                    attributes.put(\"rel\", \"nofollow noopener noreferrer\");\n                    var newTabLabel = A11Y_NEW_TAB_LABEL.get();\n                    if (newTabLabel != null) {\n                        attributes.put(\"aria-label\", ((Text)node.getFirstChild()).getLiteral() + \" \" + newTabLabel);\n                    }\n                }\n            }\n        }",
            "commit_message": "restrict protocols (#1150)"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2023-0301"
    },
    {
        "data": {
            "function_name": "verifyRedirectUri",
            "function_code": "public static String verifyRedirectUri(KeycloakSession session, String redirectUri, ClientModel client) {\n        return verifyRedirectUri(session, redirectUri, client, true);\n    }",
            "commit_message": "Avoid path traversal vis double-url encoding of redirect URI (#8)\n\n(cherry picked from commit a2128fb9e940d96c2f9a64edcd4fbcc768eedb4f)"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-3782"
    },
    {
        "data": {
            "function_name": "verifyRedirectUri",
            "function_code": "public static String verifyRedirectUri(KeycloakSession session, String redirectUri, ClientModel client) {\n        return verifyRedirectUri(session, redirectUri, client, true);\n    }",
            "commit_message": "Avoid path traversal vis double-url encoding of redirect URI (#8)\n\n(cherry picked from commit a2128fb9e940d96c2f9a64edcd4fbcc768eedb4f)"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-3782"
    },
    {
        "data": {
            "function_name": "createTmpDir",
            "function_code": "rivate String createTmpDir() {\n\t\ttry {\n\t\t\tFile tmp = File.createTempFile(\"fileresourcemanager\", null);\n\t\t\ttmp.delete();\n\t\t\ttmp.mkdir();\n\t\t\tString workDir = tmp.getAbsolutePath();\n\t\t\treturn workDir;\n\t\t} catch (IOException e) {\n\t\t\tthrow log.errorCreateWorkDir(e);\n\t\t}\n\t}\n",
            "commit_message": "Feature #4100 Fix critical Vulnerability\n\n\"File.createTempFile\" should not be used to create a directory"
        },
        "CWE": "CWE-668",
        "CVE": "CVE-2018-25068"
    },
    {
        "data": {
            "function_name": "unzip",
            "function_code": "public static File unzip(File fileToUnzip, File destDir) throws IOException {\n        FileUtils.deleteQuietly(destDir);\n        IOUtils.createDir(destDir);\n        destDir.deleteOnExit();\n\n        File file;\n        ZipFile zipFile = new ZipFile(fileToUnzip);\n        Enumeration<?> zipEnumeration = zipFile.entries();\n        while (zipEnumeration.hasMoreElements()) {\n            ZipEntry zipEntry = (ZipEntry) zipEnumeration.nextElement();\n            String fileName = zipEntry.getName();\n            file = new File(destDir, fileName);\n            if (fileName.endsWith(ZIP_FILE_SEPARATOR)) {\n                file.mkdirs();\n                continue;\n            }\n\n            File parent = file.getParentFile();\n            if (parent != null) {\n                parent.mkdirs();\n            }\n\n            InputStream inputStream = zipFile.getInputStream(zipEntry);\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            byte[] bytes = new byte[BUFFER_SIZE];\n            int length;\n            while ((length = inputStream.read(bytes)) >= 0) {\n                fileOutputStream.write(bytes, 0, length);\n            }\n            inputStream.close();\n            fileOutputStream.close();\n        }\n        zipFile.close();\n        return destDir;\n    }",
            "commit_message": "ZipUtil.java - check for path traversal attack"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2022-4878"
    },
    {
        "data": {
            "function_name": "configureProxy",
            "function_code": "private void configureProxy() {\n        saveProxyConfiguration = saveProxyConfiguration();\n        final String host = (String) getInputParameter(PROXY_HOST);\n        if (host == null || host.isEmpty()) {\n            return;\n        }\n        LOGGER.info(PROXY_HOST + \" \" + host);\n        final String protocol = (String) getInputParameter(PROXY_PROTOCOL);\n        LOGGER.info(PROXY_PROTOCOL + \" \" + protocol);\n        final String port = (String) getInputParameter(PROXY_PORT);\n        LOGGER.info(PROXY_PORT + \" \" + port);\n\n        if (SOCKS.equals(protocol)) {\n            System.setProperty(\"socksProxyHost\", host);\n            LOGGER.info(\"Setting environment variable: socksProxyHost=\" + host);\n            System.setProperty(\"socksProxyPort\", port);\n            LOGGER.info(\"Setting environment variable: socksProxyPort=\" + port);\n        } else {\n            final String hostKey = String.format(\"%s.proxyHost\", protocol.toLowerCase());\n            System.setProperty(hostKey, host);\n            LOGGER.info(\"Setting environment variable: \" + hostKey + \"=\" + host);\n            final String portKey = String.format(\"%s.proxyPort\", protocol.toLowerCase());\n            System.setProperty(portKey, port);\n            LOGGER.info(\"Setting environment variable: \" + portKey + \"=\" + port);\n        }\n\n        final String user = (String) getInputParameter(PROXY_USER);\n        LOGGER.info(PROXY_USER + \" \" + user);\n        final String password = (String) getInputParameter(PROXY_PASSWORD);\n        LOGGER.info(PROXY_PASSWORD + \" ********\");\n        if (user != null && !user.isEmpty()) {\n            Authenticator.setDefault(new Authenticator() {\n\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(user,\n                            password != null ? password.toCharArray() : \"\".toCharArray());\n                }\n\n            });\n        }\n\n    }",
            "commit_message": "fix(vulnerabilities): fix XXE attacks vulnerabilities and other code smell (#17)\n\n* Access to external entities and network access should always be\r\ndisable to avoid XXS attacks vulnerabilities.\r\n* Log error properly\r\n* refactor logger name to be compliant with java naming conventions"
        },
        "CWE": "CWE-611",
        "CVE": "CVE-2020-36640"
    },
    {
        "data": {
            "function_name": "isReadable",
            "function_code": "@Override\n    public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return File.class == type;\n    }",
            "commit_message": "Use newer API for creating tmp files in RESTEasy Reactive"
        },
        "CWE": "CWE-668",
        "CVE": "CVE-2023-0481"
    },
    {
        "data": {
            "function_name": "doGetIdentity",
            "function_code": "@Override\n    protected KrbIdentity doGetIdentity(String principalName) throws KrbException {\n        KrbIdentity krbIdentity = new KrbIdentity(principalName);\n        String searchFilter =\n            String.format(\"(&(objectclass=krb5principal)(krb5PrincipalName=%s))\", principalName);\n        try {\n            EntryCursor cursor = new FailoverInvocationHandler<EntryCursor>() {\n                @Override\n                public EntryCursor execute() throws LdapException {\n                    return connection.search(getConfig().getString(\"base_dn\"), searchFilter,\n                        SearchScope.SUBTREE, \"dn\");\n                }\n            }.run();\n\n            // there should be at most one entry with this principal name\n            if (cursor == null || !cursor.next()) {\n                return null;\n            }\n            Dn dn = cursor.get().getDn();\n            cursor.close();\n\n            Entry entry = new FailoverInvocationHandler<Entry>() {\n                @Override\n                public Entry execute() throws LdapException {\n                    return connection.lookup(dn, \"*\", \"+\");\n                }\n            }.run();\n            if (entry == null) {\n                return null;\n            }\n\n            LdapIdentityGetHelper getHelper = new LdapIdentityGetHelper(entry);\n            krbIdentity.setPrincipal(getHelper.getPrincipalName());\n            krbIdentity.setKeyVersion(getHelper.getKeyVersion());\n            krbIdentity.addKeys(getHelper.getKeys());\n            krbIdentity.setCreatedTime(getHelper.getCreatedTime());\n            krbIdentity.setExpireTime(getHelper.getExpireTime());\n            krbIdentity.setDisabled(getHelper.getDisabled());\n            krbIdentity.setKdcFlags(getHelper.getKdcFlags());\n            krbIdentity.setLocked(getHelper.getLocked());\n        } catch (LdapException e) {\n            throw new KrbException(\"Failed to retrieve identity\", e);\n        } catch (CursorException e) {\n            throw new KrbException(\"Failed to retrieve identity\", e);\n        } catch (ParseException e) {\n            throw new KrbException(\"Failed to retrieve identity\", e);\n        } catch (IOException e) {\n            throw new KrbException(\"Failed to retrieve identity\", e);\n        }\n\n        return krbIdentity;\n    }",
            "commit_message": "Using FilterBuilder in the LdapIdentityBackend"
        },
        "CWE": "CWE-74",
        "CVE": "CVE-2023-25613"
    },
    {
        "data": {
            "function_name": "validate",
            "function_code": "@Override\n  public void validate(final OidcCredentials credentials, final WebContext context) {\n    final AuthorizationCode code = credentials.getCode();\n    // if we have a code\n    if (code != null) {\n      try {\n        final String computedCallbackUrl = client.computeFinalCallbackUrl(context);\n        // Token request\n        final TokenRequest request = createTokenRequest(new AuthorizationCodeGrant(code, new URI(computedCallbackUrl)));\n        HTTPRequest tokenHttpRequest = request.toHTTPRequest();\n        tokenHttpRequest.setConnectTimeout(configuration.getConnectTimeout());\n        tokenHttpRequest.setReadTimeout(configuration.getReadTimeout());\n\n        final HTTPResponse httpResponse = tokenHttpRequest.send();\n        logger.debug(\"Token response: status={}, content={}\", httpResponse.getStatusCode(),\n            httpResponse.getContent());\n\n        final TokenResponse response = OIDCTokenResponseParser.parse(httpResponse);\n        if (response instanceof TokenErrorResponse) {\n          throw new TechnicalException(\"Bad token response, error=\" + ((TokenErrorResponse) response).getErrorObject());\n        }\n        logger.debug(\"Token response successful\");\n        final OIDCTokenResponse tokenSuccessResponse = (OIDCTokenResponse) response;\n\n        // save tokens in credentials\n        final OIDCTokens oidcTokens = tokenSuccessResponse.getOIDCTokens();\n        credentials.setAccessToken(oidcTokens.getAccessToken());\n        credentials.setRefreshToken(oidcTokens.getRefreshToken());\n        credentials.setIdToken(oidcTokens.getIDToken());\n\n      } catch (final URISyntaxException | IOException | ParseException e) {\n        throw new TechnicalException(e);\n      }\n    }\n  }",
            "commit_message": "fix(pac4j-oidc): add verifier parameter (#6835)\n\n* fix(pac4j-oidc): add verifier parameter"
        },
        "CWE": "CWE-502",
        "CVE": "CVE-2023-25558"
    },
    {
        "data": {
            "function_name": "createTag",
            "function_code": "public Tag createTag(ShaarliAccount masterAccount, String value) {\n        Tag tag = new Tag();\n        tag.setMasterAccount(masterAccount);\n        tag.setValue(value.trim());\n\n        ContentValues values = new ContentValues();\n        values.put(MySQLiteHelper.TAGS_COLUMN_ID_ACCOUNT, masterAccount.getId());\n        values.put(MySQLiteHelper.TAGS_COLUMN_TAG, tag.getValue());\n\n        // If existing, do nothing :\n        Cursor cursor = db.query(MySQLiteHelper.TABLE_TAGS, allColumns,\n                MySQLiteHelper.TAGS_COLUMN_ID_ACCOUNT + \" = \" + tag.getMasterAccountId() + \" AND \" +\n                        MySQLiteHelper.TAGS_COLUMN_TAG + \" = '\" + tag.getValue() + \"'\",\n                null, null, null, null);\n        try {\n            cursor.moveToFirst();\n            if (cursor.isAfterLast()) {\n                long insertId = db.insert(MySQLiteHelper.TABLE_TAGS, null, values);\n                tag.setId(insertId);\n                return tag;\n            } else {\n                tag = cursorToTag(cursor);\n            }\n        } catch (Exception e){\n            tag = null;\n        } finally {\n            cursor.close();\n        }\n        return tag;\n    }",
            "commit_message": "Solve bug with tags (possible sql injection)"
        },
        "CWE": "CWE-89",
        "CVE": "CVE-2015-10076"
    },
    {
        "data": {
            "function_name": "pathOffset",
            "function_code": "public static String pathOffset(String path, RoutingContext context) {\n    final Route route = context.currentRoute();\n\n    // cannot make any assumptions\n    if (route == null) {\n      return path;\n    }\n\n    if (!route.isExactPath()) {\n      final String rest = context.pathParam(\"*\");\n      if (rest != null) {\n        // normalize\n        if (rest.length() > 0) {\n          if (rest.charAt(0) == '/') {\n            return rest;\n          } else {\n            return \"/\" + rest;\n          }\n        } else {\n          return \"/\";\n        }\n      }\n    }\n    int prefixLen = 0;\n    String mountPoint = context.mountPoint();\n    if (mountPoint != null) {\n      prefixLen = mountPoint.length();\n      // special case we need to verify if a trailing slash  is present and exclude\n      if (mountPoint.charAt(mountPoint.length() - 1) == '/') {\n        prefixLen--;\n      }\n    }\n    // we can only safely skip the route path if there are no variables or regex\n    if (!route.isRegexPath()) {\n      String routePath = route.getPath();\n      if (routePath != null) {\n        prefixLen += routePath.length();\n        // special case we need to verify if a trailing slash  is present and exclude\n        if (routePath.charAt(routePath.length() - 1) == '/') {\n          prefixLen--;\n        }\n      }\n    }\n    return prefixLen != 0 ? path.substring(prefixLen) : path;\n  }",
            "commit_message": "Fix the webroot escape to classpath on windows\n\nSigned-off-by: Paulo Lopes <pmlopes@gmail.com>"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2023-24815"
    },
    {
        "data": {
            "function_name": "updateButtons",
            "function_code": "protected void updateButtons(AjaxRequestTarget target) {\n\t\tCollection<User> recpnts = recipients.getModelObject();\n\t\ttarget.add(\n\t\t\t\tdialog.getSend().setEnabled(!recpnts.isEmpty())\n\t\t\t\t, dialog.getGenerate().setEnabled(recpnts.size() == 1)\n\t\t\t\t);\n\t}",
            "commit_message": "[OPENMEETINGS-2739] generate URL is disabled if non-contact is selected"
        },
        "CWE": "CWE-306",
        "CVE": "CVE-2023-28326"
    },
    {
        "data": {
            "function_name": "validateSQLInput",
            "function_code": "public static void validateSQLInput(final String sqlSearch) {\n        if (StringUtils.isBlank(sqlSearch)) {\n            return;\n        }\n        String lowerCaseSQL = sqlSearch.toLowerCase();\n        for (String ddl : DDL_COMMANDS) {\n            if (lowerCaseSQL.contains(ddl)) {\n                throw new SQLInjectionException();\n            }\n        }\n\n        for (String dml : DML_COMMANDS) {\n            if (lowerCaseSQL.contains(dml)) {\n                throw new SQLInjectionException();\n            }\n        }\n\n        for (String comments : COMMENTS) {\n            if (lowerCaseSQL.contains(comments)) {\n                throw new SQLInjectionException();\n            }\n        }\n\n        // Removing the space before and after '=' operator\n        // String s = \" \\\" OR 1 = 1\"; For the cases like this\n        boolean injectionFound = false;\n        String inputSqlString = lowerCaseSQL;\n        while (inputSqlString.indexOf(\" =\") > 0) { // Don't remove space before\n                                                   // = operator\n            inputSqlString = inputSqlString.replaceAll(\" =\", \"=\");\n        }\n\n        while (inputSqlString.indexOf(\"= \") > 0) { // Don't remove space after =\n                                                   // operator\n            inputSqlString = inputSqlString.replaceAll(\"= \", \"=\");\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(inputSqlString, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            String token = tokenizer.nextToken().trim();\n            if (token.equals(\"'\")) {\n                if (tokenizer.hasMoreElements()) {\n                    String nextToken = tokenizer.nextToken().trim();\n                    if (!nextToken.equals(\"'\")) {\n                        injectionFound = true;\n                        break;\n                    }\n                } else {\n                    injectionFound = true;\n                    break;\n                }\n            }\n            if (token.equals(\"\\\"\")) {\n                if (tokenizer.hasMoreElements()) {\n                    String nextToken = tokenizer.nextToken().trim();\n                    if (!nextToken.equals(\"\\\"\")) {\n                        injectionFound = true;\n                        break;\n                    }\n                } else {\n                    injectionFound = true;\n                    break;\n                }\n            } else if (token.indexOf('=') > 0) {\n                StringTokenizer operatorToken = new StringTokenizer(token, \"=\");\n                String operand = operatorToken.nextToken().trim();\n                if (!operatorToken.hasMoreTokens()) {\n                    injectionFound = true;\n                    break;\n                }\n                String value = operatorToken.nextToken().trim();\n                if (operand.equals(value)) {\n                    injectionFound = true;\n                    break;\n                }\n            }\n        }\n        if (injectionFound) {\n            throw new SQLInjectionException();\n        }\n\n        Pattern pattern = Pattern.compile(SQL_PATTERN);\n        Matcher matcher = pattern.matcher(sqlSearch);\n        if (!matcher.matches()) {\n            throw new SQLInjectionException();\n        }\n    }",
            "commit_message": "FINERACT-1871: Run reports fix for 1.7.x"
        },
        "CWE": "CWE-89",
        "CVE": "CVE-2023-25197"
    },
    {
        "data": {
            "function_name": "validateSQLInput",
            "function_code": "public static void validateSQLInput(final String sqlSearch) {\n        if (StringUtils.isBlank(sqlSearch)) {\n            return;\n        }\n        String lowerCaseSQL = sqlSearch.toLowerCase();\n        for (String ddl : DDL_COMMANDS) {\n            if (lowerCaseSQL.contains(ddl)) {\n                throw new SQLInjectionException();\n            }\n        }\n\n        for (String dml : DML_COMMANDS) {\n            if (lowerCaseSQL.contains(dml)) {\n                throw new SQLInjectionException();\n            }\n        }\n\n        for (String comments : COMMENTS) {\n            if (lowerCaseSQL.contains(comments)) {\n                throw new SQLInjectionException();\n            }\n        }\n\n        // Removing the space before and after '=' operator\n        // String s = \" \\\" OR 1 = 1\"; For the cases like this\n        boolean injectionFound = false;\n        String inputSqlString = lowerCaseSQL;\n        while (inputSqlString.indexOf(\" =\") > 0) { // Don't remove space before\n                                                   // = operator\n            inputSqlString = inputSqlString.replaceAll(\" =\", \"=\");\n        }\n\n        while (inputSqlString.indexOf(\"= \") > 0) { // Don't remove space after =\n                                                   // operator\n            inputSqlString = inputSqlString.replaceAll(\"= \", \"=\");\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(inputSqlString, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            String token = tokenizer.nextToken().trim();\n            if (token.equals(\"'\")) {\n                if (tokenizer.hasMoreElements()) {\n                    String nextToken = tokenizer.nextToken().trim();\n                    if (!nextToken.equals(\"'\")) {\n                        injectionFound = true;\n                        break;\n                    }\n                } else {\n                    injectionFound = true;\n                    break;\n                }\n            }\n            if (token.equals(\"\\\"\")) {\n                if (tokenizer.hasMoreElements()) {\n                    String nextToken = tokenizer.nextToken().trim();\n                    if (!nextToken.equals(\"\\\"\")) {\n                        injectionFound = true;\n                        break;\n                    }\n                } else {\n                    injectionFound = true;\n                    break;\n                }\n            } else if (token.indexOf('=') > 0) {\n                StringTokenizer operatorToken = new StringTokenizer(token, \"=\");\n                String operand = operatorToken.nextToken().trim();\n                if (!operatorToken.hasMoreTokens()) {\n                    injectionFound = true;\n                    break;\n                }\n                String value = operatorToken.nextToken().trim();\n                if (operand.equals(value)) {\n                    injectionFound = true;\n                    break;\n                }\n            }\n        }\n        if (injectionFound) {\n            throw new SQLInjectionException();\n        }\n\n        Pattern pattern = Pattern.compile(SQL_PATTERN);\n        Matcher matcher = pattern.matcher(sqlSearch);\n        if (!matcher.matches()) {\n            throw new SQLInjectionException();\n        }\n    }",
            "commit_message": "FINERACT-1871: Run reports fix for 1.7.x"
        },
        "CWE": "CWE-89",
        "CVE": "CVE-2023-25197"
    },
    {
        "data": {
            "function_name": "doPluginsSearch",
            "function_code": "@Restricted(NoExternalUse.class)\n    public HttpResponse doPluginsSearch(@QueryParameter String query, @QueryParameter Integer limit) {\n        List<JSONObject> plugins = new ArrayList<>();\n        for (UpdateSite site : Jenkins.get().getUpdateCenter().getSiteList()) {\n            List<JSONObject> sitePlugins = site.getAvailables().stream()\n                .filter(plugin -> {\n                    if (StringUtils.isBlank(query)) {\n                        return true;\n                    }\n                    return StringUtils.containsIgnoreCase(plugin.name, query) ||\n                        StringUtils.containsIgnoreCase(plugin.title, query) ||\n                        StringUtils.containsIgnoreCase(plugin.excerpt, query) ||\n                        plugin.hasCategory(query) ||\n                        plugin.getCategoriesStream()\n                            .map(UpdateCenter::getCategoryDisplayName)\n                            .anyMatch(category -> StringUtils.containsIgnoreCase(category, query)) ||\n                        plugin.hasWarnings() && query.equalsIgnoreCase(\"warning:\");\n                })\n                .limit(Math.max(limit - plugins.size(), 1))\n                .sorted((o1, o2) -> {\n                    String o1DisplayName = o1.getDisplayName();\n                    if (o1.name.equalsIgnoreCase(query) ||\n                        o1DisplayName.equalsIgnoreCase(query)) {\n                        return -1;\n                    }\n                    String o2DisplayName = o2.getDisplayName();\n                    if (o2.name.equalsIgnoreCase(query) || o2DisplayName.equalsIgnoreCase(query)) {\n                        return 1;\n                    }\n                    if (o1.name.equals(o2.name)) {\n                        return 0;\n                    }\n                    final int pop = Double.compare(o2.popularity, o1.popularity);\n                    if (pop != 0) {\n                        return pop; // highest popularity first\n                    }\n                    return o1DisplayName.compareTo(o2DisplayName);\n                })\n                .map(plugin -> {\n                    JSONObject jsonObject = new JSONObject();\n                    jsonObject.put(\"name\", plugin.name);\n                    jsonObject.put(\"sourceId\", plugin.sourceId);\n                    jsonObject.put(\"title\", plugin.title);\n                    jsonObject.put(\"displayName\", plugin.getDisplayName());\n                    jsonObject.put(\"wiki\", plugin.wiki);\n                    jsonObject.put(\"categories\", plugin.getCategoriesStream()\n                        .filter(PluginManager::isNonMetaLabel)\n                        .map(UpdateCenter::getCategoryDisplayName)\n                        .collect(toList())\n                    );\n\n                    if (hasAdoptThisPluginLabel(plugin)) {\n                        jsonObject.put(\"adoptMe\", Messages.PluginManager_adoptThisPlugin());\n                    }\n                    if (plugin.isDeprecated()) {\n                        jsonObject.put(\"deprecated\", Messages.PluginManager_deprecationWarning(plugin.getDeprecation().url));\n                    }\n                    jsonObject.put(\"excerpt\", plugin.excerpt);\n                    jsonObject.put(\"version\", plugin.version);\n                    jsonObject.put(\"popularity\", plugin.popularity);\n                    if (plugin.isForNewerHudson()) {\n                        jsonObject.put(\"newerCoreRequired\", Messages.PluginManager_coreWarning(plugin.requiredCore));\n                    }\n                    if (plugin.hasWarnings()) {\n                        JSONObject unresolvedSecurityWarnings = new JSONObject();\n                        unresolvedSecurityWarnings.put(\"text\", Messages.PluginManager_securityWarning());\n                        Set<UpdateSite.Warning> pluginWarnings = plugin.getWarnings();\n                        if (pluginWarnings == null) {\n                            throw new IllegalStateException(\"warnings cannot be null here\");\n                        }\n                        List<JSONObject> warnings = pluginWarnings.stream()\n                            .map(warning -> {\n                                JSONObject jsonWarning = new JSONObject();\n                                jsonWarning.put(\"url\", warning.url);\n                                jsonWarning.put(\"message\", warning.message);\n                                return jsonWarning;\n                            }).collect(toList());\n                        unresolvedSecurityWarnings.put(\"warnings\", warnings);\n                        jsonObject.put(\"unresolvedSecurityWarnings\", unresolvedSecurityWarnings);\n                    }\n                    if (plugin.releaseTimestamp != null) {\n                        JSONObject releaseTimestamp = new JSONObject();\n                        releaseTimestamp.put(\"iso8601\", Functions.iso8601DateTime(plugin.releaseTimestamp));\n                        releaseTimestamp.put(\"displayValue\", Messages.PluginManager_ago(Functions.getTimeSpanString(plugin.releaseTimestamp)));\n                        jsonObject.put(\"releaseTimestamp\", releaseTimestamp);\n                    }\n                    return jsonObject;\n                })\n                .collect(toList());\n            plugins.addAll(sitePlugins);\n            if (plugins.size() >= limit) {\n                break;\n            }\n        }\n\n        JSONArray mappedPlugins = new JSONArray();\n        mappedPlugins.addAll(plugins);\n\n        return hudson.util.HttpResponses.okJSON(mappedPlugins);\n    }",
            "commit_message": "[SECURITY-3037]"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2023-27898"
    },
    {
        "data": {
            "function_name": "getLinkParser",
            "function_code": "private static LinkParser getLinkParser() {\n        return Utils.getComponent(LinkParser.class);\n    }",
            "commit_message": "XWIKI-20327: Escape closing HTML macro in XWikiDocument#display"
        },
        "CWE": "CWE-74",
        "CVE": "CVE-2023-29523"
    },
    {
        "data": {
            "function_name": "setLogid",
            "function_code": "public void setLogid(String logid) {\n        synchronized (this) {\n            if (\"-\".equals(logid)) {\n                this.logid = \"\";\n            } else {\n                this.logid = SolrTools.escapeSpecialCharacters(logid);\n            }\n        }\n    }",
            "commit_message": "Only allow setting logId to a value matching [\\w-]+\n\nrefs #24571"
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2023-29014"
    },
    {
        "data": {
            "function_name": "cacheImplyingPermissions",
            "function_code": "rivate static Set<Permission> cacheImplyingPermissions(Permission permission) {\n    Set<Permission> implyingPermissions;\n    if (PermissionHelper.isDangerous(permission)) {\n      /*\n       * if this is a dangerous permission, fall back to Administer unless we're in compat mode\n       */\n      implyingPermissions = getImplyingPermissions(Jenkins.ADMINISTER);\n    } else {\n      implyingPermissions = new HashSet<>();\n\n      // Get the implying permissions\n      for (Permission p = permission; p != null; p = p.impliedBy) {\n        implyingPermissions.add(p);\n      }\n    }\n\n    implyingPermissionCache.put(permission, implyingPermissions);\n    return implyingPermissions;\n  }\n",
            "commit_message": "[SECURITY-3053]"
        },
        "CWE": "CWE-281",
        "CVE": "CVE-2023-28668"
    },
    {
        "data": {
            "function_name": "getNextElementUpwards",
            "function_code": "private DomNode getNextElementUpwards(final DomNode startingNode) {\n            if (startingNode == DomNode.this) {\n                return null;\n            }\n            final DomNode parent = startingNode.getParentNode();\n            if (parent == null || parent == DomNode.this) {\n                return null;\n            }\n            DomNode next = parent.getNextSibling();\n            while (next != null && !isAccepted(next)) {\n                next = next.getNextSibling();\n            }\n            if (next == null) {\n                return getNextElementUpwards(parent);\n            }\n            return next;\n        }",
            "commit_message": "remove recursion to make the fuzzer happy"
        },
        "CWE": "CWE-787",
        "CVE": "CVE-2023-2798"
    },
    {
        "data": {
            "function_name": "updateConfig",
            "function_code": "private RemotingCommand updateConfig(ChannelHandlerContext ctx, RemotingCommand request) {\n        if (ctx != null) {\n            log.info(\"updateConfig called by {}\", RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        byte[] body = request.getBody();\n        if (body != null) {\n            String bodyStr;\n            try {\n                bodyStr = new String(body, MixAll.DEFAULT_CHARSET);\n            } catch (UnsupportedEncodingException e) {\n                log.error(\"updateConfig byte array to string error: \", e);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"UnsupportedEncodingException \" + e);\n                return response;\n            }\n\n            Properties properties = MixAll.string2Properties(bodyStr);\n            if (properties == null) {\n                log.error(\"updateConfig MixAll.string2Properties error {}\", bodyStr);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"string2Properties error\");\n                return response;\n            }\n\n            this.namesrvController.getConfiguration().update(properties);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }",
            "commit_message": "Make configPath unable to update at runtime"
        },
        "CWE": "CWE-94",
        "CVE": "CVE-2023-33246"
    },
    {
        "data": {
            "function_name": "getF2CPerfMetricList",
            "function_code": "csRequest.getRegionId() + \"-\" + e.getMessage());\n        }\n        return result;\n    }\n\n    private static void existRegion(GetMetricsRequest getMetricsRequest) {\n        if (StringUtils.isEmpty(getMetricsRequest.getRegionId())) {\n            throw new Fit2cloudException(10002, \"\u533a\u57df\u4e3a\u5fc5\u586b\u53c2\u6570\");\n        }\n    }\n\n    /**\n     * \u83b7\u53d6\u865a\u62df\u673a\u76d1\u63a7\u6307\u6807\u6570\u636e\n     * \u9664\u4e86CPU,\u5185\u5b58\uff0c\u78c1\u76d8\u4e0e\u7f51\u7edc\u90fd\u662f\u57fa\u7840\u6307\u6807\u7684\u6570\u636e\uff0c\u56e0\u4e3aAPI\u65e0\u6cd5\u83b7\u53d6\n     *\n     * @param getMetricsRequest \u76d1\u63a7\u67e5\u8be2\u53c2\u6570\n     * @return \u76d1\u63a7\u6570\u636e\n     */\n    private static List<F2CPerfMetricMonitorData> getVmPerfMetric(GetMetricsRequest getMetricsRequest) {\n        HuaweiVmCredential credential = JsonUtil.parseObject(getMetricsRequest.getCredential(), HuaweiVmCredential.class);\n        List<F2CPerfMetricMonitorData> result = new ArrayList<>();\n        List<F2CVirtualMachine> vms = listVirtualMachine(getListVmRequest(getMetricsRequest));\n        if (vms.size() == 0) {\n            return result;\n        }\n        CesClient cesClient = credential.getCesClient(getMetricsRequest.getRegionId());\n        // \u5faa\u73af\u4e91\u4e3b\u673a\n    ",
            "commit_message": "Merge pull request #176 from CloudExplorer-Dev/pr@main@fix_huawei_monitoring_bug\n\nfix(vm-service): \u534e\u4e3a\u4e91\u540c\u6b65\u76d1\u63a7\u6570\u636e\u6570\u636e\u7c92\u5ea6\u8c03\u6574\u4e3a300"
        },
        "CWE": "CWE-284",
        "CVE": "CVE-2023-2845"
    },
    {
        "data": {
            "function_name": "getF2CPerfMetricList",
            "function_code": "csRequest.getRegionId() + \"-\" + e.getMessage());\n        }\n        return result;\n    }\n\n    private static void existRegion(GetMetricsRequest getMetricsRequest) {\n        if (StringUtils.isEmpty(getMetricsRequest.getRegionId())) {\n            throw new Fit2cloudException(10002, \"\u533a\u57df\u4e3a\u5fc5\u586b\u53c2\u6570\");\n        }\n    }\n\n    /**\n     * \u83b7\u53d6\u865a\u62df\u673a\u76d1\u63a7\u6307\u6807\u6570\u636e\n     * \u9664\u4e86CPU,\u5185\u5b58\uff0c\u78c1\u76d8\u4e0e\u7f51\u7edc\u90fd\u662f\u57fa\u7840\u6307\u6807\u7684\u6570\u636e\uff0c\u56e0\u4e3aAPI\u65e0\u6cd5\u83b7\u53d6\n     *\n     * @param getMetricsRequest \u76d1\u63a7\u67e5\u8be2\u53c2\u6570\n     * @return \u76d1\u63a7\u6570\u636e\n     */\n    private static List<F2CPerfMetricMonitorData> getVmPerfMetric(GetMetricsRequest getMetricsRequest) {\n        HuaweiVmCredential credential = JsonUtil.parseObject(getMetricsRequest.getCredential(), HuaweiVmCredential.class);\n        List<F2CPerfMetricMonitorData> result = new ArrayList<>();\n        List<F2CVirtualMachine> vms = listVirtualMachine(getListVmRequest(getMetricsRequest));\n        if (vms.size() == 0) {\n            return result;\n        }\n        CesClient cesClient = credential.getCesClient(getMetricsRequest.getRegionId());\n        // \u5faa\u73af\u4e91\u4e3b\u673a\n    ",
            "commit_message": "Merge pull request #176 from CloudExplorer-Dev/pr@main@fix_huawei_monitoring_bug\n\nfix(vm-service): \u534e\u4e3a\u4e91\u540c\u6b65\u76d1\u63a7\u6570\u636e\u6570\u636e\u7c92\u5ea6\u8c03\u6574\u4e3a300"
        },
        "CWE": "CWE-862",
        "CVE": "CVE-2023-2844"
    },
    {
        "data": {
            "function_name": "getF2CPerfMetricList",
            "function_code": "csRequest.getRegionId() + \"-\" + e.getMessage());\n        }\n        return result;\n    }\n\n    private static void existRegion(GetMetricsRequest getMetricsRequest) {\n        if (StringUtils.isEmpty(getMetricsRequest.getRegionId())) {\n            throw new Fit2cloudException(10002, \"\u533a\u57df\u4e3a\u5fc5\u586b\u53c2\u6570\");\n        }\n    }\n\n    /**\n     * \u83b7\u53d6\u865a\u62df\u673a\u76d1\u63a7\u6307\u6807\u6570\u636e\n     * \u9664\u4e86CPU,\u5185\u5b58\uff0c\u78c1\u76d8\u4e0e\u7f51\u7edc\u90fd\u662f\u57fa\u7840\u6307\u6807\u7684\u6570\u636e\uff0c\u56e0\u4e3aAPI\u65e0\u6cd5\u83b7\u53d6\n     *\n     * @param getMetricsRequest \u76d1\u63a7\u67e5\u8be2\u53c2\u6570\n     * @return \u76d1\u63a7\u6570\u636e\n     */\n    private static List<F2CPerfMetricMonitorData> getVmPerfMetric(GetMetricsRequest getMetricsRequest) {\n        HuaweiVmCredential credential = JsonUtil.parseObject(getMetricsRequest.getCredential(), HuaweiVmCredential.class);\n        List<F2CPerfMetricMonitorData> result = new ArrayList<>();\n        List<F2CVirtualMachine> vms = listVirtualMachine(getListVmRequest(getMetricsRequest));\n        if (vms.size() == 0) {\n            return result;\n        }\n        CesClient cesClient = credential.getCesClient(getMetricsRequest.getRegionId());\n        // \u5faa\u73af\u4e91\u4e3b\u673a\n    ",
            "commit_message": "Merge pull request #176 from CloudExplorer-Dev/pr@main@fix_huawei_monitoring_bug\n\nfix(vm-service): \u534e\u4e3a\u4e91\u540c\u6b65\u76d1\u63a7\u6570\u636e\u6570\u636e\u7c92\u5ea6\u8c03\u6574\u4e3a300"
        },
        "CWE": "CWE-284",
        "CVE": "CVE-2023-2845"
    },
    {
        "data": {
            "function_name": "getF2CPerfMetricList",
            "function_code": "csRequest.getRegionId() + \"-\" + e.getMessage());\n        }\n        return result;\n    }\n\n    private static void existRegion(GetMetricsRequest getMetricsRequest) {\n        if (StringUtils.isEmpty(getMetricsRequest.getRegionId())) {\n            throw new Fit2cloudException(10002, \"\u533a\u57df\u4e3a\u5fc5\u586b\u53c2\u6570\");\n        }\n    }\n\n    /**\n     * \u83b7\u53d6\u865a\u62df\u673a\u76d1\u63a7\u6307\u6807\u6570\u636e\n     * \u9664\u4e86CPU,\u5185\u5b58\uff0c\u78c1\u76d8\u4e0e\u7f51\u7edc\u90fd\u662f\u57fa\u7840\u6307\u6807\u7684\u6570\u636e\uff0c\u56e0\u4e3aAPI\u65e0\u6cd5\u83b7\u53d6\n     *\n     * @param getMetricsRequest \u76d1\u63a7\u67e5\u8be2\u53c2\u6570\n     * @return \u76d1\u63a7\u6570\u636e\n     */\n    private static List<F2CPerfMetricMonitorData> getVmPerfMetric(GetMetricsRequest getMetricsRequest) {\n        HuaweiVmCredential credential = JsonUtil.parseObject(getMetricsRequest.getCredential(), HuaweiVmCredential.class);\n        List<F2CPerfMetricMonitorData> result = new ArrayList<>();\n        List<F2CVirtualMachine> vms = listVirtualMachine(getListVmRequest(getMetricsRequest));\n        if (vms.size() == 0) {\n            return result;\n        }\n        CesClient cesClient = credential.getCesClient(getMetricsRequest.getRegionId());\n        // \u5faa\u73af\u4e91\u4e3b\u673a\n    ",
            "commit_message": "Merge pull request #176 from CloudExplorer-Dev/pr@main@fix_huawei_monitoring_bug\n\nfix(vm-service): \u534e\u4e3a\u4e91\u540c\u6b65\u76d1\u63a7\u6570\u636e\u6570\u636e\u7c92\u5ea6\u8c03\u6574\u4e3a300"
        },
        "CWE": "CWE-862",
        "CVE": "CVE-2023-2844"
    },
    {
        "data": {
            "function_name": "cancel",
            "function_code": "@Override\n    public WorkflowContext cancel(Integer processId, String operator, String remark) {\n        Preconditions.expectNotBlank(operator, ErrorCodeEnum.INVALID_PARAMETER, \"operator cannot be null\");\n        Preconditions.expectNotNull(processId, \"processId cannot be null\");\n\n        WorkflowContext context = workflowContextBuilder.buildContextForProcess(processId);\n        List<WorkflowTaskEntity> pendingTasks = taskEntityMapper.selectByProcess(processId, TaskStatus.PENDING);\n        for (WorkflowTaskEntity taskEntity : pendingTasks) {\n            WorkflowTask task = context.getProcess().getTaskByName(taskEntity.getName());\n            context.setActionContext(new WorkflowContext.ActionContext()\n                    .setAction(WorkflowAction.CANCEL)\n                    .setTaskEntity(taskEntity)\n                    .setOperator(operator)\n                    .setRemark(remark)\n                    .setTask(task));\n            this.processorExecutor.executeComplete(task, context);\n        }\n\n        return context;\n    }",
            "commit_message": "[INLONG-7798][Manager] Add user authentication when operate workflow"
        },
        "CWE": "CWE-552",
        "CVE": "CVE-2023-31064"
    },
    {
        "data": {
            "function_name": "bindTag",
            "function_code": "@Override\n    public Boolean bindTag(BindTagRequest request, String operator) {\n        LOGGER.info(\"begin to bind or unbind cluster tag: {}\", request);\n        Preconditions.expectNotNull(request, \"inlong cluster info cannot be empty\");\n        String clusterTag = request.getClusterTag();\n        Preconditions.expectNotBlank(clusterTag, ErrorCodeEnum.INVALID_PARAMETER, \"cluster tag cannot be empty\");\n        InlongClusterTagEntity exist = clusterTagMapper.selectByTag(clusterTag);\n        userService.checkUser(exist.getInCharges(), operator,\n                \"Current user does not have permission to bind or unbind cluster tag\");\n        if (CollectionUtils.isNotEmpty(request.getBindClusters())) {\n            request.getBindClusters().forEach(id -> {\n                InlongClusterEntity entity = clusterMapper.selectById(id);\n                Set<String> tagSet = Sets.newHashSet(entity.getClusterTags().split(InlongConstants.COMMA));\n                tagSet.add(clusterTag);\n                String updateTags = Joiner.on(\",\").join(tagSet);\n                InlongClusterEntity updateEntity = clusterMapper.selectById(id);\n                updateEntity.setClusterTags(updateTags);\n                updateEntity.setModifier(operator);\n                if (InlongConstants.AFFECTED_ONE_ROW != clusterMapper.updateById(updateEntity)) {\n                    LOGGER.error(\"cluster has already updated with name={}, type={}, curVersion={}\",\n                            updateEntity.getName(), updateEntity.getType(), updateEntity.getVersion());\n                    throw new BusinessException(ErrorCodeEnum.CONFIG_EXPIRED);\n                }\n            });\n        }\n\n        if (CollectionUtils.isNotEmpty(request.getUnbindClusters())) {\n            request.getUnbindClusters().forEach(id -> {\n                InlongClusterEntity entity = clusterMapper.selectById(id);\n                this.removeClusterTag(entity, clusterTag, operator);\n            });\n        }\n        LOGGER.info(\"success to bind or unbind cluster tag {} by {}\", request, operator);\n        return true;\n    }",
            "commit_message": "[INLONG-7946][Manager] Add user authentication when bind clusterTag"
        },
        "CWE": "CWE-732",
        "CVE": "CVE-2023-31454"
    },
    {
        "data": {
            "function_name": "generateTooltipHtml",
            "function_code": "private String generateTooltipHtml(CmsListInfoBean infoBean) {\n\n        StringBuffer result = new StringBuffer();\n        result.append(\"<p><b>\").append(CmsClientStringUtil.shortenString(infoBean.getTitle(), 70)).append(\"</b></p>\");\n        if (infoBean.hasAdditionalInfo()) {\n            for (CmsAdditionalInfoBean additionalInfo : infoBean.getAdditionalInfo()) {\n                result.append(\"<p>\").append(additionalInfo.getName()).append(\":&nbsp;\");\n                // shorten the value to max 45 characters\n                result.append(CmsClientStringUtil.shortenString(additionalInfo.getValue(), 45)).append(\"</p>\");\n            }\n        }\n        return result.toString();\n    }",
            "commit_message": "Fixed XSS issue in gallery result view (github issue #652)."
        },
        "CWE": "CWE-79",
        "CVE": "CVE-2023-31544"
    },
    {
        "data": {
            "function_name": "initialCfgs",
            "function_code": "public static List<Configuration> initialCfgs(InstallationConfig cfg) {\n\t\tList<Configuration> list = new ArrayList<>();\n\t\taddCfg(list, CONFIG_CRYPT, cfg.getCryptClassName(), Configuration.Type.STRING,\n\t\t\t\t\"This Class is used for Authentification-Crypting. \"\n\t\t\t\t\t\t+ \"Be carefull what you do here! If you change it while \"\n\t\t\t\t\t\t+ \"running previous Pass of users will not be workign anymore! \"\n\t\t\t\t\t\t+ \"for more Information see https://openmeetings.apache.org/CustomCryptMechanism.html\"\n\t\t\t\t\t\t, VER_1_9);\n\n\t\taddCfg(list, CONFIG_REGISTER_FRONTEND, String.valueOf(cfg.isAllowFrontendRegister()), Configuration.Type.BOOL\n\t\t\t\t, \"Is USER register available on login screen\", VER_1_8);\n\t\taddCfg(list, CONFIG_REGISTER_SOAP, String.valueOf(true), Configuration.Type.BOOL, \"Is user register available via SOAP/REST\", VER_3_0);\n\t\taddCfg(list, CONFIG_REGISTER_OAUTH, String.valueOf(true), Configuration.Type.BOOL, \"Is user register available via OAuth\", VER_3_0);\n\t\t// this group_id is the Group of users who register through the frontend or SOAP\n\t\taddCfg(list, CONFIG_DEFAULT_GROUP_ID, String.valueOf(getDefaultGroup()), Configuration.Type.NUMBER, \"\", VER_1_8);\n\n\t\taddCfg(list, CONFIG_SMTP_SERVER, cfg.getSmtpServer(), Configuration.Type.STRING, \"this is the smtp server to send messages\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_SMTP_PORT, String.valueOf(cfg.getSmtpPort()), Configuration.Type.NUMBER, \"this is the smtp server port normally 25\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_SMTP_SYSTEM_EMAIL, cfg.getMailReferer(), Configuration.Type.STRING, \"all send e-mails by the system will have this address\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_SMTP_USER, cfg.getMailAuthName(), Configuration.Type.STRING, \"System auth email username\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_SMTP_PASS, cfg.getMailAuthPass(), Configuration.Type.STRING, \"System auth email password\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_SMTP_TLS, String.valueOf(cfg.isMailUseTls()), Configuration.Type.BOOL, \"Enable TLS\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_SMTP_TIMEOUT_CON, \"30000\", Configuration.Type.NUMBER,\n\t\t\t\t\"Socket connection timeout value in milliseconds. Default is 30 seconds (30000).\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_SMTP_TIMEOUT, \"30000\", Configuration.Type.NUMBER,\n\t\t\t\t\"Socket I/O timeout value in milliseconds. Default is 30 seconds (30000).\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_APPLICATION_NAME, DEFAULT_APP_NAME, Configuration.Type.STRING, \"Name of the Browser Title window\", VER_3_0);\n\n\t\t// \"1\" == \"EN\"\n\t\taddCfg(list, CONFIG_DEFAULT_LANG, String.valueOf(cfg.getDefaultLangId()), Configuration.Type.NUMBER, \"Default System Language ID see languages.xml\", VER_1_8);\n\n\t\taddCfg(list, CONFIG_DOCUMENT_DPI, String.valueOf(cfg.getDocDpi()), Configuration.Type.NUMBER,\n\t\t\t\t\"dpi for conversion of PDF to images (should be an integer between 50 and  600 with a default value of 150 dpi)\", VER_2_0);\n\n\t\taddCfg(list, CONFIG_DOCUMENT_QUALITY, String.valueOf(cfg.getDocQuality()), Configuration.Type.NUMBER,\n\t\t\t\t\"compression quality for conversion of PDF to images (should be an integer between 1 and 100, with a default value of 90)\", VER_2_0);\n\n\t\taddCfg(list, CONFIG_PATH_IMAGEMAGIC, cfg.getImageMagicPath(), Configuration.Type.STRING, \"Path to ImageMagick tools\", VER_2_0);\n\n\t\taddCfg(list, CONFIG_PATH_SOX, cfg.getSoxPath(), Configuration.Type.STRING, \"Path To SoX-Tools\", VER_2_0);\n\n\t\taddCfg(list, CONFIG_PATH_FFMPEG, cfg.getFfmpegPath(), Configuration.Type.STRING, \"Path To FFMPEG\", VER_2_0);\n\t\taddCfg(list, CONFIG_PATH_OFFICE, cfg.getOfficePath(), Configuration.Type.STRING,\n\t\t\t\t\"The path to OpenOffice/LibreOffice (optional) please set this to the real path in case jodconverter is unable to find OpenOffice/LibreOffice installation automatically\", VER_2_0);\n\n\t\taddCfg(list, CONFIG_DASHBOARD_RSS_FEED1, cfg.getUrlFeed(), Configuration.Type.STRING, \"Feed URL 1\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_DASHBOARD_RSS_FEED2, cfg.getUrlFeed2(), Configuration.Type.STRING, \"Feed URL 2\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_EMAIL_AT_REGISTER, String.valueOf(cfg.isSendEmailAtRegister()), Configuration.Type.BOOL,\n\t\t\t\t\"User get a EMail with their Account data.\", VER_2_0);\n\n\t\taddCfg(list, CONFIG_EMAIL_VERIFICATION, String.valueOf(cfg.isSendEmailWithVerficationCode()), Configuration.Type.BOOL,\n\t\t\t\tString.format(\"User must activate their account by clicking on the \"\n\t\t\t\t\t\t+ \"activation-link in the registering Email \"\n\t\t\t\t\t\t+ \"It makes no sense to make this(%s) 'true' while \"\n\t\t\t\t\t\t+ \"%s is 'false' cause you need to send a EMail.\", CONFIG_EMAIL_VERIFICATION, CONFIG_EMAIL_AT_REGISTER), VER_2_0);\n\n\t\taddCfg(list, CONFIG_APPLICATION_BASE_URL, cfg.getBaseUrl(), Configuration.Type.STRING, \"Base URL your Openmeetings installation will be accessible at.\", \"3.0.2\");\n\n\t\t// ***************************************\n\t\t// ***************************************\n\t\t// SIP Integration Coniguration Values\n\t\t// ***************************************\n\n\t\taddCfg(list, CONFIG_SIP_ENABLED, String.valueOf(cfg.isSipEnable()), Configuration.Type.BOOL, \"Enable to enable the red5SIP integration \", VER_1_9);\n\t\taddCfg(list, CONFIG_SIP_ROOM_PREFIX, cfg.getSipRoomPrefix(), Configuration.Type.STRING, \"Numerical prefix for OM rooms created inside the SIP\", VER_1_9);\n\t\taddCfg(list, CONFIG_SIP_EXTEN_CONTEXT, cfg.getSipExtenContext(), Configuration.Type.STRING, \"Enable to enable the red5SIP integration \", VER_1_9);\n\n\t\t// ***************************************\n\t\t// ***************************************\n\t\t// Timezone settings\n\t\t// ***************************************\n\n\t\taddCfg(list, CONFIG_DEFAULT_TIMEZONE, cfg.getTimeZone(), Configuration.Type.STRING, \"This is the default timezone if nothing is specified\", VER_1_9);\n\n\t\t// ***************************************\n\t\t// ***************************************\n\t\t// additional settings\n\t\t// ***************************************\n\n\t\taddCfg(list, CONFIG_SCREENSHARING_QUALITY, \"1\", Configuration.Type.NUMBER, \"\"\"\n\t\t\t\tDefault selection in ScreenSharing Quality:\n\t\t\t\t 0 - bigger frame rate, no resize\n\t\t\t\t 1 - no resize\n\t\t\t\t 2 - size == 1/2 of selected area\n\t\t\t\t 3 - size == 3/8 of selected area\"\"\", VER_3_0_3);\n\n\t\taddCfg(list, CONFIG_SCREENSHARING_FPS, \"10\", Configuration.Type.NUMBER, \"Default selection in ScreenSharing FPS\", VER_3_0_3);\n\t\taddCfg(list, CONFIG_SCREENSHARING_FPS_SHOW, String.valueOf(true), Configuration.Type.BOOL, \"Is screensharing FPS should be displayed or not\", VER_3_0_3);\n\t\taddCfg(list, CONFIG_SCREENSHARING_ALLOW_REMOTE, String.valueOf(true), Configuration.Type.BOOL\n\t\t\t\t, \"Is remote control will be enabled while screensharing. Allowing remote control will be not possible in case it is set to 'false'\", \"3.0.4\");\n\n\t\taddCfg(list, CONFIG_DASHBOARD_SHOW_MYROOMS, String.valueOf(true), Configuration.Type.BOOL, \"Show 'My Rooms' widget on dashboard\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_DASHBOARD_SHOW_CHAT, String.valueOf(true), Configuration.Type.BOOL, \"Show 'Global Chat' outside the room\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_DASHBOARD_SHOW_RSS, String.valueOf(false), Configuration.Type.BOOL, \"Show RSS widget on dashboard\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_MAX_UPLOAD_SIZE, String.valueOf(DEFAULT_MAX_UPLOAD_SIZE), Configuration.Type.NUMBER,\n\t\t\t\t\"Maximum size of upload file (bytes)\", VER_1_8);\n\n\t\taddCfg(list, CONFIG_APPOINTMENT_REMINDER_MINUTES, String.valueOf(getAppointmentReminderMinutes()), Configuration.Type.NUMBER,\n\t\t\t\t\"The number of minutes before reminder emails are send. Set to 0 to disable reminder emails\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_LOGIN_MIN_LENGTH, String.valueOf(USER_LOGIN_MINIMUM_LENGTH), Configuration.Type.NUMBER,\n\t\t\t\t\"Number of chars needed in a user login\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_PASS_MIN_LENGTH, String.valueOf(USER_PASSWORD_MINIMUM_LENGTH), Configuration.Type.NUMBER,\n\t\t\t\t\"Number of chars needed in a user password\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_CALENDAR_ROOM_CAPACITY, \"50\", Configuration.Type.NUMBER,\n\t\t\t\t\"Default number of participants conference room created via calendar\", VER_1_9);\n\n\t\taddCfg(list, CONFIG_KEYCODE_ARRANGE, \"Shift+F8\", Configuration.Type.HOTKEY\n\t\t\t\t, \"A hot key code for arrange video windows functionality\", VER_2_0);\n\t\taddCfg(list, CONFIG_KEYCODE_MUTE_OTHERS, \"Shift+F12\", Configuration.Type.HOTKEY\n\t\t\t\t, \"A hot key code for the 'mute others' functionality\", VER_2_0);\n\t\taddCfg(list, CONFIG_KEYCODE_MUTE, \"Shift+F7\", Configuration.Type.HOTKEY\n\t\t\t\t, \"A hot key code for the 'mute/unmute audio' functionality\", VER_2_0);\n\n\t\t// system-wide ldap params\n\t\taddCfg(list, CONFIG_DEFAULT_LDAP_ID, \"0\", Configuration.Type.NUMBER, \"Ldap domain selected by default in the login screen\", VER_1_9);\n\n\t\t// set inviter's email address as ReplyTo in email invitations\n\t\taddCfg(list, CONFIG_REPLY_TO_ORGANIZER, String.valueOf(cfg.isReplyToOrganizer()), Configuration.Type.BOOL,\n\t\t\t\t\"Set inviter's email address as ReplyTo in email invitations\", VER_2_0);\n\n\t\taddCfg(list, CONFIG_DEFAULT_LANDING_ZONE, \"user/dashboard\", Configuration.Type.STRING\n\t\t\t\t, \"Area to be shown to the user after login. Possible values are: \"\n\t\t\t\t\t\t+ \"user/dashboard, user/calendar, user/record, rooms/my, rooms/group, rooms/public\"\n\t\t\t\t\t\t+ \", profile/messages, profile/edit, profile/search, profile/invitation, profile/widget\"\n\t\t\t\t\t\t+ \", admin/user, admin/connection\"\n\t\t\t\t\t\t+ \", admin/group, admin/room, admin/config, admin/lang, admin/ldap, admin/oauth2, admin/backup, admin/email\", \"2.1.x\");\n\n\t\t// oauth2 params\n\t\taddCfg(list, CONFIG_IGNORE_BAD_SSL, String.valueOf(false), Configuration.Type.BOOL, \"\"\"\n\t\t\t\tSet \"yes\" or \"no\" to enable/disable ssl certifications checking for OAuth2\n\t\t\t\tWARNING: it is not secure to ignore bad SSL\"\"\", VER_3_0);\n\n\t\taddCfg(list, CONFIG_REDIRECT_URL_FOR_EXTERNAL, \"\", Configuration.Type.STRING,\n\t\t\t\t\"Users entered the room via invitationHash or secureHash will be redirected to this URL on connection lost\", VER_3_0);\n\t\taddCfg(list, CONFIG_GOOGLE_ANALYTICS_CODE, null, Configuration.Type.STRING, \"Code for Google Analytics\", \"3.1.0\");\n\t\taddCfg(list, CONFIG_EXT_PROCESS_TTL, String.valueOf(getExtProcessTtl()), Configuration.Type.NUMBER, String.format(\"Time to live in minutes for external processes such as conversion via ffmpeg (default %s minutes)\", getExtProcessTtl()), VER_3_3_0);\n\t\taddCfg(list, CONFIG_MYROOMS_ENABLED, String.valueOf(true), Configuration.Type.BOOL, \"Users are allowed to create personal rooms\", \"3.3.2\");\n\t\taddCfg(list, CONFIG_REMINDER_MESSAGE, null, Configuration.Type.STRING, \"Reminder message to notify about upcoming appointment, generated message will be used if not set\", VER_2_0);\n\t\taddCfg(list, CONFIG_MP4_AUDIO_RATE, String.valueOf(getAudioRate()), Configuration.Type.NUMBER, \"Audio sampling rate (in Hz) for MP4 video\", \"4.0.1\");\n\t\taddCfg(list, CONFIG_MP4_AUDIO_BITRATE, String.valueOf(getAudioBitrate()), Configuration.Type.STRING, \"Audio bitrate for MP4 video\", \"4.0.1\");\n\t\taddCfg(list, CONFIG_REST_ALLOW_ORIGIN, null, Configuration.Type.STRING, \"List of addresses browser Ajax REST requests are allowed from\", \"4.0.2\");\n\t\taddCfg(list, CONFIG_FNAME_MIN_LENGTH, String.valueOf(USER_LOGIN_MINIMUM_LENGTH), Configuration.Type.NUMBER,\n\t\t\t\t\"Number of chars needed in a user first name\", \"4.0.4\");\n\t\taddCfg(list, CONFIG_LNAME_MIN_LENGTH, String.valueOf(USER_LOGIN_MINIMUM_LENGTH), Configuration.Type.NUMBER,\n\t\t\t\t\"Number of chars needed in a user last name\", \"4.0.4\");\n\t\taddCfg(list, CONFIG_CHAT_SEND_ON_ENTER, String.valueOf(false), Configuration.Type.BOOL,\n\t\t\t\t\"Controls if chat message will be set on Enter (default: send on Ctrl+Enter)\", \"4.0.5\");\n\t\taddCfg(list, CONFIG_MP4_VIDEO_PRESET, \"medium\", Configuration.Type.STRING,\n\t\t\t\t\"Preset (encoder optimization settings) to be used while performing mp4 conversion.\"\n\t\t\t\t\t+ \"Valid values are: ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow\", \"4.0.5\");\n\t\taddCfg(list, CONFIG_CAM_FPS, \"30\", Configuration.Type.NUMBER, \"Camera FPS, should be positive number in range (0, 60]\", VER_5_0_0);\n\t\taddCfg(list, CONFIG_MIC_RATE, \"22\", Configuration.Type.NUMBER, \"The rate at which the microphone should capture sound, in kHz. The default value is 22 kHz.\", VER_5_0_0);\n\t\taddCfg(list, CONFIG_MIC_ECHO, String.valueOf(true), Configuration.Type.BOOL, \"Whether or not echo cancellation is preferred and/or required.\", VER_5_0_0);\n\t\taddCfg(list, CONFIG_MIC_NOISE, String.valueOf(true), Configuration.Type.BOOL, \"Whether noise suppression is preferred and/or required.\", VER_5_0_0);\n\t\taddCfg(list, CONFIG_DISPLAY_NAME_EDITABLE, String.valueOf(false), Configuration.Type.BOOL, \"Is user will be able to edit his/her display name (default false).\", \"4.0.7\");\n\t\taddCfg(list, CONFIG_KEYCODE_QUICKPOLL, \"Ctrl+Alt+KeyQ\", Configuration.Type.HOTKEY\n\t\t\t\t, \"A hot key code to start quick poll\", \"4.0.10\");\n\t\taddCfg(list, CONFIG_AUTO_OPEN_SHARING, String.valueOf(false), Configuration.Type.BOOL, \"Whether shared screen should be auto-opened.\", VER_5_0_0);\n\t\taddCfg(list, CONFIG_KEYCODE_ARRANGE_RESIZE, \"Ctrl+Shift+KeyA\", Configuration.Type.HOTKEY\n\t\t\t\t, \"A hot key code to arrange video windows bottom-to-top with resize to 120x90\", VER_5_0_0);\n\t\tfinal String cspMore = \", more info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\";\n\t\taddCfg(list, CONFIG_CSP_FONT, DEFAULT_CSP_FONT, Configuration.Type.STRING, \"Value for 'font-src' directive of 'Content-Security-Policy' header (default: \"\n\t\t\t\t+ DEFAULT_CSP_FONT + \")\" + cspMore, VER_5_0_0);\n\t\taddCfg(list, CONFIG_CSP_FRAME, SELF.getValue(), Configuration.Type.STRING, \"Value for 'frame-src' directive of 'Content-Security-Policy' header (default: \"\n\t\t\t\t+ SELF + \")\" + cspMore, VER_5_0_0);\n\t\taddCfg(list, CONFIG_CSP_IMAGE, DEFAULT_CSP_DATA, Configuration.Type.STRING, \"Value for 'image-src' directive of 'Content-Security-Policy' header (default: \"\n\t\t\t\t+ DEFAULT_CSP_DATA + \")\" + cspMore, VER_5_0_0);\n\t\taddCfg(list, CONFIG_CSP_MEDIA, DEFAULT_CSP_DATA, Configuration.Type.STRING, \"Value for 'media-src' directive of 'Content-Security-Policy' header (default: \"\n\t\t\t\t+ DEFAULT_CSP_DATA + \")\" + cspMore, VER_5_0_0);\n\t\taddCfg(list, CONFIG_CSP_SCRIPT, STRICT_DYNAMIC.getValue(), Configuration.Type.STRING, \"Value for 'script-src' directive of 'Content-Security-Policy' header (default: \"\n\t\t\t\t+ STRICT_DYNAMIC + \")\" + cspMore, VER_5_0_0);\n\t\taddCfg(list, CONFIG_CSP_STYLE, DEFAULT_CSP_STYLE, Configuration.Type.STRING, \"Value for 'style-src' directive of 'Content-Security-Policy' header (default: \"\n\t\t\t\t+ DEFAULT_CSP_STYLE + \")\" + cspMore, VER_5_0_0);\n\t\taddCfg(list, CONFIG_SMTP_SSL, String.valueOf(false), Configuration.Type.BOOL, \"Enable SSL\", VER_5_0_0);\n\t\taddCfg(list, CONFIG_CSP_ENABLED, String.valueOf(true), Configuration.Type.BOOL, \"Whether or not CSP secure headers are enabled\", VER_5_0_0);\n\t\taddCfg(list, CONFIG_PASS_CHECK_UPPER, String.valueOf(true), Configuration.Type.BOOL, \"Whether or not Password MUST contain uppercase characters\", VER_5_0_1);\n\t\taddCfg(list, CONFIG_PASS_CHECK_DIGIT, String.valueOf(true), Configuration.Type.BOOL, \"Whether or not Password MUST contain numeric\", VER_5_0_1);\n\t\taddCfg(list, CONFIG_PASS_CHECK_SPECIAL, String.valueOf(true), Configuration.Type.BOOL, \"Whether or not Password MUST contain special character\", VER_5_0_1);\n\t\taddCfg(list, CONFIG_APPOINTMENT_PRE_START_MINUTES, String.valueOf(getAppointmentPreStartMinutes()), Configuration.Type.NUMBER\n\t\t\t\t, \"How many minutes before the start the room should be open (default: \" + getAppointmentPreStartMinutes() + \")\", VER_5_0_1);\n\t\taddCfg(list, CONFIG_RECORDING_ENABLED, String.valueOf(true), Configuration.Type.BOOL, \"Whether or not recording functionality is enabled\", \"6.0.0\");\n\t\taddCfg(list, CONFIG_THEME, getTheme(), Configuration.Type.STRING, \"UI theme, possible values are Cerulean, Cosmo, Cyborg, Darkly, Flatly, \"\n\t\t\t\t+ \"Journal, Litera, Lumen, Lux, Materia, Minty, Pulse, Sandstone, Simplex, Sketchy, Slate, Solar, Spacelab, Superhero, \"\n\t\t\t\t+ \"United, Yeti\", \"6.1.0\");\n\n\t\taddCfg(list, CONFIG_OTP_ENABLED, String.valueOf(false), Configuration.Type.BOOL, \"Whether or not Time-based One Time Passwords are enabled\", \"6.3.0\");\n\t\treturn list;\n\t}",
            "commit_message": "[OPENMEETINGS-2765] config creation is fixed"
        },
        "CWE": "CWE-20",
        "CVE": "CVE-2023-29246"
    },
    {
        "data": {
            "function_name": "badRequest",
            "function_code": "public void badRequest(final String explain) {\n    badRequest(new BadRequestException(explain));\n  }",
            "commit_message": "Fix for #2269 and #2267 XSS vulnerability.\nEscaping the user supplied input when outputing the HTML for the old BadRequest\nHTML handlers should help. Thanks to the reporters.\nFixes CVE-2018-13003."
        },
        "CWE": "CWE-74",
        "CVE": "CVE-2023-36812"
    },
    {
        "data": {
            "function_name": "getFile",
            "function_code": "private File getFile(String... path) {\n        File result = baseDir;\n        for (String p : path) {\n            result = new File(result, p);\n        }\n        return result;\n    }",
            "commit_message": "Merge pull request from GHSA-2h6c-rv6q-494v\n\nFix dependency cache path traversal vulnerability"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2023-35946"
    },
    {
        "data": {
            "function_name": "resetPwd",
            "function_code": "\n    }\n\n    @Override\n    public boolean resetPwd(ResetPwdRequest request, UserDto currentUser) {\n        Optional.ofNullable(curren",
            "commit_message": "fix: \u7528\u6237\u4fee\u6539\u5bc6\u7801\u589e\u52a0\u540e\u7aef\u63a5\u53e3\u6821\u9a8c"
        },
        "CWE": "CWE-521",
        "CVE": "CVE-2023-3423"
    },
    {
        "data": {
            "function_name": "init",
            "function_code": "static void init() {\n        try {\n            impl = SnappyLoader.loadSnappyApi();\n        }\n        catch (Exception e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }",
            "commit_message": "Merge pull request from GHSA-fjpj-2g6w-x25r\n\n* Fixed integer overflow by checking if bytesize is bigger than input length, then throwing exception\n\n* Fixed integer overflow by checking if bytesize is bigger than input length, then throwing exception\n\n* Fixed integer overflow by checking if bytesize is bigger than input length, then throwing exception\n\n* improved error messages by adding new error enum INPUT_TOO_LARGE in SnappyErrorCode.java, and added happy and sad cases in SnappyTest.java\n\n* fixed mispelling: validArrayInputLength --> isInvalidArrayInputLength\n\n* switched SnappyError into ILLEGAL_ARGUMENT in SnappyErrorCode.java and Snappy.java and fixed a typo in error comment\n\n* Fix buffer size boundary tests\n\n* Remove negative array size tests\n\n* updated comments for unit test\n\n---------\n\nCo-authored-by: Taro L. Saito <leo@xerial.org>"
        },
        "CWE": "CWE-190",
        "CVE": "CVE-2023-34454"
    },
    {
        "data": {
            "function_name": "removeSharesyPanel",
            "function_code": "tringUtils.isBlank(panelGroup.getName())) {\n            return;\n        }\n        panelShareOutDTOS.forEach(shareOut -> {\n            SysLogConstants.SOURCE_TYPE buiType = buiType(shareOut.getType());\n            DeLogUtils.save(SysLogConstants.OPERATE_TYPE.UNSHARE, SysLogConstants.SOURCE_TYPE.PANEL, panelId, panelGroup.getPid(), shareOut.getTargetId(), buiType);\n        });\n\n        Map<Integer, List<PanelShareOutDTO>> listMap = panelShareOutDTOS.stream().collect(Collectors.groupingBy(dto -> dto.getType()));\n        AuthURD urd = new AuthURD();\n        for (Map.Entry<Integer, List<PanelShareOutDTO>> entry : listMap.entrySet()) {\n            List<PanelShareOutDTO> dtoList = entry.getValue();\n            if (CollectionUtils.isNotEmpty(dtoList)) {\n                List<Long> curTargetIds = dtoList.stream().map(dto -> Long.parseLong(dto.getTargetId())).collect(Collectors.toList());\n                buildRedAuthURD(entry.getKey(), curTargetIds, urd);\n            }\n        }\n        Set<Long> userIds = AuthUtils.userIdsByURD(urd);\n        if (CollectionUtils.isNotEmpty(userIds)) {\n            CurrentUserDto user = AuthUtils.getUser();\n            Gson gson = new Gson();\n            userIds.forEach(userId -> {\n                if (!user.getUserId().equals(userId)) {\n                    String msg = panelGroup.getName();\n                    List<String> msgParam = new ArrayList<>();\n                    msgParam.add(panelId);\n                    DeMsgutil.sendMsg(userId, 3L, user.getNickName() + \" \u53d6\u6d88\u5206\u4eab\u4e86\u4eea\u8868\u677f\u3010\" + msg + \"\u3011\uff0c\u8bf7\u67e5\u6536!\", gson.toJson(msgParam));\n                }\n            });\n        }\n    }\n\n    private SysLogConstants.SOURCE_TYPE buiType(Integer type) {\n        SysLogConstants.SOURCE_TYPE targetType = SysLogConstants.SOURCE_TYPE.USER;\n        if (type == 1) {\n            targetType = SysLogConstants.SOURCE_TYPE.ROLE;\n        } else if (type == 2) {\n            targetType = SysLogConstants.SOURCE_TYPE.DEPT;\n        }\n        return targetType;\n    }\n\n    @Transactional\n    public void removeShares(PanelShareRemoveRequest removeRequest) {\n        String panelId = re",
            "commit_message": "feat(\u4eea\u8868\u677f): \u5220\u9664\u5206\u4eabIDOR\u6f0f\u6d1e"
        },
        "CWE": "CWE-639",
        "CVE": "CVE-2023-32310"
    },
    {
        "data": {
            "function_name": "setIgnorePermissions",
            "function_code": "@Override\n    public void setIgnorePermissions(final boolean ignorePermissions) {\n        this.ignorePermissions = ignorePermissions;\n    }",
            "commit_message": "Avoid override target symlink by standard file in AbstractUnArchiver"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2023-37460"
    },
    {
        "data": {
            "function_name": "getResponse",
            "function_code": "public static Response getResponse(byte [] bytes) {\n        Response temp = null;\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            temp = Response.parseXML(new ByteArrayInputStream(bytes));\n        } catch (SAMLException se) {\n            debug.error(\"getResponse : \" , se);\n        }\n        return temp;\n    }",
            "commit_message": "GHSL-2023-143, GHSL-2023-144, deny unsigned SAML response (#624)"
        },
        "CWE": "CWE-287",
        "CVE": "CVE-2023-37471"
    },
    {
        "data": {
            "function_name": "untar",
            "function_code": "protected void untar(File destDir, InputStream inputStream) throws IOException {\n        TarArchiveInputStream tin = new TarArchiveInputStream(inputStream);\n        TarArchiveEntry tarEntry = null;\n\n        while ((tarEntry = tin.getNextTarEntry()) != null) {\n            File destEntry = new File(destDir, tarEntry.getName());\n            File parent = destEntry.getParentFile();\n\n            if (!parent.exists()) {\n                parent.mkdirs();\n            }\n\n            if (tarEntry.isDirectory()) {\n                destEntry.mkdirs();\n            } else {\n                FileOutputStream fout = new FileOutputStream(destEntry);\n                try {\n                    IOUtils.copy(tin, fout);\n                } finally {\n                    fout.close();\n                }\n            }\n        }\n\n        tin.close();\n    }",
            "commit_message": "Merge pull request from GHSA-m88m-crr9-jvqq\n\n* Fix zip slip vulnerability in project import command\n\n* Add zip-slip.tar test resource"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2023-37476"
    },
    {
        "data": {
            "function_name": "findSubscriptionsInternal",
            "function_code": "@Override\n  protected MultiValueMap<String, String> findSubscriptionsInternal(String destination, Message<?> message) {\n    MultiValueMap<String, String> result = this.destinationCache.getSubscriptions(destination, message);\n    return filterSubscriptions(result, message);\n  }",
            "commit_message": "AMBARI-25111. Intermittent ConcurrentModificationException exception during STOMP message emitting.(Replace StandardEvaluationContext with SimpleEvaluationContext)"
        },
        "CWE": "CWE-917",
        "CVE": "CVE-2022-42009"
    },
    {
        "data": {
            "function_name": "eval",
            "function_code": "public Optional<Number> eval(JMXMetricHolder jmxMetricHolder) {\n      List<Object> metrics = jmxMetricHolder.findAll(propertyList);\n      if (metrics.isEmpty()) {\n        return Optional.empty();\n      } else {\n        Object value = getValue().eval(metrics);\n        return value instanceof Number ? Optional.of((Number)value) : Optional.empty();\n      }\n    }",
            "commit_message": "Replace StandardEvaluationContext with SimpleEvaluationContext in Metricsource.Contributed by Vishal Suvagia."
        },
        "CWE": "CWE-917",
        "CVE": "CVE-2022-45855"
    },
    {
        "data": {
            "function_name": "genericToFile",
            "function_code": "@Converter\n    public static File genericToFile(GenericFile<File> genericFile, Exchange exchange) throws IOException {\n        Object body = genericFile.getBody();\n        File file;\n        if (body instanceof byte[]) {\n            byte[] bos = (byte[]) body;\n            String destDir = System.getProperty(\"java.io.tmpdir\");\n            if (destDir != null && !destDir.endsWith(File.separator)) {\n                destDir += File.separator;\n            }\n            file = new File(destDir, genericFile.getFileName());\n            if (!file.getCanonicalPath().startsWith(destDir)) {\n                throw new IOException(\"File is not jailed to the destination directory\");\n            }\n            Files.write(file.toPath(), bos, StandardOpenOption.CREATE);\n            // delete the temporary file on exit, as other routing may need the file for post processing\n            file.deleteOnExit();\n        } else {\n            file = (File) body;\n        }\n        return file;\n    }",
            "commit_message": "CAMEL-19421 - Camel-Jira: Use Files.createTempFile in FileConverter instead of creating File directly\n\nSigned-off-by: Andrea Cosentino <ancosen@gmail.com>"
        },
        "CWE": "CWE-200",
        "CVE": "CVE-2023-34442"
    },
    {
        "data": {
            "function_name": "matches",
            "function_code": "default boolean matches(String domain) {\n        return false;\n    }",
            "commit_message": "Tighten up the $private HTTP rule\n\n - Block multicast and the fd00::/8 address ranges.\n - Block several cloud metadata providers which sit outside the standard\n   address ranges."
        },
        "CWE": "CWE-918",
        "CVE": "CVE-2023-37262"
    },
    {
        "data": {
            "function_name": "extract",
            "function_code": "public void extract() throws IOException {\n        log.debug(\"Extract content of '{}' to '{}'\", source, destination);\n\n        // delete destination directory if exists\n        if (destination.exists() && destination.isDirectory()) {\n            FileUtils.delete(destination.toPath());\n        }\n\n        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n            ZipEntry zipEntry;\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                File file = new File(destination, zipEntry.getName());\n\n                // create intermediary directories - sometimes zip don't add them\n                File dir = new File(file.getParent());\n\n                mkdirsOrThrow(dir);\n\n                if (zipEntry.isDirectory()) {\n                    mkdirsOrThrow(file);\n                } else {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    try (FileOutputStream fos = new FileOutputStream(file)) {\n                        while ((length = zipInputStream.read(buffer)) >= 0) {\n                            fos.write(buffer, 0, length);\n                        }\n                    }\n                }\n            }\n        }\n    }",
            "commit_message": "Add security checks to prevent directory traversal when decompressing (#538)"
        },
        "CWE": "CWE-22",
        "CVE": "CVE-2023-40828"
    },
    {
        "data": {
            "function_name": "getDefaultEngineConfig",
            "function_code": "private static EngineConfiguration getDefaultEngineConfig() {\n        if (_defaultEngineConfig == null) {\n            _defaultEngineConfig =\n                EngineConfigurationFactoryFinder.newFactory().getClientEngineConfig();\n        }\n        return _defaultEngineConfig;\n    }",
            "commit_message": "Filter out unsupported protocols in the client class ServiceFactory"
        },
        "CWE": "CWE-20",
        "CVE": "CVE-2023-40743"
    },
    {
        "data": {
            "function_name": "initialValue",
            "function_code": "@Override\n        protected SimpleDateFormat initialValue() {\n\t\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n\t\t\tformat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n\t\t\treturn format;\n        }",
            "commit_message": "fixes XML eXternal Entity injection (XXE)"
        },
        "CWE": "CWE-611",
        "CVE": "CVE-2023-46502"
    },
    {
        "data": {
            "function_name": "parseAudiences",
            "function_code": "protected Optional<List<String>> parseAudiences(JwtClaims claims) {\n        return parseClaimList(claims, JwtClaims.AUDIENCE);\n    }",
            "commit_message": "Merge pull request from GHSA-qw22-8w9r-864h\n\nThe `aud` claim should contain the Client ID.\n\nhttps://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n\n> Clients MUST validate the ID Token in the Token Response in the following manner:\n...\n> 1.2. The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery) MUST exactly match the value of the iss (issuer) Claim.\n> 1.3. The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified by the iss (issuer) Claim as an audience.\n\nThe audience claim is [validated correctly when obtained from authorisation server.](https://github.com/micronaut-projects/micronaut-security/blob/master/security-oauth2/src/main/java/io/micronaut/security/oauth2/endpoint/token/response/validation/DefaultOpenIdTokenResponseValidator.java#L122) with the [`AudienceClaimValidator`](https://github.com/micronaut-projects/micronaut-security/blob/master/security-oauth2/src/main/java/io/micronaut/security/oauth2/endpoint/token/response/validation/AudienceClaimValidator.java).\n\nHowever, if the user set `micronaut.security.authentication` to `idtoken`, the token validation of a new request does not validate `aud` claim to match the Client ID if the `iss` claim matched an existing issuer in the application.\n\nThis change fixes this vulnerability."
        },
        "CWE": "CWE-284",
        "CVE": "CVE-2023-36820"
    },
    {
        "data": {
            "function_name": "authenticateClient",
            "function_code": "@Override\n    public void authenticateClient(ClientAuthenticationFlowContext context) {\n\n        X509ClientCertificateLookup provider = context.getSession().getProvider(X509ClientCertificateLookup.class);\n        if (provider == null) {\n            logger.errorv(\"\\\"{0}\\\" Spi is not available, did you forget to update the configuration?\",\n                    X509ClientCertificateLookup.class);\n            return;\n        }\n\n        X509Certificate[] certs = null;\n        ClientModel client = null;\n        try {\n            certs = provider.getCertificateChain(context.getHttpRequest());\n            String client_id = null;\n            MediaType mediaType = context.getHttpRequest().getHttpHeaders().getMediaType();\n            boolean hasFormData = mediaType != null && mediaType.isCompatible(MediaType.APPLICATION_FORM_URLENCODED_TYPE);\n\n            MultivaluedMap<String, String> formData = hasFormData ? context.getHttpRequest().getDecodedFormParameters() : null;\n            MultivaluedMap<String, String> queryParams = context.getSession().getContext().getUri().getQueryParameters();\n\n            if (formData != null) {\n                client_id = formData.getFirst(OAuth2Constants.CLIENT_ID);\n            }\n\n            if (client_id == null && queryParams != null) {\n                client_id = queryParams.getFirst(OAuth2Constants.CLIENT_ID);\n            }\n\n            if (client_id == null) {\n                client_id = context.getSession().getAttribute(\"client_id\", String.class);\n            }\n\n            if (client_id == null) {\n                Response challengeResponse = ClientAuthUtil.errorResponse(Response.Status.BAD_REQUEST.getStatusCode(), \"invalid_client\", \"Missing client_id parameter\");\n                context.challenge(challengeResponse);\n                return;\n            }\n\n            client = context.getRealm().getClientByClientId(client_id);\n            if (client == null) {\n                context.failure(AuthenticationFlowError.CLIENT_NOT_FOUND, null);\n                return;\n            }\n            context.getEvent().client(client_id);\n            context.setClient(client);\n\n            if (!client.isEnabled()) {\n                context.failure(AuthenticationFlowError.CLIENT_DISABLED, null);\n                return;\n            }\n        } catch (GeneralSecurityException e) {\n            logger.errorf(\"[X509ClientCertificateAuthenticator:authenticate] Exception: %s\", e.getMessage());\n            context.attempted();\n            return;\n        }\n\n        if (certs == null || certs.length == 0) {\n            // No x509 client cert, fall through and\n            // continue processing the rest of the authentication flow\n            logger.debug(\"[X509ClientCertificateAuthenticator:authenticate] x509 client certificate is not available for mutual SSL.\");\n            context.attempted();\n            return;\n        }\n\n        OIDCAdvancedConfigWrapper clientCfg = OIDCAdvancedConfigWrapper.fromClientModel(client);\n        String subjectDNRegexp = client.getAttribute(ATTR_SUBJECT_DN);\n        if (subjectDNRegexp == null || subjectDNRegexp.length() == 0) {\n            logger.errorf(\"[X509ClientCertificateAuthenticator:authenticate] \" + ATTR_SUBJECT_DN + \" is null or empty\");\n            context.attempted();\n            return;\n        }\n\n        Optional<String> matchedCertificate;\n\n        if (clientCfg.getAllowRegexPatternComparison()) {\n            Pattern subjectDNPattern = Pattern.compile(subjectDNRegexp);\n\n            matchedCertificate = Arrays.stream(certs)\n                    .map(certificate -> certificate.getSubjectDN().getName())\n                    .filter(subjectdn -> subjectDNPattern.matcher(subjectdn).matches())\n                    .findFirst();\n        } else {\n            // OIDC/OAuth2 does not use regex comparison as it expects exact DN given in the format according to RFC4514. See RFC8705 for the details.\n            // We allow custom OIDs attributes to be \"expanded\" or not expanded in the given Subject DN\n            X500Principal expectedDNPrincipal = new X500Principal(subjectDNRegexp, CUSTOM_OIDS_REVERSED);\n\n            matchedCertificate = Arrays.stream(certs)\n                    .filter(certificate -> expectedDNPrincipal.getName(X500Principal.RFC2253, CUSTOM_OIDS).equals(certificate.getSubjectX500Principal().getName(X500Principal.RFC2253, CUSTOM_OIDS)))\n                    .map(certificate -> certificate.getSubjectDN().getName())\n                    .findFirst();\n        }\n\n        if (!matchedCertificate.isPresent()) {\n            // We do quite expensive operation here, so better check the logging level beforehand.\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"[X509ClientCertificateAuthenticator:authenticate] Couldn't match any certificate for expected Subject DN '\" + subjectDNRegexp + \"' with allow regex pattern '\" + clientCfg.getAllowRegexPatternComparison() + \"'.\");\n                logger.debug(\"[X509ClientCertificateAuthenticator:authenticate] Available SubjectDNs: \" +\n                        Arrays.stream(certs)\n                                .map(cert -> cert.getSubjectDN().getName())\n                                .collect(Collectors.toList()));\n            }\n            context.attempted();\n            return;\n        } else {\n            logger.debug(\"[X509ClientCertificateAuthenticator:authenticate] Matched \" + matchedCertificate.get() + \" certificate.\");\n        }\n\n        context.success();\n    }",
            "commit_message": "Improper Client Certificate Validation for OAuth/OpenID clients (#20)\n\nCo-authored-by: Stian Thorgersen <stianst@gmail.com>"
        },
        "CWE": "CWE-295",
        "CVE": "CVE-2023-2422"
    }
]